---
title: OSCAL Profile Resolution
description: Transforming a profile into the tailored catalog it represents
---
<h2 xmlns="http://www.w3.org/1999/xhtml" id="d2e8-head">Abstract</h2><p xmlns="http://www.w3.org/1999/xhtml">This specification provides the minimal requirements for processing an OSCAL Profile to create a new OSCAL Catalog Document. This process of applying a profile to a catalog to create a new catalog is called
      <b class="term">Profile Resolution</b>. Not all OSCAL Profiles will be resolved, nor are expected to be; however, the resolution requirements in this document are crucial to understanding the intended functionality of any given OSCAL Profile.
       This specification is intended for software developers who intend to develop an OSCAL Profile Resolver, or for OSCAL Profile authors who want a more in-depth understanding of profile resolution.
    </p><h2 xmlns="http://www.w3.org/1999/xhtml" id="d2e14-head">Introduction</h2><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e16-head">Purpose</h3><p xmlns="http://www.w3.org/1999/xhtml">This document defines the normative requirements for an OSCAL Profile Resolver. Profile resolution is core to addressing a fundamental OSCAL requirement: 
        the representation of baselines separately from the control catalogs on which they depend). The requirements for resolution must therefore be well-defined and deterministic, 
        enabling tool developers and parties exchanging OSCAL Profiles can work from a common understanding.</p><p xmlns="http://www.w3.org/1999/xhtml">No requirements are placed on implementation-level details, instead, requirements are laid out as what the output of resolution must look like given a certain input.
         By adhering to these requirements OSCAL producers, OSCAL consumers, and any other members of the OSCAL ecosystem can create and resolve profiles deterministically, 
         with repeatable results, regardless of the tool used.</p><h2 xmlns="http://www.w3.org/1999/xhtml" id="d2e20-head">Reading This Document</h2><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e23-head">Terminology</h3><p xmlns="http://www.w3.org/1999/xhtml">Many core OSCAL concepts are defined on the <a class="a" href="https://pages.nist.gov/OSCAL/concepts/terminology/">OSCAL Terminology Page</a>. The most important are repeated in this document, but readers should verify their understanding of all core OSCAL terms before reading this document.</p><p xmlns="http://www.w3.org/1999/xhtml">Additionally, many terms in the wider domain have overloaded definitions. Unless defined otherwise by OSCAL or explicitly in this document, terms are to be understood as defined in the <a class="a" href="https://csrc.nist.gov/glossary">NIST CSRC Glossary</a>.</p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>
            <b class="term">profile</b>- an OSCAL Profile Document. Defines a set of inclusions, modifications, and transformations against a
            <b class="term">catalog</b>. See
            <a class="a" href="https://pages.nist.gov/OSCAL/concepts/layer/control/profile/">OSCAL Profile Model</a>.
          </p></li><li><p>
            <b class="term">catalog</b>- an OSCAL Catalog Document. Contains a well-defined set of
            <b class="term">controls</b>. See
            <a class="a" href="https://pages.nist.gov/OSCAL/concepts/layer/control/catalog/">OSCAL Catalog Model</a>.
          </p></li><li><p>
            <b class="term">control</b>- an individual item in an OSCAL Catalog. See
            <a class="a" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r5.pdf">NIST Special Publication 800-53r5</a>for a more in-depth definition.
          </p></li><li><p>
            <b class="term">profile resolution</b>- The process of consuming one or more OSCAL Profiles and the OSCAL Catalogs that they reference to produce a new tailored
            <b class="term">catalog</b>. See
            <a class="a" href="https://pages.nist.gov/OSCAL/concepts/layer/control/catalog/">OSCAL Catalog Model</a>.
          </p></li><li><p>
            <b class="term">source</b>- refers to the profile document that is input into the profile resolution processor. This is the profile being resolved. In this document, when referring to objects from the
            <b class="term">source</b>document, the following style is used:
            <code class="src">source-object</code>.
          </p></li><li><p>
            <b class="term">target</b>- the intended output of the transformation, a catalog document. In this document, when referring to objects of a
            <b class="term">target</b>document, the following style is used:
            <code class="tgt">target-object</code>.
          </p></li><li><p>
            <b class="term">directive</b>- refers to an object or combination of objects in source documents, which is designed to affect a particular outcome in the target catalog. For the most part, directives are in the source profile document â€“ for example, a
            <code class="src">set-parameter</code>object in a source profile is a directive to set a parameter value in the target catalog.
          </p></li><li><p>
            <b class="term">original order</b>- the order of objects as presented in the
            <b class="term">source</b>document(s). See XYZ.
          </p></li><li><p>
            <b class="term">canonical order</b>- the order of objects as required in the appropriate OSCAL Model (Profile, Catalog, etc.). This can differ from the above order when converting between "ordered" formats (ex. XML), and "non-ordered" formats (ex. JSON).
          </p></li></ul><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e111-head">Requirement Keywords</h3><p xmlns="http://www.w3.org/1999/xhtml">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in
        <a class="a" href="https://tools.ietf.org/pdf/bcp14.pdf">BCP 14</a>
        <a class="a" href="https://tools.ietf.org/pdf/rfc2119">[RFC2119]</a>
        <a class="a" href="https://tools.ietf.org/pdf/rfc8174">[RFC8174]</a>when, and only when, they appear in all capitals, as shown here.
      </p><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e124-head">Use of YAML</h3><p xmlns="http://www.w3.org/1999/xhtml">OSCAL supports a variety of serialization formats, each of which having it's own benefits and drawbacks. In this document, YAML (YAML Ain't Markup Language) is used to represent the various objects of the
        <b class="term">source</b>and
        <b class="term">target</b>. All examples and in-line references will be represented using
        <a class="a" href="https://yaml.org/spec/1.2/spec.html">YAML 1.2</a>.
      </p><p xmlns="http://www.w3.org/1999/xhtml">YAML maps cleanly to JSON, thus allowing easy use of existing JSON/XML transformers where needed. With that in mind, the
        <a class="a" href="https://pages.nist.gov/OSCAL/reference/latest/complete/json-reference/">OSCAL Complete JSON Reference</a>is a valuable resource for understanding the YAML-based information structures used in this document. All JSON properties and objects defined in the reference equate to a YAML mapping, list, or dictionary.
      </p><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e140-head">Reading YAML Examples</h3><p xmlns="http://www.w3.org/1999/xhtml">YAML is a particularly human-readable format. For those unfamiliar with the format, the basics:</p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>Each line is a key-value pair, presented as
            <code class="code">key:value</code>, or as
            <code class="code">key:</code>with any number of list items on the following lines.
          </p></li><li><p>Indentation, spacing, and white space matters. Items below a key and indented one level in are members (or children) of that key.</p></li><li><p>List items are represented with a preceding dash
            <code class="code">- listitemkey:value</code>.
          </p></li></ul><p xmlns="http://www.w3.org/1999/xhtml">The YAML specification is freely available here:
        <a class="a" href="https://yaml.org/spec/1.2/spec.html">YAML 1.2</a>.
      </p><p xmlns="http://www.w3.org/1999/xhtml">Additionally, in order to unambiguously express information, this specification uses additional conventions, as described below.</p><p xmlns="http://www.w3.org/1999/xhtml">There are some objects whose values must be determined dynamically at processing time. The most common example of this is timestamping output as it is processed. In this case, and any other dynamic-value cases, the expression
        <code class="code">${{ }}</code>is used.
      </p><p xmlns="http://www.w3.org/1999/xhtml">For example:</p>{{< highlight xml>}}last-modified: ${{ timestamp }}{{</highlight>}}<p xmlns="http://www.w3.org/1999/xhtml">Indicates the
        <code class="tgt">last-modified</code>object should be produced with contents generated appropriately, in this case, the timestamp at the time of processing.
      </p><p xmlns="http://www.w3.org/1999/xhtml">Some examples may elide content to enhance readability or save space. In these cases, a YAML comment (any line that starts with
        <code class="code">#</code>) will be used to explain the elision.
      </p><p xmlns="http://www.w3.org/1999/xhtml">Finally, although examples are syntactically faithful to OSCAL, they are not necessarily always formally valid in every respect. For example, OSCAL defines allowed property names (
        <code class="src">props</code>) and values, and those rules may not be observed here. Examples are given for purposes of illustrating profile resolution semantics only, and should not be taken as normative for any actual use.
      </p><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e183-head">Document Layout</h3><p xmlns="http://www.w3.org/1999/xhtml">The specification is broken into the following major sections:</p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>
            <b class="term">Phases of Profile Resolution</b>- Lays out the necessary steps and phases of profile resolution. As each phase executes, the processor is understood to be creating and editing an intermediate representation of the output. There is one section for each of the three main phases.
          </p></li><li><p>
            <b class="term">Target Catalog Structure</b>- Provides the requirements for structuring the final output from the intermediate representation generated throughout the previous section.
          </p></li></ul><p xmlns="http://www.w3.org/1999/xhtml">
        <b class="term">Please note</b>: As referenced in the Purpose section
        [See: <a href="#d2e16-head" class="xref">Purpose</a>], this specification makes no hard requirements on the specifics of implementation. It is feasible for an implementation to use no intermediate representation, and to directly and iteratively build the output. As long as all processing and output requirements are satisfied, any approach is allowed. With that said, the specification has been laid out to aid in implementation by providing a clear organization as a sequence of distinct operations.
      </p><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e203-head">The Intermediate and Implementation Guidance</h3><p xmlns="http://www.w3.org/1999/xhtml">The overall intent of this document, in addition to defining strict requirements, is to provide rough guidelines on implementing an OSCAL Profile Resolution Tool. To this end, each phase of resolution will be framed as a series of transformations applied to an internal data structure that is persistent throughout the process. We call this "the intermediate".</p><p xmlns="http://www.w3.org/1999/xhtml">Any examples that are labelled as "Intermediate" are pseudo-code, designed to represent how this data structure might look as we apply different operations to it. The example intermediates are often not valid OSCAL, and are not to be taken as guidance, but rather a useful visualization tool for implementers.</p><p xmlns="http://www.w3.org/1999/xhtml">The authors believe that applying the steps of resolution in order against this intermediate representation is the simplest way to achieve full compliance with the specification. However, there is no requirement to implement profile resolution in this way. Requirements are given as rules on the output of resolution, and as such, tools can operate any way they would like internally.</p><h2 xmlns="http://www.w3.org/1999/xhtml" id="d2e208-head">Phases of Profile Processing</h2><p xmlns="http://www.w3.org/1999/xhtml">An OSCAL Profile has three major sections, each which correspond to a phase of profile resolution. In order to complete the profile resolution process, each section must be fully parsed and a catalog output created.</p><p xmlns="http://www.w3.org/1999/xhtml">It is strongly RECOMMENDED that implementations execute the following steps in the order that they are provided here. While it is possible to achieve compliance with a non-standard approach, the iterative nature of profile resolution lends itself to linear processing.</p><p xmlns="http://www.w3.org/1999/xhtml">The three steps are
      <b class="term">import</b>;
      <b class="term">merge</b>; and
      <b class="term">modify</b>. In brief:
    </p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>
          <b class="term">import</b>- identifies one or more control sources (catalogs or profiles) and defines the controls within them to be included in the result catalog. If nothing is imported, no resulting catalog is produced. Invoked by
          <code class="src">import</code>directives in source profiles;
        </p></li><li><p>
          <b class="term">merge</b>- designates the rules for how controls will be organized (ordered and/or grouped) and merged (addressing conflicts or ambiguities) in the result catalog. Controlled by the
          <code class="src">merge</code>directive in source profiles; if none are included, default merge rules are used;
        </p></li><li><p>
          <b class="term">modify</b>- indicates how controls and their parameters in the underlying catalog are to be altered, edited, amended or added in the final result catalog. Logical evaluation and parameter constraints provide advanced processing. Controlled by the
          <code class="src">modify</code>directive in source profiles. If a
          <code class="src">modify</code>directive is not provided, no changes will be made to the controls that have been imported/merged.
        </p></li></ul><p xmlns="http://www.w3.org/1999/xhtml">As described in the previous section, when resolved, an OSCAL Profile takes the form of an OSCAL Catalog. The phases described below will produce outputs conforming to the catalog model.</p><h2 xmlns="http://www.w3.org/1999/xhtml" id="d2e245-head">Import Phase</h2><p xmlns="http://www.w3.org/1999/xhtml">A profile begins by listing a set of catalogs and/or profiles to be imported. Each is represented by a resolvable resource URI and a directive specifying which controls to import from that resource. These resources may be available as static resources, or they may be produced dynamically on request; such as is the case when a profile is imported. Imports are given in sequence after the metadata:</p>{{< highlight xml>}}
      
profile:
  uuid: ~
  metadata: ~
  imports:
    - href: ${{ catalog URI }}
      include-controls: ${{ list of selected controls }}
    - href: ${{ profile URI }}
      include-controls: ${{ list of selected controls }} 
    {{</highlight>}}<p xmlns="http://www.w3.org/1999/xhtml">In an import directive, the reference to the resource to be imported appears on an
      <code class="src">href</code>child object. It takes either of two forms, external or internal:
    </p><p xmlns="http://www.w3.org/1999/xhtml">An external reference appears as an absolute or relative URL:</p>{{< highlight xml>}}
      
profile:
  uuid: ~
  metadata: ~
  imports:
    - href: >-
        https://github.com/usnistgov/oscal-content/tree
        /master/nist.gov/SP800-53/rev4/yaml/NIST_SP-800-53_rev4_catalog.yaml
      include-controls: ${{ list of selected controls }}
    - href: "../../NIST_SP-800-53_rev5_catalog.yaml"
      include-controls: ${{ list of selected controls }} 
    {{</highlight>}}<p xmlns="http://www.w3.org/1999/xhtml">While an internal reference appears as below (see
      [See: <a href="#d2e300-head" class="xref">Internal References</a>]):
    </p>{{< highlight xml>}}
      
profile:
  uuid: ~
  metadata: ~
  imports:
    - href: #80052rev4
      include-controls: ${{ list of selected controls }}
    - href: #80052rev5
      include-controls: ${{ list of selected controls }} 
    {{</highlight>}}<p xmlns="http://www.w3.org/1999/xhtml">All import directives will contain either
      <code class="src">include-all: ~</code>or
      <code class="src">include-controls</code>. These directives indicate which controls from the imported document are explicitly selected
      [See: <a href="#d2e394-head" class="xref">Including Controls</a>].
    </p><p xmlns="http://www.w3.org/1999/xhtml">The following section contains requirements for processing the
      importchild of a source
      profile
    </p><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e277-head">Import href Requirements</h3><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e279-head">Import URI Resolution</h4><p xmlns="http://www.w3.org/1999/xhtml">Tools MUST resolve URIs by following
          <a class="a" href="https://datatracker.ietf.org/doc/html/rfc3986#section-5">Section 5 of RFC3986</a>, with the exception of URI Fragments (URIs that start with "#"). URI Fragments MUST instead be resolved as defined in
          [See: <a href="#d2e300-head" class="xref">Internal References</a>].
        </p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e288-head">Import Resource Acquisition</h4><p xmlns="http://www.w3.org/1999/xhtml">Tools MUST acquire resources at the resolved URI by following
          <a class="a" href="https://datatracker.ietf.org/doc/html/rfc3986#section-5">Section 5 of RFC3986</a>, with the exception of URI Fragments (URIs that start with "#"). URI Fragments MUST instead be acquired as defined in
          [See: <a href="#d2e300-head" class="xref">Internal References</a>].
        </p><p xmlns="http://www.w3.org/1999/xhtml">For the purposes of resolving URIs using the above specification, the Base URI MUST be considered to be the absolute URI of the containing profile.</p><p xmlns="http://www.w3.org/1999/xhtml">In the case that acquiring a resource fails, the tool MUST cease processing and provide an error. In order to ensure profile resolution results in the same catalog regardless of which tool resolves it, all imports must successfully resolve. While this may cause inconvenience if resources are frequently not available, it ensures interoperability.</p><p xmlns="http://www.w3.org/1999/xhtml">Note that receiving a cached version of an import, or resolving an import that is otherwise unavailable through some other (but automatic) means still satisfies the above requirement. This specification does not put requirements on the precise function of the import, as long as the correct document is retrieved.</p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e300-head">Internal References</h4><p xmlns="http://www.w3.org/1999/xhtml">URI Fragments in OSCAL represent internal references to other OSCAL objects in the same document. These references follow the pattern of "#{{objectID}}". For example, the URI Fragment "#param1" is referencing the Parameter with unique ID "param1".</p><p xmlns="http://www.w3.org/1999/xhtml">In the context of the Import Phase, internal references will only appear as a reference to a profile or catalog that is in the <code class="src">resources</code> section of the source. When tools encounter such a reference, they MUST locate the object in <code class="src">resources</code> with the matching ID value, and resolve the import using the
          rlinkURI and the above resolution requirements.
        </p><p xmlns="http://www.w3.org/1999/xhtml">If the object fetched cannot be found or is not a valid OSCAL object, the tool MUST cease processing and provide an error.</p>{{< highlight xml>}}
          
profile:
  metadata: ~
  imports:
    - href: "#nist-sp800-53_catalog"
      include-controls: ${{ list of selected controls }}
    
  # Content Elided
    
  backmatter:
    resources:
      - uuid: "nist-sp800-53_catalog"
        description: "NIST SP 800-53 rev5 OSCAL format, on Github."
        rlinks:
          - rlink:
              href: >-
                https://github.com/usnistgov/oscal-content/tree
                /master/nist.gov/SP800-53/rev4/xml/NIST_SP-800-53_rev5_catalog.xml   
        {{</highlight>}}<h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e314-head">Resolving Imports of Profiles</h4><p xmlns="http://www.w3.org/1999/xhtml">If the resource acquired is an OSCAL Profile, the tool MUST apply this specification to resolve it, then continue processing having imported the resulting catalog.</p><p xmlns="http://www.w3.org/1999/xhtml">When a profile imports a profile, the subordinate profile SHOULD be resolved first into a catalog using this specification, before it is imported. This presents the possibility of circular imports, when a profile is directed to import itself either directly or indirectly.</p><p xmlns="http://www.w3.org/1999/xhtml">A
          <b class="term">circular import</b>occurs when a profile imports an already imported profile, which was called at an earlier place in the import hierarchy. For example, if profile A imports profile B, and profile B imports profile A, the second import is circular. (An import at the top can only be circular if a profile tries to import itself.) If A imports B, B imports C and C imports A, Câ€™s import is circular.
        </p><p xmlns="http://www.w3.org/1999/xhtml">Note that an import can only be circular within the context of processing a particular profile. In the last example, Câ€™s import would not be circular if invoked in the context of resolving B by itself.</p><p xmlns="http://www.w3.org/1999/xhtml">If a processor encounters a
          <b class="term">circular import</b>as described above (self-imports are inherently circular), the processor MUST cease processing and generate an error.
        </p><div xmlns="http://www.w3.org/1999/xhtml" class="mapping"><p>A profile identified as
            <code class="code">home_profile.yaml</code>imports another one identified as
            <code class="code">circular_profile.yaml</code>:
          </p>{{< highlight xml>}}
            
profile:
  id: "home_profile.yaml"
  metadata: ~
  imports:
    - href: "circular_profile.yaml"
      include-controls: ${{ list of selected controls }} 
          {{</highlight>}}<p>In turn this file invokes
            <code class="code">home_profile.xml</code>:
          </p>{{< highlight xml>}}
            
profile:
  id: "circular_profile.yaml"
  metadata: ~
  imports:
    - href: "home_profile.yaml"
      include-controls: ${{ list of selected controls }} 
          {{</highlight>}}<p>Once detected, this circular import will result in an error and no further processing will take place.</p>{{< highlight xml>}}
            
  # Import at href: "circular_profile.yaml" failed.
  # Reason: Error during profile import:
  # Import at href: "home_profile.yaml" failed.
  # Reason: Circular import 
          {{</highlight>}}</div><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e345-head">Multiple imports</h4><p xmlns="http://www.w3.org/1999/xhtml">Each import directive is processed to produce a set of controls. Note that this occurs even if the same catalog is imported multiple times: each distinct import collects controls into a separate
          selection:
        </p>{{< highlight xml>}}
          
profile:
  uuid: ~
  metadata: ~
  imports:
    - href: "#catalog"
      include-controls:
       - with-ids:
          - ac-1
          - ac-2
    - href: "#catalog"
      include-controls:
       - with-ids:
          - ac-3
          - ac-4 
        {{</highlight>}}{{< highlight xml>}}
          
intermediate:
  inclusions:
    - id: ${{uuid of #catalog}}
      included-controls:
          - ac-1
          - ac-2
    - id: ${{uuid of #catalog}}
      included-controls:
          - ac-3
          - ac-4 
        {{</highlight>}}<p xmlns="http://www.w3.org/1999/xhtml">The control inclusions are combined and collapsed in the next phase of processing,
          <b class="term">merge</b>(see [See: <a href="#d2e565-head" class="xref">Merge Phase</a>]) .
        </p><p xmlns="http://www.w3.org/1999/xhtml">Multiple imports against the same resource are allowed, and would most commonly occur when the profile author is using [See: <a href="#d2e365-head" class="xref">Mapping Controls</a>] to create very specific output. 
          Multiple imports may result in outputs with clashing control IDs if mapping or the merge directive is not set correctly.</p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e365-head">Mapping Controls</h4><p xmlns="http://www.w3.org/1999/xhtml">The optional
          mappingchild of a given
          importprovides a simple ID remapping for objects included from that specific import. This provides the means for profile authors to proactively avoid clashing IDs of controls and other objects.
        </p><p xmlns="http://www.w3.org/1999/xhtml">The Mapping section consists of 5 optional subsections, each covering a particular type of object. Each subsection is a list of ID mappings to be applied for objects that are the parent object type.</p><p xmlns="http://www.w3.org/1999/xhtml">When encountering a given mapping instruction, processors:</p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>MUST change the distinctive ID of that object to be equal to the value of the
              toobject.
            </p></li><li><p>MUST update all known references to the old ID in other included content, allowing the new ID to be used in subsequent profile sections.</p></li></ul><p xmlns="http://www.w3.org/1999/xhtml">Since mapping is a self contained process inside each import, the rest of this specification will continue to reference IDs with the assumption that mapping has already been applied if it was present. Since mapping is most commonly used to avoid clashing IDs, processors should take care to not handle duplicate IDs until after mapping is complete.</p><p xmlns="http://www.w3.org/1999/xhtml">Below is a simple example of mapping. The second
          importis included controls from a different catalog whose ID values happen to collide. Knowing this, the profile author has remapped those IDs to new values.
        </p>{{< highlight xml>}}
          
profile:
  uuid: ~
  metadata: ~
  imports:
    - href: "#catalog"
      include-controls:
       - with-ids:
          - ac-1
          - ac-2
    - href: "#catalog2"
      include-controls:
       - with-ids:
          - ac-1
          - ac-2
      mapping:
       - controls:
          - from: ac-1
            to: map-ac-1
          - from: ac-2
            to: map-ac-2
        {{</highlight>}}<p xmlns="http://www.w3.org/1999/xhtml">Using the intermediate approach, an internal data structure resembling the following would result from the above profile:</p>{{< highlight xml>}}
          
intermediate:
  metadata: ~
  inclusions:
    - id: ${{uuid of #catalog}}
      included-controls:
          - ac-1
          - ac-2
    - id: ${{uuid of #catalog2}}
      included-controls:
          - map-ac-1
          - map-ac-2 
        {{</highlight>}}<h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e394-head">Including Controls</h3><p xmlns="http://www.w3.org/1999/xhtml">Each import contains directives on which controls from the imported catalog are to be fetched and used for further processing. Throughout the rest of the document we will refer to this as "inclusion". 
        If a control is included, and the source profile makes no other changes to it, it will be present in the output. Exclusion directives in this section, as well as directives in the following two major sections (merge and modify), 
        may make changes to an included control or group that could cause it to appear differently, or not at all, in the output. Using the intermediate implementation approach, any control(s) that are included would be extracted from the referenced catalogs, any applicable mappings would be applied, then the controls(s) would be stored.</p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e397-head">include-all</h4><p xmlns="http://www.w3.org/1999/xhtml">When an import provides the
          <code class="src">include-all</code>directive, ALL controls and groups in the referenced document (including nested controls) MUST be included:
        </p>{{< highlight xml>}}include-all: ~{{</highlight>}}<h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e405-head">include-controls plus with-id</h4><p xmlns="http://www.w3.org/1999/xhtml">When an import provides the
          <code class="src">include-controls</code>directive, with a
          <code class="src">with-id</code>child, all controls in the referenced document whose
          <code class="code">id</code>match one of the listed
          <code class="code">id</code>values MUST be included:
        </p>{{< highlight xml>}}
          
include-controls:
  - with-ids:
    - id: ac-1
    - id: ac-2
        {{</highlight>}}<h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e419-head">include-controls plus matching</h4><p xmlns="http://www.w3.org/1999/xhtml">Controls may also be included using match patterns against their IDs. This is useful because related controls (either in a hierarchy, or together in a group) frequently have related IDs as well.</p><p xmlns="http://www.w3.org/1999/xhtml">When an import provides the
          <code class="src">include-controls</code>directive, with a
          <code class="src">matching</code>child, all controls in the referenced document whose
          <code class="code">id</code>matches one of the listed
          <code class="code">pattern</code>values (Glob matching) MUST be included:
        </p><p xmlns="http://www.w3.org/1999/xhtml">If a
          <code class="code">matching</code>object is provided with no
          <code class="code">pattern</code>, it MUST be treated as matching nothing. While not providing a pattern is technically valid, resolution tool implementers should be aware that it is generally undesirable, and warnings or notices to the user may be appropriate.
        </p>{{< highlight xml>}}
          
include-controls:
  - matching:
    - pattern: "ac*" 
        {{</highlight>}}<h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e440-head">Dealing with Nested Controls and Groups</h4><p xmlns="http://www.w3.org/1999/xhtml">In OSCAL, controls may contain child controls. For instance, in SP 800-53 many controls are supplemented with control enhancements; in OSCAL these are represented as child controls within parent controls. So parent AC-2 (in a given catalog) has children AC-2(1) through AC-2(13), for example.</p><p xmlns="http://www.w3.org/1999/xhtml">By default, inclusion of a control also causes any of that control's ancestors (or parents) to also be included. By default, inclusion of a control DOES NOT cause the inclusion of any descendants (or children) of that control to be included. This applies to both controls and groups.</p><p xmlns="http://www.w3.org/1999/xhtml">This default behavior can be modified by the following two optional children of the
          include-controlsobject.
        </p><h5 xmlns="http://www.w3.org/1999/xhtml" id="d2e448-head">with-child-controls</h5><p xmlns="http://www.w3.org/1999/xhtml">Child controls are, for the most part, treated the same as top level controls: they can be explicitly included using the selection directives above. As a shortcut to manually including all of the desired descendant controls of a given control, OSCAL provides the "with-child-controls" option. "with-child-controls" appears as a child object under a given inclusion directive, and defines additional behavior that is to be executed alongside the parent inclusion.</p><p xmlns="http://www.w3.org/1999/xhtml">A
            <code class="src">with-child-controls: yes</code>directive on an
            <code class="src">include-controls</code>indicates that
            <em class="em">all descendant controls</em>of the included control MUST also be included.
          </p><p xmlns="http://www.w3.org/1999/xhtml">A
            <code class="src">with-child-controls: no</code>directive on an
            <code class="src">include-controls</code>indicates that ONLY the matching control is included, any descendant children are not included.
          </p><p xmlns="http://www.w3.org/1999/xhtml">If no
            <code class="src">with-child-controls</code>is provided, the processor MUST consider the directive as being equivalent to one having
            <code class="src">with-child-controls:no</code>.
          </p><h5 xmlns="http://www.w3.org/1999/xhtml" id="d2e471-head">with-parent-controls</h5><p xmlns="http://www.w3.org/1999/xhtml">Although similar to the above
            with-child-controls, the optional
            with-parent-controlsapplies to parents of the included control, and has the opposite default behavior. In order to maintain the structure of the source catalog, profile resolution includes all parents of an included control by default. If a profile author wants to change this structure, they could use an exclude directive that lists all of the undesired parents. As a shortcut for this,
            with-parent-controlsprovides the following functionality:
          </p><p xmlns="http://www.w3.org/1999/xhtml">A
            <code class="src">with-parent-controls: yes</code>directive on an
            <code class="src">include-controls</code>indicates that
            <em class="em">all parent controls</em>of the included control MUST also be included.
          </p><p xmlns="http://www.w3.org/1999/xhtml">A
            <code class="src">with-parent-controls: no</code>directive on an
            <code class="src">include-controls</code>indicates that ONLY the matching control is included, any parents are not included.
          </p><p xmlns="http://www.w3.org/1999/xhtml">If no
            <code class="src">with-parent-controls</code>is provided, the processor MUST consider the directive as being equivalent to one having
            <code class="src">with-parent-controls:yes</code>.
          </p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e501-head">exclude-controls</h4><p xmlns="http://www.w3.org/1999/xhtml">Exclusions work the same way as inclusions, except with the opposite effect - the indicated control(s) do not appear in the target catalog.</p><p xmlns="http://www.w3.org/1999/xhtml">Any control designated to be both included and excluded, MUST be excluded. This holds irrespective of the specificity of the selection for inclusion or exclusion. For example, if AC-1 is included by id
          <code class="code">ac-1</code>and excluded by matching
          <code class="code">ac.*</code>, it is excluded.
        </p><p xmlns="http://www.w3.org/1999/xhtml">When
          <code class="src">exclude-controls</code>has at least one
          <code class="src">with-ids</code>or
          <code class="src">matching</code>directive, the processor MUST follow the same rules as defined in the relevant sections above for these directives, but exclude instead of include any controls. All optional features (with-child-controls, etc.) also apply to exclusion directives.
        </p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e518-head">Redundant Inclusions and Exclusions</h4><p xmlns="http://www.w3.org/1999/xhtml">A given
          <code class="src">import</code>may have any number of inclusion statements and any number of exclusion statements. Their effect is cumulative; any control that is included (or excluded) more than once MUST be considered to be included (or excluded) only once. In other words, a given control being included or excluded more than once has no effect. Exclusion still takes priority over inclusion (see above).
        </p><p xmlns="http://www.w3.org/1999/xhtml">Note that this requirement only applies to controls included within the context of a single import. Controls with duplicate IDs included under a different
          importare not discarded. Also note that this redundancy pruning happens after any relevant mappings have been applied.
        </p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e528-head">Handling Params</h4><p xmlns="http://www.w3.org/1999/xhtml">Any
          <code class="src">param</code>that is not directly under a control is referred to as a
          <q class="q">loose</q>param.
        </p><p xmlns="http://www.w3.org/1999/xhtml">All loose params from both imported documents and the profile source MUST be included. These params will be kept in the final output if document contains any references to them, and discarded otherwise. See
          [See: <a href="#d2e1281-head" class="xref">Pruning and Ordering</a>]. Since new references can be created during the
          modifyphase, tools should be careful not to prune params without fully understanding the final state of the output document.
        </p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e542-head">Handling Groups</h4><p xmlns="http://www.w3.org/1999/xhtml">Some source catalogs use
          groupobjects to place controls into arbitrary groupings. Tools will need to be aware of these groups when executing the "merge" phase below, as they will duplicated into the output under the "as-is" mode and can be referenced in "custom" mode. The naÃ¯ve intermediate approach would keep all groups until all other phases are complete, but implementations may find it more performant to look ahead and prune unused groups early.
        </p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e548-head">Avoiding Implementation Pitfalls</h4><p xmlns="http://www.w3.org/1999/xhtml">In order to ensure that implementers have as much flexibility as possible, requirements in this section have purposefully been kept minimal. Below are some common issues for implementers to be aware of:  </p><ul xmlns="http://www.w3.org/1999/xhtml"><li>The ordering and hierarchical organization of included controls as they were present in the original catalog may be used later in the resolution process. 
            Specifically, if the profile is using the "as-is" structuring directive, the ordering and organziation of the output should match the source catalog as closely as possible. 
            Implementations may want to track this information, or look ahead to see what structuring mode is being used. Note that "as-is" also requires implementations to replicate any use of the <code class="src">group</code> element.
          </li></ul><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e557-head">Wrapping up the Import Phase</h3><p xmlns="http://www.w3.org/1999/xhtml">At this point all requirements for content importing and control inclusion have been covered. If using the intermediate approach, the processor should have an intermediate that contains: a set of included controls and all of their child informational (non-control, non-group) objects, any relevant
        groupobjects and their informational content, and a set of included "loose params"
        [See: <a href="#d2e528-head" class="xref">Handling Params</a>](zero to many). The general structure of the intermediate would match that of the imported catalogs (i.e. Nested controls remain nested, grouped controls remain grouped).
      </p><h2 xmlns="http://www.w3.org/1999/xhtml" id="d2e565-head">Merge Phase</h2><p xmlns="http://www.w3.org/1999/xhtml">Profiles may contain a
      <code class="src">merge</code>section, where directives are given to instruct the processor how to combine the set of included objects collected during the Import Phase.
      <code class="code">merge</code>has two parts: a "combine" directive, and a "structuring" directive.
    </p><p xmlns="http://www.w3.org/1999/xhtml">It is RECOMMENDED that tools apply the "combine" directive to the intermediate generated by the Import phase first, then apply the "structuring" directive.</p><p xmlns="http://www.w3.org/1999/xhtml">The following section contains requirements for processing the
      mergechild of a source profile.
    </p><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e578-head">The "combine" Directive</h3><p xmlns="http://www.w3.org/1999/xhtml">
        <code class="code">combine</code>is an optional child of
        <code class="code">merge</code>that provides the rules for dealing with objects that have duplicate (or clashing) distinct IDs
        [See: <a href="#d2e1305-head" class="xref">Distinct ID of Objects</a>].
      </p><p xmlns="http://www.w3.org/1999/xhtml">There are two valid combination methods provided by OSCAL, provided by the
        <code class="src">method</code>child of
        <code class="src">combine</code>:
      </p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>use-first: Use the first definition - the first control with a given ID is used; subsequent ones are discarded</p></li><li><p>keep: Keep - controls with the same ID are kept, retaining the clash</p></li></ul><p xmlns="http://www.w3.org/1999/xhtml">Note that "merge: combine" is deprecated, and MUST be considered undefined behavior when encountered.</p><p xmlns="http://www.w3.org/1999/xhtml">In order to apply the combination method, IDs of each control explicitly included are compared against one another. As IDs are unique across entire OSCAL documents, different imports or any groupings have no bearing on collision. Processing requirements for each method are described below.</p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e601-head">No Combine Directive</h4><p xmlns="http://www.w3.org/1999/xhtml">If no
          <code class="src">merge</code>directive is given in the profile, or if a
          <code class="src">merge</code>is given without a
          <code class="src">combine</code>, merge conflicts MUST be treated as if
          <code class="src">method: keep</code>was given. For example, a profile with no
          <code class="src">merge</code>directive:
        </p>{{< highlight xml>}}
          
profile:
  imports:
    - href: #catalogURI
      include-all: ~ 
        {{</highlight>}}<p xmlns="http://www.w3.org/1999/xhtml">is the same as</p>{{< highlight xml>}}
          
profile:
  imports:
    - href: #catalogURI
      include-all: ~
  merge:
    combine:
      method: keep
      flat: ~ 
        {{</highlight>}}<h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e620-head">
          <q class="q">method:keep</q>
        </h4><p xmlns="http://www.w3.org/1999/xhtml">When a merge is indicated by
          <code class="src">method:keep</code>, or not given, the
          <q class="q">keep</q>combination rule is used. Any controls with the same distinctive ID
          [See: <a href="#d2e1305-head" class="xref">Distinct ID of Objects</a>]MUST NOT not merged. (They are kept.)
        </p>{{< highlight xml>}}
          
  merge:
    combine:
      method: keep 
        {{</highlight>}}<p xmlns="http://www.w3.org/1999/xhtml">Under this directive, colliding controls will result in invalid results, as they will both appear in the results with the same ID. Accordingly, this setting may be useful in ensuring integrity of references to controls as given in the profile: if any included control is called only once, clashing controls will not be produced and validation will succeed.</p>{{< highlight xml>}}
          
profile:
  imports:
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2 
  merge:
    combine:
      method: keep
        {{</highlight>}}<p xmlns="http://www.w3.org/1999/xhtml">In the intermediate (showing control inclusions):</p>{{< highlight xml>}}
          
intermediate:
  inclusions:
    - explicitly-included-controls:
          - ac-1
          - ac-2
          - ac-1
          - ac-2 
        {{</highlight>}}<p xmlns="http://www.w3.org/1999/xhtml">In this case, downstream errors should be expected: the two
          <code class="code">ac-1</code>controls clash with each other, as do the two
          <code class="code">ac-2</code>controls.
        </p><p xmlns="http://www.w3.org/1999/xhtml">Processors SHOULD provide a warning under this directive when duplicate controls are detected. The processor MAY throw an error and cease processing (short-circuiting a certain future error).</p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e648-head">
          <q class="q">method:use-first</q>
        </h4>{{< highlight xml>}}
          
  merge:
    combine:
      method: use-first 
        {{</highlight>}}<p xmlns="http://www.w3.org/1999/xhtml">When the
          <q class="q">use-first</q>combination rule is applied, and controls that share a distinctive ID are found, the first control encountered MUST be kept, the rest MUST be discarded.
          <q class="q">First</q>MUST be determined by a top-down, depth-first traversal of the source profile's import hierarchy.
        </p><div xmlns="http://www.w3.org/1999/xhtml" class="mapping">{{< highlight xml>}}
            
profile:
  imports:
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-3
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2 
  merge:
    combine:
      method: use-first
          {{</highlight>}}<p>In the intermediate(showing control inclusions):</p>{{< highlight xml>}}
            
intermediate:
  inclusions:
    - explicitly-included-controls:
          - ac-1 (From catalog1)
          - ac-3
          - ac-2 
          {{</highlight>}}</div><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e667-head">
          method:merge
        </h4><p xmlns="http://www.w3.org/1999/xhtml">Deprecated, unspecified behavior.</p><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e673-head">The "structuring" Directive</h3><p xmlns="http://www.w3.org/1999/xhtml">This section describes how a profile may dictate the structure of the target
        <code class="tgt">catalog</code>, apart from its
        <code class="tgt">metadata</code>or
        <code class="tgt">back-matter</code>. Optionally, one of three "structuring" directives can be included as a child of
        merge:
        <code class="src">flat</code>,
        <code class="src">as-is</code>and
        <code class="src">custom</code>. When one of these appears, it is the selected structuring directive. If more than one appears, processors MUST generate an error and cease processing. Processing requirements for each are given below:
      </p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e692-head">No Structuring Directive</h4><p xmlns="http://www.w3.org/1999/xhtml">If no
          <code class="src">merge</code>directive is given in the profile, or if a
          <code class="src">merge</code>is given without a structuring directive, structuring the output MUST be treated as if the structuring directive
          <code class="src">flat</code>was given. For example, a profile with no
          <code class="src">merge</code>directive:
        </p>{{< highlight xml>}}
          
profile:
  imports:
    - href: #catalogURI
      include-all: ~ 
        {{</highlight>}}<p xmlns="http://www.w3.org/1999/xhtml">is the same as</p>{{< highlight xml>}}
          
profile:
  imports:
    - href: #catalogURI
      include-all: ~
  merge:
    combine:
      method: keep 
      flat: ~ 
        {{</highlight>}}<h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e709-head">"flat"</h4><p xmlns="http://www.w3.org/1999/xhtml">Profiles with the "flat" merge directive are resolved as unstructured catalogs, with no groupings of controls.</p><p xmlns="http://www.w3.org/1999/xhtml">Unstructured catalog output MUST be produced by adhering to the following requirements:</p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>All included controls are output to the target as a flat list directly under "catalog".</p></li><li><p>Any included "loose params" are output to the target as a flat list directly under "catalog".</p></li><li>Any groups are discarded.</li></ul><p xmlns="http://www.w3.org/1999/xhtml">An example of flat structuring is provided below</p>{{< highlight xml>}}
          
catalog:
  groups:
    - groupA
      - ac-1
      - ac-2
    - groupB
      - bc-1 
        {{</highlight>}}{{< highlight xml>}}
          
profile:
  imports:
    - href: #catalogURI
      include-controls:
        with-ids:
          - ac-1
          - ac-2
          - bc-1
  merge:
    combine:
      method: keep 
      flat: ~ 
        {{</highlight>}}{{< highlight xml>}}
          
intermediate:
  controls:
    - ac-1
    - ac-2
    - bc-1 
        {{</highlight>}}<h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e726-head">
          <q class="q">as-is</q>
        </h4><p xmlns="http://www.w3.org/1999/xhtml">An
          <code class="src">as-is</code>directive is used to reproduce the structure of the source documents in the target catalog.
        </p><p xmlns="http://www.w3.org/1999/xhtml">Processors MUST handle the
          <code class="src">as-is</code>directive by adhering to the following requirements:
        </p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>All included controls are output to the target, keeping the structure of the groups and nested controls. Any group that holds an included control MUST appear in the output with all of its non-control children intact. 
              If an included control has a parent control that was not included, that control's output location is "up-leveled", or made equal to the non-included parent. This applies recursively until the control is directly under either "catalog" or another included control.</p></li><li><p>Any included "loose params" are output to the target as a flat list directly under "catalog".</p></li></ul><p xmlns="http://www.w3.org/1999/xhtml">Example:</p>{{< highlight xml>}}
          
catalog:
  groups:
    - groupA
      - ac-1
      - ac-2
    - groupB
      - bc-1 
        {{</highlight>}}{{< highlight xml>}}
          
profile:
  imports:
    - href: #catalogURI
      include-controls:
        with-ids:
          - ac-1
          - ac-2
          - bc-1
  merge:
    combine:
      method: keep 
      as-is: ~ 
        {{</highlight>}}{{< highlight xml>}}
          
intermediate: 
#In this approach, the original hierarchy of the controls under the groups is stored,
#but is not shown in this example.
  controls:
    - ac-1
    - ac-2
    - bc-1
  groups:
    - groupA
    - groupB 
        {{</highlight>}}<h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e751-head">
          <q class="q">custom</q>
        </h4><p xmlns="http://www.w3.org/1999/xhtml">The
          <code class="src">custom</code>directive provides the target catalog with a custom structure. A one-to-one mapping of the desired structure of the target catalog is defined alongside control matching instructions, resulting in a strictly controlled output catalog.
        </p><h5 xmlns="http://www.w3.org/1999/xhtml" id="d2e760-head">Creating Custom Groups</h5><p xmlns="http://www.w3.org/1999/xhtml">A
            <code class="src">group</code>object given under
            customMUST result in a
            <code class="tgt">group</code>with the exact same content (excluding
            insert-controls) in the target catalog.
          </p><p xmlns="http://www.w3.org/1999/xhtml">If the ID of the group matches the ID of a group that has been included during the import phase, all contents inside the group, including
            <code class="src">title</code>,
            <code class="src">param</code>,
            <code class="src">prop</code>and
            <code class="src">part</code>objects MUST be copied into the target, appearing in the same order as in the source.
          </p><p xmlns="http://www.w3.org/1999/xhtml">Note that groups defined in
            custommay vary from fully featured to minimally instantiated. This includes arbitrary nesting of such groups inside of one another. No groups other than those explicitly declared should appear in the output catalog.
          </p><h5 xmlns="http://www.w3.org/1999/xhtml" id="d2e786-head">Inserting Controls</h5><p xmlns="http://www.w3.org/1999/xhtml">The
            insert-controlsdirective may appear anywhere under
            custom, whether as a direct child or inside any of the defined groups. Inside insert-controls,
            include-controlsand
            include-allfrom the Import Phase
            [See: <a href="#d2e245-head" class="xref">Import Phase</a>]are used with the same basic behavior to configure which controls are selected and inserted at the current location.
          </p><p xmlns="http://www.w3.org/1999/xhtml">In order to provide clarity, controls that match the various conditions of these inclusion directives inside the
            customobject will be referred to as "selected" instead of "included". Only directly selected controls will appear in the target catalog.
          </p><p xmlns="http://www.w3.org/1999/xhtml">A
            insert-controlswith an
            include-controlschild results in the following behavior:
          </p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>
                <code class="src">with-id</code>results in selecting and inserting, at that point inside the new grouping, the included controls with the
                <code class="src">id</code>given by
                <code class="src">with-id</code>. They should be given in the same order as they appear in the control selection(s).
              </p></li><li><p>A
                <code class="src">matching</code>directive results in selecting and inserting, at that point inside the new grouping, all included controls whose
                <code class="src">id</code>match, as a Glob expression, the pattern given in the
                <code class="src">pattern</code>. They are given in the same order as they appear in the input control selection(s).
              </p></li></ul><p xmlns="http://www.w3.org/1999/xhtml">An
            insert-controlswith an
            include-allchild results in all included controls being selected and inserted. They are given in the same order as they appear in the input control selection(s).
          </p><p xmlns="http://www.w3.org/1999/xhtml">
            insert-controlscan also indicate the order that the selected controls are to be emitted in the result catalog using an
            <code class="src">order</code>child. Three values MUST be supported and handled as specified below:
          </p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>
                <code class="code">ascending</code>will sort all selected controls into ascending alphanumeric order by their ID.
              </p></li><li><p>
                <code class="code">descending</code>will sort all selected controls into descending alphanumeric order by their ID.
              </p></li><li><p>
                <code class="code">keep</code>indicates that controls should be inserted in the order of their appearance, using a depth-first traversal of the source profile's imports.
              </p></li></ul><p xmlns="http://www.w3.org/1999/xhtml">In the case that a control selection matches none of the included controls, it MUST be ignored; a warning SHOULD be provided. If a control that was included by the Import Phase is never selected, no error occurs, that control simply does not appear in the output catalog.</p><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e858-head">Wrapping up the Merge Phase</h3><p xmlns="http://www.w3.org/1999/xhtml">After the merge phase, the intermediate should now closely resemble the content and structure of the final output catalog. Controls and groups have been included, remapped, de-duplicated, then placed into their final location within the output's structure. Note: there is still an opportunity for included controls or groups to become referenced; and therefore, not eligible for pruning
        [See: <a href="#d2e1281-head" class="xref">Pruning and Ordering</a>]in the next phase.
      </p><p xmlns="http://www.w3.org/1999/xhtml">Regardless of any merge directives, there also likely remains "loose params" that have been propagated forward; these too must be persisted.</p><h2 xmlns="http://www.w3.org/1999/xhtml" id="d2e865-head">Modify Phase</h2><p xmlns="http://www.w3.org/1999/xhtml">There are two ways profiles may further modify the results of profile resolution: setting parameters, and altering controls. These activities are defined as two child objects inside the third step of profile resolution, the Modify Phase.</p><p xmlns="http://www.w3.org/1999/xhtml">The following section contains requirements for processing the
      modifychild of a source profile.
    </p><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e872-head">Setting Parameters</h3><p xmlns="http://www.w3.org/1999/xhtml">Modification of parameter settings is indicated using the
        <code class="src">set-parameter</code>object under
        modify. For this section, a given
        set-parameterobject will be referred to as the
        source.
      </p><p xmlns="http://www.w3.org/1999/xhtml">Profile Resolution Tools MUST adhere to the following requirements for processing "set-parameter":</p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>First, the list of included params (among "loose params" and remaining included controls and groups) is searched for a param who has a "id" equal to this object's "param-id". This is the "target". If no such parameter is found, a warning SHOULD be issued, but processing MUST continue.</p></li><li><p>When encountering the following objects in the source: class, depends-on, label, usage, values, select; overwrites the object of the same name in the target. If no such object exists in the target, it is created.</p></li><li><p>When encountering the following objects in the source: props, links, constraints, guidelines; adds the contents of the source object to the contents of the target object of the same name. If no such object exists in the target, it is created. For each individual child object of "props" and "links" in the source, if an individual child inside the target object has the same distinctive ID, it is instead overwritten by the source object
            [See: <a href="#d2e1305-head" class="xref">Distinct ID of Objects</a>]
          </p></li><li><p>If more than one
            <code class="src">set-parameter</code>directive is given for the same parameter, all are applied, in the sequence given in the profile.
          </p></li></ul><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e900-head">Altering controls</h3><p xmlns="http://www.w3.org/1999/xhtml">A control can be altered by an
        <code class="src">alter</code>object inside "modify". The
        <code class="src">control-id</code>child object under the
        <code class="src">alter</code>indicates the control to which the alteration is applied.
      </p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e910-head">Adding contents to controls</h4><p xmlns="http://www.w3.org/1999/xhtml">Contents may be added to controls using an add directive inside an alter directive. There are two forms of alteration: with implicit and explicit bindings.</p><h5 xmlns="http://www.w3.org/1999/xhtml" id="d2e913-head">Implicit binding</h5><p xmlns="http://www.w3.org/1999/xhtml">An
            <code class="src">add</code>directive with no
            <code class="src">by-id</code>is taken to apply to the control as a whole. Its
            <code class="src">position</code>may be either of two values:
            <code class="code">starting</code>and
            <code class="code">ending</code>.
          </p><p xmlns="http://www.w3.org/1999/xhtml">The contents of the add directive are then added to the control contents in the target, either after its
            <code class="tgt">title</code>when
            <code class="src">position</code>is
            <code class="code">starting</code>, or at the end if its position is
            <code class="code">ending</code>, or not given.
          </p><p xmlns="http://www.w3.org/1999/xhtml">However, control contents in catalogs must appear in the order
            <code class="code">title, param, prop, link, part, control</code>. Subsequent to adding new objects, the control contents are sorted to appear in the required order. As a consequence, a new
            <code class="tgt">prop</code>appears after any
            <code class="src">prop</code>already in the control, when
            <code class="src">position</code>is
            <code class="code">ending</code>, or not given, or before any
            <code class="src">prop</code>in the control when
            <code class="src">position</code>is
            <code class="code">starting</code>.
          </p><p xmlns="http://www.w3.org/1999/xhtml">When add has no
            <code class="src">ref-id</code>(has an implicit binding), the
            <code class="src">position</code>values
            <code class="code">before</code>and
            <code class="code">after</code>are treated like
            <code class="code">starting</code>and
            <code class="code">ending</code>, respectively.
            <span class="revisit">The schema permits these values.</span>
          </p><div xmlns="http://www.w3.org/1999/xhtml" class="mapping"><p>An addition operating on a control with implicit binding and position
              <code class="code">starting</code>
            </p>{{< highlight xml>}}
               
control:
  id: a1
  title: Basic precautions
  props:
    - name: status
      value: ready 
            {{</highlight>}}{{< highlight xml>}}
               
alter:
  control-id: a1
  add:
    position: starting
    props:
      - name: basis
        value: enumerated
    parts:
      - name: caution
        prose: \\n\\nPending scheduled testing. 
            {{</highlight>}}{{< highlight xml>}}
               
control:
  id: a1
  title: Basic precautions
  props:
    - name: basis
      value: enumerated
    - name: status
      value: ready
  parts:
    - name: caution
      prose: \\n\\nPending scheduled testing. 
            {{</highlight>}}<p>Position is
              <code class="code">starting</code>but the new
              <code class="tgt">part</code>is added after the existing
              <code class="tgt">prop</code>, because
              <code class="tgt">prop</code>objects must always occur first.
            </p></div><div xmlns="http://www.w3.org/1999/xhtml" class="mapping"><p>An addition operating on a control with implicit binding and position
              <code class="code">ending</code>
            </p>{{< highlight xml>}}
               
control:
  id: a1
  title: Basic precautions
  props:
    - name: status
      value: ready 
            {{</highlight>}}{{< highlight xml>}}
               
alter:
  control-id: a1
  add:
    position: starting
    props:
      - name: basis
        value: enumerated
    parts:
      - name: caution
        prose: \\n\\nPending scheduled testing. 
            {{</highlight>}}{{< highlight xml>}}
               
control:
  id: a1
  title: Basic precautions
  props:
    - name: status
      value: ready
    - name: basis
      value: enumerated
  parts:
    - name: caution
      prose: \\n\\nPending scheduled testing. 
            {{</highlight>}}<p>The
              <code class="src">position</code>is
              <code class="code">ending</code>so the new
              <code class="tgt">prop</code>appears after the existing
              <code class="tgt">prop</code>.
            </p></div><h5 xmlns="http://www.w3.org/1999/xhtml" id="d2e1015-head">Explicit binding</h5><p xmlns="http://www.w3.org/1999/xhtml">An explicit binding on an addition permits inserting new contents anywhere in a control, not only at the top level. It is given by a
            <code class="src">ref-id</code>on the
            <code class="src">add</code>directive. The value of the
            <code class="src">ref-id</code>must correspond to the value of an
            <code class="src">id</code>on an object inside the control, and not the control itself. If
            <code class="src">ref-id</code>does not correspond to such a value, the
            <code class="src">add</code>directive is inoperative. A warning MAY be issued in such a case.
          </p><p xmlns="http://www.w3.org/1999/xhtml">The object with
            <code class="src">id</code>equal to the
            <code class="src">ref-id</code>is considered the
            <b class="term">target</b>of the addition.
          </p><p xmlns="http://www.w3.org/1999/xhtml">Additionally, with an explicit binding given by a
            <code class="src">ref-id</code>,
            <code class="src">position</code>may have any of the values
            <code class="code">starting</code>,
            <code class="code">ending</code>,
            <code class="code">before</code>and
            <code class="code">after</code>.
          </p><p xmlns="http://www.w3.org/1999/xhtml">When
            <code class="src">position</code>is
            <code class="code">starting</code>or
            <code class="code">ending</code>, the new contents are added at the beginning or ending of the target object, inside that object, as are additions into controls (using implicit bindings).
          </p><p xmlns="http://www.w3.org/1999/xhtml">Additionally, a
            <code class="src">position</code>given as
            <code class="code">before</code>indicates the addition should be made directly before the target object, while
            <code class="code">after</code>indicates the addition should appear directly after the target object.
          </p><div xmlns="http://www.w3.org/1999/xhtml" class="mapping"><p>An addition operating on a control with explicit binding and position
              <code class="code">after</code>
            </p>{{< highlight xml>}}
               
control:
  id: a1
  title: Basic precautions
  props:
    - name: status
      value: ready
  parts:
    - name: recommendations
      id: a1.b
      parts: 
        - name: task1
          id: a1.b1
          prose: Collect recycling for pickup
        - name: task2
          id: a1.b2
          prose: Sweep surfaces free of dust
            {{</highlight>}}<p>Note that the
              <code class="src">add</code>directive identifies the object with
              <code class="src">id</code>
              <code class="code">a1.b1</code>as its target.
            </p>{{< highlight xml>}}
               
alter:
  control-id: a1
  add:
    position: after
    ref-id: a1.b1
    props:
      - name: basis
        value: allocated
    parts:
      - name: caution
        prose: Unavailable on weekends 
            {{</highlight>}}{{< highlight xml>}}
               
control:
  id: a1
  title: Basic precautions
  props:
    - name: status
      value: ready
  parts:
    - name: recommendations
      id: a1.b
      parts: 
        - name: task1
          id: a1.b1
          prose: Collect recycling for pickup
        - name: caution
          prose: Unavailable on weekends
        - name: task2
          id: a1.b2
          prose: Sweep surfaces free of dust
      props:
        - name: basis
          value: allocated
            {{</highlight>}}<p>The
              <code class="src">position</code>is
              <code class="code">after</code>so both objects inside
              <code class="src">add</code>are added after (not inside) the target object. Since the target object is inside another
              <code class="tgt">part</code>in the control, the new additions appear there as well.
            </p><p>Note that the result in this case will be schema-invalid since a
              <code class="tgt">prop</code>may not occur directly following a
              <code class="tgt">part</code>. A better result can be obtained (a better target may be defined) by using two
              <code class="src">add</code>directives, to insert the new
              <code class="tgt">prop</code>separately before any
              <code class="tgt">part</code>objects in the target.
            </p></div><h5 xmlns="http://www.w3.org/1999/xhtml" id="d2e1113-head">Usage of
            <code class="src">add</code>directives modifying controls inside controls
          </h5><p xmlns="http://www.w3.org/1999/xhtml">OSCAL supports control extensions inside controls in the form of
            <code class="src">control</code>objects inside
            <code class="src">control</code>objects. Because the semantics of the
            <code class="src">add</code>directive target any (object) contents of controls, they can be used to target these control extensions for modification as well as other contents.
          </p><p xmlns="http://www.w3.org/1999/xhtml">Because such a control can already be modified using implicit bindings, it is recommended that they not be targeted with explicit bindings. Using an implicit binding supports more robust alteration since contents in the target can be ordered properly by the resolution processor.
            <span class="revisit">XXX can we guarantee valid results here and do we have to specify a sort/order?</span>However, it is not an error to target control objects in this way, manipulating them in the same way as other targets may be manipulated.
          </p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e1130-head">Removing contents from controls</h4><p xmlns="http://www.w3.org/1999/xhtml">Contents inside controls can be removed from them in catalog targets. In combination with adding new contents, this feature can be used to edit controls as well as amend them.</p><p xmlns="http://www.w3.org/1999/xhtml">A
          <code class="src">remove</code>directive inside an
          <code class="src">alter</code>directive identifies an object or set of objects inside a control to be removed. It does this using any of five child objects. These are
          <em class="em">additive</em>; that is, if more than one is given, all must match:
        </p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>
              <code class="src">by-id</code>, like
              <code class="src">add:by-id</code>, matches an object by its
              <code class="src">id</code>value.
            </p><p>Because
              <code class="src">id</code>values are unique, the remove directive will remove only a single object. Ordinarily this would not combined with other identifiers for removal.
            </p></li><li><p>
              <code class="src">name-ref</code>keys to the
              <code class="src">name</code>child object on any object inside the control.
            </p><p>Any object inside the control with the assigned
              <code class="src">name</code>, is removed (typically providing there is also a match on
              <code class="src">ns</code>).
            </p></li><li><p>
              <code class="src">ns-ref</code>keys to the
              <code class="src">ns</code>child object on any object inside the control.
            </p><p>Any object inside the control with the assigned
              <code class="src">name</code>, is removed (typically providing there is also a match on
              <code class="src">name</code>).
            </p></li><li><p>
              <code class="src">class-ref</code>keys to the
              <code class="src">class</code>child object on any object inside the control. All objects with matching
              <code class="src">class</code>are removed.
            </p></li><li><p>
              <code class="src">item-name</code>keys to the object or property name; for example,
              <code class="code">remove: item-name: prop</code>has the effect of removing all
              <code class="src">prop</code>objects from inside the control.
            </p></li></ul><p xmlns="http://www.w3.org/1999/xhtml">Unlike an
          <code class="src">add</code>directive, a
          <code class="src">remove</code>may not be bound implicitly to the control; its binding, to contents inside the control, must be explicit.
        </p><p xmlns="http://www.w3.org/1999/xhtml">To remove an control, simply avoid selecting it into the profile, or exclude it specifically using
          <code class="src">import/exclude-controls</code>.
        </p><p xmlns="http://www.w3.org/1999/xhtml">As with
          <code class="src">add</code>, a remove that targets any object outside the control, is inoperative. Similarly, a remove directive that indicates that all
          <code class="tgt">prop</code>objects should be removed from the target catalog, applies only to
          <code class="src">prop</code>
        </p><h2 xmlns="http://www.w3.org/1999/xhtml" id="d2e1218-head">Final Operations</h2><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e1220-head">Backmatter Resolution</h3><p xmlns="http://www.w3.org/1999/xhtml">
        <code class="tgt">back-matter</code>in the result is produced by combining all objects within
        <code class="src">back-matter</code>in all source catalogs, with the
        <code class="src">back-matter</code>in the input profile. The merge method and merge structuring directives are ignored. The following requirements MUST be adhered to by the processor:
      </p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>Each import's backmatter is processed in order it was provided in the source profile, then the source profile's backmatter is processed.</p></li><li><p>Each
            <code class="src">resource</code>is added to the target in the order given inside the import.
          </p></li><li><p>If a
            <code class="src">resource</code>has the same
            <code class="src">uuid</code>as a resource that has already been added, the previous resource is removed, and the more recent one added.
          </p></li><li><p>A resource with a child prop of name:keep and value:always can only be replaced following the above rule by a duplicate that also has the keep always prop.</p></li></ul><p xmlns="http://www.w3.org/1999/xhtml">Tools MAY check for pruning conditions
        [See: <a href="#d2e1281-head" class="xref">Pruning and Ordering</a>]as resources are added as long as the final result is the same as if the pruning had taken place at the end of all resource addition.
      </p><p xmlns="http://www.w3.org/1999/xhtml">Placing the keep always prop on a resource in a catalog has the effect of ensuring it will always appear in the output produced by any profile importing that catalog, even if nothing links to the resource. This version of the resource will also be the one copied, unless a later-imported catalog or importing profile offers its own version marked to keep always.</p><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e1252-head">Metadata Resolution</h3><p xmlns="http://www.w3.org/1999/xhtml">The following requirements MUST be followed with regards to the Metadata section of the output catalog:</p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>The output catalog MUST have a unique top-level UUID (metadata:uuid). This UUID may be generated as seen fit by the tool, as long as it is reasonable to assume it is globally unique. It is RECOMMENDED that tools use a combination of meaningful text and a uniquely generated value (Ex.
            <code class="code">{{sourceprofilename}}-RESOLVED-{{GUIDv5}}</code>).
          </p></li><li><p>The value of metadata:version in the target MUST be set with a string that identifies the version of this document. This SHOULD be used to track updates to this specific output document.</p></li><li><p>The value of metadata:oscal-version in the target MUST be set with a string that identifies the version of OSCAL used by this tool to resolve the profile (ex. 1.0.0). This value MUST be determined by compiling the oscal-versions from each imported document and the source profile, and taking the most recent minor version. If this version is more recent than what the resolution tool is using, then the value of the output oscal-version MUST be the version that the tool used internally. If any of the above OSCAL versions (imported document versions, source profile version, tool version) are of a different major version (the first digit differs), the tool SHOULD provide an error and cease processing.</p></li><li><p>The value of metadata:last-modified in the target MUST be set with a valid timestamp representing the time the profile resolution completed.</p></li><li><p>The value of metadata:source-profile in the target SHOULD be set with a valid URI that points to the profile that resulted in this catalog. If there are privacy or security concerns, the value MAY be set to anything, in which case the simple existence of the source-profile property indicates that this is a resolved profile.</p></li><li><p>The value of metadata:resolution-tool in the target SHOULD be set with a string that represents the tool that was used to resolve this catalog.</p></li><li>For any metadata:roles or metadata:parties that exist in the source catalogs, if they have a <code class="src">prop</code> child with name:keep and value:always, they are to be copied as is into the output metadata.</li></ul><p xmlns="http://www.w3.org/1999/xhtml">Beyond these requirements, tools are free to use any and all of the objects inside metadata to provide additional information downstream.</p><p xmlns="http://www.w3.org/1999/xhtml">Because of options in producing metadata and especially the requirement for a timestamp, developers and users should note that two different resolutions of the same profile will not, ordinarily, be identical inside
        <code class="tgt">metadata</code>.
      </p><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e1281-head">Pruning and Ordering</h3><p xmlns="http://www.w3.org/1999/xhtml">The processor SHOULD prune the result catalog to remove unused values. A given object is considered unused if it meets ALL of the following criteria:</p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>The object does not have a child prop with name:keep and value:always</p></li><li><p>The object is not explicitly included
            [See: <a href="#d2e394-head" class="xref">Including Controls</a>].
          </p></li><li><p>There are no references to the object anywhere in the final result catalog, except in other objects that also meet all other pruning criteria. A reference to a given object exists if "#{distinctiveID}" appears anywhere, where {distinctiveID} is the distinctive ID of the object
            [See: <a href="#d2e1305-head" class="xref">Distinct ID of Objects</a>].
          </p></li></ul><p xmlns="http://www.w3.org/1999/xhtml">Implementers should note that pruning need not take place after all other steps. As long as all above criteria are respected, pruning can happen at any time, and doing so is a likely performance and memory overhead improvement.</p><p xmlns="http://www.w3.org/1999/xhtml">Tools MUST reorder the output catalog into canonical order
        [See: <a href="#d2e1365-head" class="xref">Order of objects in serialization</a>], except where this specification provides different ordering requirements.
      </p><h2 xmlns="http://www.w3.org/1999/xhtml" id="d2e1303-head">Items of Note</h2><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e1305-head">Distinct ID of Objects</h3><p xmlns="http://www.w3.org/1999/xhtml">Whenever this specification refers to
        <q class="q">distinctiveness</q>, it MUST be interpreted as is defined in this section with regards to the object in question.
      </p><p xmlns="http://www.w3.org/1999/xhtml">control,param,group - distinctiveness is defined by the value of the
        <q class="q">id</q>child object.
      </p><p xmlns="http://www.w3.org/1999/xhtml">resource - distinctiveness is defined by the value of the
        <q class="q">uuid</q>
        [See: <a href="#d2e1220-head" class="xref">Backmatter Resolution</a>].
      </p><h3 xmlns="http://www.w3.org/1999/xhtml" id="d2e1321-head">Dealing with Multiple Formats</h3><p xmlns="http://www.w3.org/1999/xhtml">Profile Resolution tools SHOULD be able to handle source profiles, imported catalogs, and imported profiles that are serialized in XML, JSON, or YAML. A different serialization format of any given input MUST NOT result in a differing output catalog.</p><p xmlns="http://www.w3.org/1999/xhtml">In order to help bootstrap this format management, the following resources are provided for implementers:</p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>.
            
          </p></li></ul><p xmlns="http://www.w3.org/1999/xhtml">The following sections provide additional requirements and guidance for each format.</p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e1332-head">Requirements and Guidance for XML Output</h4><p xmlns="http://www.w3.org/1999/xhtml">See
          <a class="a" href="https://pages.nist.gov/OSCAL/reference/latest/complete/xml-definitions/">the complete XML reference</a>for model requirements.
        </p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e1341-head">Requirements and Guidance for JSON Output</h4><p xmlns="http://www.w3.org/1999/xhtml">See the
          <a class="a" href="https://pages.nist.gov/OSCAL/reference/latest/complete/json-reference/">complete JSON reference</a>for model requirements.
        </p><p xmlns="http://www.w3.org/1999/xhtml">The JSON format, in general use, does not require the preservation of order of fields. As order matters in OSCAL, care should be taken to adhere to the canonical OSCAL order
          [See: <a href="#d2e1365-head" class="xref">Order of objects in serialization</a>]when outputting a catalog in JSON.
        </p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e1353-head">Requirements and Guidance for YAML Output</h4><p xmlns="http://www.w3.org/1999/xhtml">YAML is considered a simple variation on the JSON format. Beyond cosmetic differences there are no differences in the information structure between these formats. Therefore, the
          <a class="a" href="https://pages.nist.gov/OSCAL/reference/latest/complete/json-reference/">complete JSON reference</a>provides model requirements.
        </p><p xmlns="http://www.w3.org/1999/xhtml">The YAML format, in general use, does not require the preservation of order of fields. As order matters in OSCAL, care should be taken to adhere to the canonical OSCAL order
          [See: <a href="#d2e1365-head" class="xref">Order of objects in serialization</a>]when outputting a catalog in YAML.
        </p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e1365-head">Order of objects in serialization</h4><p xmlns="http://www.w3.org/1999/xhtml">In OSCAL, order of top level objects (those that are direct children of the root element) is considered important only when the XML format is used. To facilitate this, OSCAL provides the concept of
          <b class="term">canonical order</b>. This order is provided by the OSCAL Metaschema files for a given document type (see
          <a class="a" href="https://pages.nist.gov/OSCAL/concepts/layer/overview/#modeling-approach">an overview of Metaschema</a>.
        </p><p xmlns="http://www.w3.org/1999/xhtml">When the output format is XML, tools MUST use the OSCAL canonical order as described above. When using the YAML or JSON formats, order conveys no meaning, and is not considered important.</p><h4 xmlns="http://www.w3.org/1999/xhtml" id="d2e1375-head">Comments in result documents</h4><p xmlns="http://www.w3.org/1999/xhtml">In an XML-based profile resolution, XML comments are one straightforward way for a processor to record events or conditions without affecting the output's nominal semantics. To support this, while two processors are obliged to return the same catalog XML for the same profile XML inputs, they are not required to match one another's comments, white space usage, attribute order, or processing instructions, only each other's objects, attributes and data content.</p><p xmlns="http://www.w3.org/1999/xhtml">One consequence of this is that processes intended to compare two profile resolutions may have to accommodate differences in comments, considering them as insignificant along with other differences in serialization.</p>