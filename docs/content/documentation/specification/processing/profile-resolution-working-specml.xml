<?xml version="1.0" encoding="UTF-8"?><?xml-model href="profile-resolution-working-specml.rnc" type="application/relax-ng-compact-syntax"?>
<?xml-stylesheet type="text/css" href="specml.css"?>
<SPECIFICATION xmlns="http://csrc.nist.gov/ns/oscal/specml">
    <!--description: A profile implicitly defines a control set; profile resolution makes this
      control set explicit and available for further processing.-->
  <head>Profile Resolution</head>
  <p>These PRELIMINARY specifications describe how to render an OSCAL profile document in
    the form of an OSCAL catalog. We call this <term>profile resolution</term>.</p>
  <p>These specifications take the form of a tag set mapping between two XML applications, namely
    the OSCAL <term>profile</term> and OSCAL <term>catalog</term> document models. The same mapping
    (transformation from source to target) can be effected using other expressions of the OSCAL
    model such as JSON or YAML object serializations. In these specifications, there will be
    reference to XML constructs (such as <q>element</q> where you might prefer <q>object</q>) and
    examples using XML syntax: these however are for illustrative purposes only and normative only
    with respect to the semantic mapping, not the syntax as such. The XML orientation of the
    specification of this mapping is an expediency; in the longer term we would like to have
    specifications that are format-agnostic.</p>
  <div>
    <head>Use of XPath</head>
    <p>Additionally, in these specs there is lightweight use of XPath notation to identify elements
      and attributes in the XML. A summary:</p>
    <ul>
      <li>
        <p><s>element</s> (unpunctuated) indicates an element named <s>element</s></p>
      </li>
      <li>
        <p><s>@attribute</s> (punctuated <q>@</q>) indicates an attribute named <s>attribute</s></p>
      </li>
      <li>
        <p><s>elem/@attr</s> indicates an attribute named <s>attr</s> on an element named
            <s>elem</s></p>
      </li>
      <li>
        <p><s>elmn[@att='val']</s> indicates an element <s>elmn</s> that has an attribute
            <s>@att</s> with value <code>val</code>. </p>
      </li>
    </ul>
  </div>
  <p>In an XML context, document validation is available as a means of determining whether an
    arbitrary XML document entity conforms to structural and naming constraints such as must be
    assumed by processors respecting application semantics. These specifications assume that XML
    inputs for profile resolution will be <em>schema-valid</em> with respect to the OSCAL
      <term>profile</term> model, and hence will be tagged in the namespace
      <code>http://csrc.nist.gov/ns/oscal/1.0</code>.</p>
  <p>In these specs there are references to <s>source</s>, <t>target</t> and <term>result</term>.
      <s>Source</s> refers sometimes to profile documents as a type (abstractly), and sometimes to
    instance profiles in operation (particular kinds of sources). <t>Target</t> refers to the
    intended output of the transformation, that is the catalog model generally (as a document type)
    or, for particular source instances, particular targets.</p>
  <p>The term <term>result</term> refers to the actual results of transformation, as opposed to the
    intended or expected results. A processor's conformance can be described as the degree to which
    its result resembles this target; that is, that resolving a profile in a particular
    implementation produce correct results as described in these specs. Paradoxically, this means
    that a correct target, in some circumstances, is invalid to the nominal target schema.
    Correctness of a processor, in other words, in conforming to these specifications, may require
    that sometimes its results are formally invalid to the target schema. Such situation will
    generally reflect erros (even if not formally invalid) or unnecessary complexities in the input;
    as such they are remediable and can be prevented by design. These conditions are not described
    by these specifications as errors, but they may be noted as occasions for warnings.</p>
  <p>In a normal or default configuration, a conformant processor should not repair these problems
    on its own (making it difficult or impossible to duplicate its results in another conformant
    processor). It may provide features making it easier to detect and repair problems in source
    data that give rise to them.</p>
  <div>
    <head>Detecting issues in profiles</head>
    <p>It is frequently possible by static analysis to detect many conditions even in valid profile
      documents, that will result in problematic catalogs in resolution. The most common issue will
      be clashing controls, that is more than one control with a given identifier (ID), making
      references to such controls ambiguous. Such analysis is outside the scope of these
      specifications.</p>
  </div>
    <p>A <term>profile</term> in OSCAL represents a selection and configuration of a set of
      <term>controls</term>. In the normal case, the set of controls available to a profile is
    provided by a catalog. For example, the three NIST SP 800-53 profiles representing the impact
    baselines HIGH, MODERATE and LOW: each of these calls on the full SP 800-53/53A catalog for its
    controls. In a data processing system, this dependency can be modeled in the form of separate
    documents - the (nominal) <q>catalog</q> and its <q>profile</q>, the latter being the selection
    and application of the catalog as distinct from the catalog itself.</p>
    <p>However, profiles may also select controls from profiles, implicitly selecting from
      underlying catalogs as modified. And they can select controls from more than one catalog or
      profile origin.</p>
  <p>In the most common case, a profile will source its controls from a single catalog or perhaps a
    complementary pair of catalogs (perhaps an authoritative or standard catalog, plus a
    supplement). In the general case and more broadly, however, OSCAL must support sourcing more
    than one catalog at once, in order to aggregate and organize controls from any sources. This
    specification describes handling that within an ordinary workflow context must be considered
    (and detected and handled) as error conditions, and this especially applies to situations where
    multiple catalogs are sourced – or where the same catalog is sourced more than once.</p>
    <p>In order to support these semantics – because whatever data set is sourced by a profile, it
    must <q>look like a catalog</q>, the results of resolving a single profile must be in the form
    of a single (<q>virtual</q> or implicit) catalog. Two different OSCAL processors that promise
    profile resolution, must deliver the same catalog with regard to its controls and the structure
    in which they are embedded (groups). This specification is designed to make this possible, by
    defining <q>the same</q> in this context.</p>
  <div>
    <head>Why resolve a profile as a catalog</head>
    <p>A profile is a representation of a delta, a <q>here to there</q>. As such, a profile might be
      conceived of as a recipe or set of procedures, whereby to create an OSCAL catalog (set of
      controls describing security requirements) from an OSCAL catalog (set of controls describing
      security requirements).</p>
    <p>This is because although catalogs - for example, the controls described in NIST SP 800-53 -
      are published, available for use, and even standardized, they can never be used exactly in the
      form in which they are acquired. They must be taken from the packaging and placed into
      operational context before they mean anything. This typically requires a few operations over
        <q>raw catalogs</q> be supported. We must be able to select controls; we must be able to
      arrange them in order (or not); and we must be able to condition them by setting parameters
      defined for them and making adjustments to them. </p>
    <p>By representing the steps by which a base catalog can be sliced, sifted, amended and edited,
      into a (nominally) <q>finished</q> set of control requirements, a profile makes it easier to
      codify and preserve even very temporary local revisions of a control catalog. Once expressed
      as a profile in OSCAL syntax, that is, a set of emendations to a catalog can be managed
      entirely separately and independently from the catalog.</p>
    <p>This separation of concerns - between the originating catalog authors, who describe policy in
      only general terms, and the authors of the <q>user manual</q> catalog, who must describe
      policy in very particular and local terms - is a necessary factor in supporting sustainable
      processes with the potential for automation and process improvement.</p>
    <p>In order for this to work however we need a process that can perform the necessary
      operations, to <q>apply the delta</q> to an unmodified catalog, to produce the local view of
      the catalog as modified. This is profile resolution.</p>
  </div>
  <div>
    <head>Comments in result documents</head>
    <p>In an XML-based profile resolution, XML comments are one easy way for a processor to trace
      events or conditions without affecting the main results. Two processors are obliged to return
      the same catalog XML for the same profile XML inputs, but they are not required to match one
      another's comments, whitespace usage, attribute order, or processing instructions, only each
      other's elements and attributes.</p>
  </div>
    <section>
      <head>Profile mapping to catalog</head>
      <p>Considered as a <q>document</q> or integrated data set (object), a profile has three sections,
        each of which corresponds to a conceptual step in resolution. To resolve a catalog fully is
        to perform all these steps.</p>
      <p>While the steps are described in this specification as occurring in sequence, a profile
        processor is not obliged to perform them in the order described. Conformance to these
        specifications is determined by whether the results of processing (*resolution*) appear as
        described, not on whether the means to produce those results work in exactly the manner
        described here.</p>
      <p>The three steps are <term>import</term> (control selection); <term>merge</term>; and
        <term>modify</term>. In brief:</p>
      <ul>
        <li><p><term>import</term> identifies one or more control sources (catalogs or profiles) and the
          controls within them to be included in this profile</p></li>
        <li><p><term>merge</term> produces the rules for how controls will be organized and merged (or not)</p></li>
        <li><p><term>modify</term> indicates how parameters in the underlying catalog may be modified or set,
          and how control contents may be amended or modified.</p></li>
      </ul>
      <p>The selection (import) stage is mandatory inasmuch as a profile that imports no controls is
      inoperative. Such a profile is not in error and it can be resolved, but its resolution will
      contain no controls (and as such might fail a validation check against the catalog
      schema).</p>
      <p>The merge stage can be considered mandatory in that there are default rules for merging, to
        be followed when no merge behavior is given; thus <q>no merging</q> is permitted, and a profile
        with no merge semantics indicated is not in error.</p>
      <p>The modify stage is optional in that controls do not have to be modified and parameters do
      not have to be set; a profile is always free to represent these components as they are given
      in their catalogs. Leaving a parameter unset, or qualifying its setting (with additional
      information or constraints) without modifying its value, is also possible; like a catalog, a
      profile can represent a set of controls (and parameters) that are not fully defined, for
      purposes of use at another layer (profile or implementation) where such definition can be
      provided.</p>
      <p>When resolved, an OSCAL profile takes the form of an OSCAL catalog, whose organization and
        parts are described in the next section. The merge semantics described below will produce
        outputs conforming to this organization.</p>
    <section>
      <head>Catalog results - top level</head>
      <p>The following sections describe how to populate and organize the body of a result catalog
        (a target) with controls invoked by a profile from a source catalog. At its base, an OSCAL
          <s>profile</s> source should produce a <t>catalog</t>:</p>
      <mapping source_file="base-test_profile.xml" target_file="examples/base-test_TARGET_catalog.xml">
        <tagging whose="source">&lt;profile id="profile-identifier">...&lt;/profile></tagging>
        <tagging whose="target_catalog">&lt;catalog id="{new-catalog-identifier}">
  &lt;metadata>[Required metadata, as described below]&lt;/metadata>
  [ Controls or control groups, as described below ]
  &lt;back-matter>[Optional back matter as described below]&lt;/back-matter>
&lt;/catalog></tagging>
      </mapping>
      <p>A valid catalog must have <t>metadata</t> in addition to controls and control groups.
        Additionally it may have <t>back-matter</t>. How to produce and populate the <t>metadata</t>
        and <t>back-matter</t> is described below, as is the construction of the <t>catalog/@id</t>
        in the result.</p>
      <p>Since <t>metadata</t> and <t>back-matter</t> both have dependencies on the processing of
        the main body, however (in particular where multiple catalogs are sourced), how controls are
        selected and modified is discussed first.</p>
    </section>
      <section>
        <head>Import</head>
      <p>A profile begins by importing catalogs, all of whose controls are then available for
        selection. Imports are given in series after the metadata:</p>
      <tagging whose="source_profile">&lt;profile>
  &lt;metadata>[ Profile metadata ]&lt;/metadata>
  &lt;import href="#catalog">... selection of controls ...&lt;/import>
  &lt;import href="#catalog-supplemental">... selection of controls ...&lt;/import>
&lt;/profile>
</tagging>
        <p>The resource indicated can be either an OSCAL catalog or an OSCAL profile. A catalog
        provides controls in their native form. An imported profile is resolved on import, using the
        same rules for the resolution of the profile at the top level, so a catalog is presented to
        the importing profile.</p>
        <p>No profile may import itself either directly or indirectly. An import directive that
        indicates either the profile itself, or a profile into which it is being (currently)
        imported, must be ignored. Optionally, a processor may issue a warning.</p>
        <p>In an import directive, the reference to the resource to be imported appears on an
          <s>@href</s> flag. It takes either of two forms, external or internal:</p>
        <section>
          <head>External</head>
          <p>An external reference appears as an absolute or relative URL</p>
          <p>Indicating a file available via <revisit>[prototol?]</revisit></p>
          <tagging whose="source_profile">&lt;import href="../../nist.gov/SP800-53/rev4/xml/NIST_SP-800-53_rev4_catalog.xml">
  &lt;include>
	&lt;call control-id="ac-1"/>
  &lt;/include>
&lt;/import>
</tagging>
        </section>
        <section>
          <head>Internal</head>
          <p>A catalog or profile to be imported can also be indicated using an internal link via a
            URI fragment identifier (starting with <code>#</code>). If an import href resolves to a
              <code>resource</code> elsewhere in the profile (typically in back matter), that
            resource can be retrieved to provide the source catalog.</p>
          <cf  file="examples/base2-test_profile.xml"/>
          <tagging whose="source_profile">&lt;import href="#nist-catalog">
  &lt;include>
	&lt;call control-id="ac-1"/>
  &lt;/include>
&lt;/import>

  ...
  
&lt;back-matter>
  &lt;resource id="catalog">
    &lt;desc>SP 800-53 catalog (OSCAL format) on Github&lt;/desc>
    &lt;rlink href="https://github.com/usnistgov/OSCAL/blob/master/content/nist.gov/SP800-53/rev4/xml/NIST_SP-800-53_rev4_catalog.xml"/>
  &lt;/resource>
&lt;/back-matter>
</tagging>
          <p>An internal cross-reference from an import to a resource that does not reference a
            catalog or profile, or a cross-reference to something other than a resource, is
            inoperative. It may be signaled as an error [or warning] by a processor.</p>
        </section>
        <section>
          <head>Circular imports</head>
          <p>When a profile imports a profile, the subordinate profile is resolved into a catalog
            using the same rules. This presents a possibility of circular imports, when a profile is
            directed to import itself either directly or indirectly.</p>
          <p>A <term>circular import</term> is defined as a directive to import a resource, which has already
            been called higher in the import hierarchy. For example, if Profile A imports Profile B,
            and Profile B imports Profile A, the second import is circular. (An import at the top
            can only be circular if a profile tries to import itself.) If A imports B, B imports C
            and C imports A, C’s import is circular.</p>
          <p>Note that an import can only be circular within the context of processing a particular
            profile. In the last example, C’s import would not be circular if invoked in the context
            of resolving B by itself (without being imported by A), or of resolving some other
            profile that did not import A. (D importing B importing C importing A would not be a
            problem.)</p>
          <p>Circular imports are inoperative, and may be reported as an error <revisit>[or
            warning]</revisit>.</p>
        </section>
        <section>
          <head>Multiple imports</head>
          <p>Multiple imports of the same resource are not an error as long as no circular
            dependencies occur.</p>
          <p>However, multiple imports may result in invalid outputs. Typically this will be because
          a control has been selected twice, and no merge behavior (see below) has been given.</p>
          <p>In general, sibling imports (two imports into the same profile) should never have to
          call the same catalog; and this condition may be reported as a warning. Depending on the
          merge rules and the particular controls being selected, it may or may not result in
          clashing controls.</p>
        </section>
        <section>
          <head>Availability of documents returned by given URIs</head>
          <p>The rules of XSLT <code>document()</code> apply to the traversal of any URI: that is,
            it is assumed that all calls to a given (resolved) URI reference, will return the same
            result.</p>
        <p>If documents called for import are determined to be unavailable, the processor may drop
          them along with a warning, both or either out of band (e.g. through <code>STDERR</code>)
          or in the catalog results.</p>
        </section>
        <section>
          <head>Selecting controls</head>
          <p>Imports can specify controls by inclusion and exclusion, either or both in
            combination.</p>
          <section>
            <head>Inclusion</head>
            <p>Using inclusion, all or some controls may be selected from a catalog.</p>
          <section>
            <head>Selecting by ID</head>
            <p>Select individual controls or controls by groups using <s>control-id</s> selectors
              corresponding to their IDs.</p>
            <cf file="examples/base-test_profile.xml"/>
            <tagging whose="source">&lt;include>
  &lt;call control-id="ac-1"/>
&lt;/include>
</tagging>
          </section>
          <section>
            <head>Matching IDs to select groups of related controls</head>
            <p>Controls may also be selected using match patterns against their IDs. This is useful
              because related controls (either in a hierarchy, or together in a group) frequently
              have related IDs as well.</p>
            <cf file="examples/include-match-test_profile.xml"/>
            <tagging whose="source">&lt;include>
  &lt;call match="^ac"/>&lt;!-- matches any control whose ID matches regex '^ac' -->
&lt;/include>
</tagging>
            <p><revisit>Calls and matches cannot be combined in a single include. To use both, use
                more than one include statement. (See Issue 525.)</revisit></p>
            <p><revisit>The match pattern is evaluated as a regular expression using XPath regular
                expression syntax. [XXXX]</revisit></p>
          </section>
          <section>
            <head>Selecting all controls</head>
            <p>Select all controls from a catalog by using an <s>include/all</s> rule:</p>
            <cf file="examples/include-all-test_profile.xml"/>
            <tagging whose="source">&lt;include>
  &lt;all/>
&lt;/include>
</tagging>
          </section>
            <section>
              <head>Including child controls</head>
              <p>In OSCAL, controls may contain controls. For example, in SP 800-53 many controls
              are supplemented with control enhancements; in OSCAL these are represented as child
              controls within parent controls. So parent AC-2 has children AC-2(1) through AC-2(13),
              for example.</p>
              <p>Child controls can be included by the same mechanism as controls, i.e. by means of
                an ID call. Alternatively a match can frequently be applied (at least given most ID
                assignment schemes) to match controls and child controls together.</p>
              <p>Additionally, a <s>with-child-controls</s> directive on a <s>call</s> or
                <s>match</s> can indicate that child controls (that is, direct children not all
              descendants) should be included with the applicable call(s) or match(es).</p>
              <p>Furthermore, <s>all[@with-child-controls='no']</s> may select all controls placed
              directly within a group, excluding all  controls appearing inside other controls.</p>
            <cf file="include-all-no-children.xml"/>
            </section>
          </section>
          <section>
            <head>Exclusions</head>
            <p>Exclusions work the same way as inclusions, except with the opposite effect - the
            indicated control(s) do not appear in the result catalog.</p>
            <p>Additionally, there is no such thing as <s>exclude/all</s>, which is invalid and
            should be considered inoperable.</p>
            <p>Any control designated to be both included and excluded, is excluded. This holds
            irrespective of the specifity of the selection for inclusion or exclusion. For example,
            if AC-1 is included by id <code>ac-1</code> and excluded by matching <code>ac.*</code>,
            it is excluded. Selection for exclusion prevails.</p>
          </section>
          <section><head>Implicit <s>all</s></head><p>An empty import statement should be considered the same as an import with an <s>include/all</s>.
            An empy import instruction</p><tagging whose="source">&lt;import href="#nist-catalog"/>
</tagging><p>is
            functionally equivalent to
              this:</p><tagging whose="source">&lt;import href="#nist-catalog">
  &lt;include>
    &lt;all/>
  &lt;/include>
&lt;/import>
</tagging>
          <cf file="examples/include-all-implicit-test_profile.xml"/><p>The
              same thing occurs if an exclude instruction is given without an include
              instruction.</p><p>Example:</p><tagging whose="source">&lt;import href="#nist-catalog">
  &lt;exclude>
    &lt;call control-id="ac-1"/>
  &lt;/exclude>
&lt;/import>
</tagging><p>is
            the same as
              this:</p><tagging whose="source">&lt;import href="#nist-catalog">
  &lt;include>
    &lt;all/>
  &lt;/include>
  &lt;exclude>
    &lt;call control-id="ac-1"/>
  &lt;/exclude>
&lt;/import>
</tagging><p>Result: all controls from the catalog are included <em>except</em> AC-1.</p>
          <cf file="examples/exclude-call-test_profile.xml"/></section>
        </section>
      <section>
        <head>Copying parameters</head>
        <p>Unlike controls, parameters are copied implicitly. Whether a parameter in the source
          catalog is copied into the result depends on two factors: its location, and whether it is
          referenced by an <t>include</t> directive in the result catalog.</p>
        <section>
          <head>Parameters given in controls</head>
          <p>Any parameter (<s>param</s> element) that appears in a control being selected, appears
            in the result, unless the parameter element was indicated by a remove statement (see
            below).</p>
          <mapping>
            <tagging whose="source">&lt;control id="a1">
    &lt;title>Control A1&lt;/title>
    &lt;param id="param-a1.a">
        &lt;label>a1.a parameter&lt;/label>
        &lt;value>a1.a value&lt;/value>
    &lt;/param>
    &lt;prop name="status">alive&lt;/prop>
    &lt;part name="statement" id="a1-stmt">
        &lt;p>A1 aaaaa aaaaaaaaaa&lt;/p>
    &lt;/part>
&lt;/control></tagging>
          </mapping>
          <cf file="examples/include-all-test_profile.xml"/>
        </section>
        <section>
          <head>Loose parameters</head>
          <p>Parameters may sometimes be given in catalogs outside of controls. For example, a
            parameter that is referenced from inside two different controls, may be represented
            outside both of them, within a group.</p>
          <p>These parameters are copied if (only if) a control is also propagated, which after
            modification contains an <s>insert</s> directive referencing this parameter. The
            parameter appears in the location in the resolved catalog corresponding to its location
            in the source, albeit ungrouped if no <s>merge/as-is</s> is given.</p>
          <p>When a catalog is organized by a <s>merge/custom</s> directive, loose parameters are
            copied into the resulting grouping structure directly preceding the first control
            appearing that contains an <s>insert</s> instruction referencing that parameter.</p>
          <p>Parameters that are not referenced by an <s>insert</s>, do not appear in the result
            catalog.</p>
        </section>
      </section>
      </section>
      <section>
        <head>Merge - defines rules on how to arrange / manage controls</head>
        <section>
          <head><s>merge/combine</s> - handling control collisions</head>
          <p><term>Colliding controls</term> (or <term>clashing</term>) describes the condition that
          occurs when multiple invocations of controls with the same ID are given, and so a profile
          resolution will result in duplicative and/or contradictory information. Even given a rule
          against multiple imports of the same resource, it may frequently occur that in profiles
          (especially profiles under development), multiple copies – and with variations – may be
          invoked from different sources. For example, if a profile tailors another profile which
          includes a control with amendments, and then (the top-level profile) includes the same
          control directly from its original catalog, a collision will occur between these two
          variants.</p>
          <p>Generally such a collision is readily detectable as long as IDs have not been modified;
          in other words, constraints over uniqueness (within document scope) of IDs will be
          violated in resolved instances where two (perhaps different) representations of the same
          control appear. Careful profile authors will be able to detect and prevent these resulting
          problems.</p>
        <p>Apart from handling problems and exceptions, however, for different purposes different
          profiles might wish to apply different rules. The combination rules to be applied are
          given in the profile <s>merge/combine</s> element as a <s>method</s> attribute (flag).</p>
          <section>
          <head>No <s>merge/combine</s> given</head>
          <p>If no <s>merge</s> instruction is given in the profile, or if a <s>merge</s> is given
            without a <s>combine</s>, the <term>keep</term> rules are applied to controls selected,
            as if <s>merge/combine[@method='keep']</s> were given.</p>
          <mapping>
            <tagging whose="source">&lt;profile>
  &lt;import href="#catalog1"/>
  &lt;import href="#catalog2"/>
&lt;/profile></tagging>
          </mapping>
          <p>is the same as</p>
          <tagging whose="source">&lt;profile>
  &lt;import href="#catalog1"/>
  &lt;import href="#catalog2"/>
  &lt;merge>
    &lt;combine method="keep"/>
  &lt;/merge>
&lt;/profile></tagging>
        </section>
        <section>
          <head><s>merge combine[@method='keep']</s> ()</head>
          <tagging whose="source">&lt;merge combine="keep"/>
</tagging>
          <p>This is also the default if no <s>merge/combine</s> directive is given. It indicates
            that colliding controls should simply be copied through, for handling downstream.</p>
          <p>While colliding controls will result in invalid results under this setting, since care
            should be taken that controls do not collide in any case, this setting may be useful in
            ensuring integrity of referencing as given in the profile: if any included control is
            called only once, clashing controls will not be produced and validation will
            succeed..</p>
        </section>
          <section>
            <head><s>merge combine[@method='use-first']</s></head>
          <tagging whose="source">&lt;merge combine="use-first"/>
</tagging>
            <p>The first reference to a given control prevails over later references. <q>First</q>
            is determined by a top-down, depth-first traversal of the profile import hierarchy. So
            if a profile is imported before a catalog, and the imported profile presents a
            representation of a control also given in the catalog import, the profile’s
            representation (perhaps modified) is taken.</p>
            <p>The same logic applies to parameter settings.</p>
          </section>
          <section>
            <head>merge combine[@method='merge']</head>
            <p>The processor should merge all representations of a given control, into a single
              unified representation.</p>
            <p>The single unified representation is assembled by aggregating all the contents of all
              the (clashing) control instances and discarding duplicate branches.</p>
            <p>Example:</p>
            <tagging whose="source">&lt;control id="a1">
  &lt;title>Control A1&lt;/title>
  &lt;prop name="label">A-1&lt;/prop>
  &lt;prop name="status">pending&lt;/prop>
&lt;/control>
</tagging>
            <p>merging with</p>
            <tagging whose="source">&lt;control id="a1">
  &lt;title>Control A1&lt;/title>
  &lt;prop name="label">A-1&lt;/prop>
  &lt;prop name="status">ready&lt;/prop>
&lt;/control>
</tagging>
            <p>results in</p>
            <tagging whose="target">&lt;control id="a1">
  &lt;title>Control A1&lt;/title>
  &lt;prop name="label">A-1&lt;/prop>
  &lt;prop name="status">pending&lt;/prop>
  &lt;prop name="status">ready&lt;/prop>
&lt;/control>
</tagging>
            <p>[tbd]</p>
          </section>
        </section>
        <section>
          <head>How to build a structure</head>
          <section>
            <head>Unstructured catalog output</head>
            <p>Two <code>merge</code> directives are used to introduce structure into a profile
              result catalog, <code>as-is</code> and <code>custom</code>.</p>
            <p>Profiles that have neither of these directives are resolved as unstructured catalogs,
              with no groups of controls. Where controls are given as</p>
          </section>
          <section>
            <head>as is</head>
            <p>reproduce structure of input catalog</p>
            <p>(consider case of multiple imports of single resource)</p>
            <section>
              <head>Implicit inclusions under <s>as-is</s></head>
              <p>Under <term>as is</term>, a resolved profile’s structure is expected to replicate the
                structure of source catalogs.</p>
              <p>This is achieved by propagating, with all controls that are included, all groups
                that they appear within, along with the groups’ IDs, titles and other contents.</p>
              <p>Groups that do not include controls that have been included (either directly or as
                descendants of contained groups, are not propagated to the result.</p>
              <p>In addition to groups, under 'as is' mergine, certain controls will be included
                implicitly. This happens when they have not been called, but they contain controls
                that have been called. Such controls are treated like groups included 'as is' – they
                must be propagated to retain the structure for descendant controls.</p>
              <p>Unlike groups, however, the title of such a control is given with the resolution,
                but no other contents are presented apart from (a) controls included explicitly or
                (b) child controls that must be included for the sake of their own (included) child
                (or descendant) controls.</p>
              <p>Example:</p>
              <tagging whose="source">&lt;import href="#XYZ-catalog">
  &lt;include>
    &lt;call control-id='xyz-1.1'/>&lt;!-- bedtime routine control -->
    &lt;call control-id='xyz-1.2.1'/>&lt;!-- kitchen trashcan -->
  &lt;/include>
&lt;/import>
</tagging>
              <p>the result would be</p>
              <tagging whose="target">&lt;control id="xyz-1">
  &lt;title>Basic Hygiene&lt;/title>
  &lt;control id="xyz-1.1">&lt;!-- bedtime routine -->...&lt;/control>
  &lt;control id="xyz-1.2">
    &lt;title>Kitchen cleanup&lt;/title>
	&lt;control id="xyz-1.2.1">&lt;!-- kitchen trashcan -->...&lt;/control>
  &lt;/control>
&lt;/control>

</tagging>
            </section>
          </section>
          <section>
            <head><s>custom</s></head>
            <p>a structure is provided, and controls are selected into it</p>
            <p>(nb this means that import/all with selection here also works)</p>
            <p><s>@with-child-controls</s> works, but all other organization is explicit (unlike 'as
            is' merging).</p>
          </section>
        </section>
      </section>
      <section>
        <head>Modify - controls are amended or modified</head>
        <p>(Aka <term>patching</term>) Explicit modification of control content</p>
        <p>There are two ways a control may need to be modified. Commonly, controls might be amended
        – new material might be added. (For example, the priority marker properties P1-P3 in the
        SP800-53 LOW MODERATE and HIGH baselines.) Less commonly, materials might be removed or
        edited.</p>
        <p>OSCAL does not provide for <q>changing</q> a control, but editing can be achieved by removing
          contents and adding (edited) contents back. In other words, editing is considered to be
          the same kind of patching as removing combined with adding.</p>
        <section>
          <head>Parameter settings</head>
          <p>Modification of parameter settings is indicated using <s>set</s>.</p>
          <p>Parameters are not always given within controls. A profile resolution result must
            include copies (with or without modifications or settings) of all parameters defined
            within the source catalog, which are referenced from 'insert' instructions anywhere
            inside included controls.</p>
        <p>Accordingly, any parameter referenced by an <s>insert</s> in any source catalog is copied
          from catalog source to result <revisit>parameter propagation rules for merge/as-is,
            merge/custom</revisit>, even if the results are invalid to the catalog schema, without
          any configuration required in the profile.</p>
          <p>However, a profile should not reproduce parameters from source catalogs, which are not
          referenced from <s>insert</s> instructions.</p>
          <p>When parameters are propagated, they may be modified by <s>set</s> instructions given
          in the profile.</p>
        <p>If more than one <s>set</s> instruction is given for the same parameter, all are applied,
          in the sequence given in the profile. <revisit>[XXX even when
            merge/combine/@method='use-first'?]</revisit></p>
          <ul>
            <li><p>A <s>set/title</s> replaces the <s>param/title</s> on the affected parameter</p></li>
            <li><p>A <s>set/label</s> replaces the <s>param/label</s> on the affected parameter</p></li>
            <li><p>A <s>set/value</s>
              <em>or</em> a <s>set/select</s> replaces <em>any</em>
              <s>param/value</s> or <s>param/select</s> on the affected parameter</p></li>
            <li><p>Other elements given in a parameter <s>set</s> are added to the affected
              parameter, after elements of the same name</p></li>
            <li><p>The prescribed order of all elements in the affected parameter is retained:
                <t>label</t>; <t>usage</t>; <t>constraint</t>;
                <t>guideline</t>; <t>value</t> or <t>select</t>; and
                <t>link</t>.</p></li>
          </ul>
          <p>[example]</p>
          <tagging whose="source">&lt;param id="p1">
  &lt;title>Password length&lt;/title>
  &lt;value>10&lt;/value>
&lt;/param>

...

&lt;set param-id="p1">
  &lt;select>
    &lt;choice>10&lt;/choice>
    &lt;choice>11&lt;/choice>
  &lt;/select>
</tagging>
        <section>
          <head>Setting a missing parameter</head>
        </section>
        </section>
      </section>
    </section>
    <section>
      <head>Result catalog structure</head>
      <section>
        <head>Form and organization of resolution out</head>
        <p>The output of a profile resolution should take the form of a catalog.</p>
        <p>(Validation against the catalog schema … recommended but not required?)</p>
      </section>
      <section>
        <head>top-level @id</head>
        <p>Because document IDs are sometimes used to distinguish data points in processing context,
          a resolved profile may not present the same ID as any of the catalogs it is importing, or
          the same ID as its source profile.</p>
        <p>It is permitted to produce the profile’s ID in resolution via a static mapping from the
          ID of the source. For example, the resolution of profile with ID 'profile-X' might have ID
          'profile-X-RESOLUTION'.</p>
      </section>
      <section>
        <head>Instance metadata</head>
        <p>[XXX Rules for constructing or copying or modifying a metadata section for a resolved
          profile]</p>
        <tagging whose="target">&lt;title>{ profile title} RESOLUTION&lt;/title>
&lt;last-modified>{ resolution date stamp }&lt;/last-modified>
&lt;prop name="catalog-title">{ imported catalog title }&lt;/prop>
&lt;prop name="catalog-title">{ imported catalog title }&lt;/prop>
</tagging>
      </section>
    <section>
      <head>Groups and <q>loose</q> parameter declarations</head>
      <p>Unless it be for special purposes in a debugging or tracing mode, profile results may not
        show and groups or structures in the form of elements not described here. Depending on the
        merge instruction, all groups will be given either by the catalog source(s)
          (<s>merge/as-is</s>) or the profile (<s>merge/custom</s>), or there will be no groups at
        all (no merge rule).</p>
      <p><revisit>what do we do with loose parameters that have no place to live when groups are
          discarded? pass them through and get invalid outputs.</revisit></p>
    </section>
      <section>
        <head>Profile back matter</head>
        <p>Profiles may have back matter.</p>
        <p>Under the <term>no merge</term> rules, profile back matter is copied into the resulting catalog
          without modification, along with back matter filtered from imported catalogs and profiles
          (next section). This may result in invalid outputs when more than a single back-matter is
          given in the results.</p>
      </section>
      <section>
        <head>Resource back matter</head>
        <p>Back matter in OSCAL can contain either or both citations and resources.</p>
        <p>A citation is a reference to an out of line document, included for reference purposes.
          Controls may contain cross-references to these citations.</p>
        <p>A resource is like a citation, but is more tightly controlled with a more rigorous
          description. It is used to designate any materials that are either formally part of a
          document but not encoded with it (such as a file attachment in a foreign format), or
          materials with support for identification or authentication, such as by comparing
          cryptographic hashes.</p>
        <p>When a profile is resolved, only citations and resources that are actually referenced
          from contents in the catalog <em>as resolved</em>, should be included.</p>
      </section>
      <section>
        <head>Result structure</head>
        <p>The rest of the catalog is structured as follows:</p>
        <p>If no 'merge' was given, or if 'merge' is given without 'custom' or 'as-is', controls are
          flat.</p>
        <p>If merge/custom is used, see above.</p>
        <p>Special case rules for handling multiple imports - are controls grouped by their source
          catalogs (intermediate or ultimate) and should the import hierarchy be reflected?</p>
        <p>(Examples)</p>
      </section>
      <section>
        <head>Merge clashes</head>
        <p>… merge clash rules …</p>
        <p>… examples …</p>
      </section>
    </section>
    <section>
      <head>Profile resolution illustrated</head>
      <p>Representational issue</p>
      <p>A profile’s results next to its original catalog(s)</p>
      <p>Chains of modifications should be traceable</p>
    </section>
    <section>
      <head>Profile tools/utilities</head>
      <ul>
        <li><p>rendering - showing both unresolved (raw) and resolved profiles</p></li>
        <li><p>editing / integrity checking</p></li>
        <li><p>rewriting/normalization</p></li>
        <li><p>diffing</p></li>
        <li><p>deriving a profile as the delta of two catalogs ('base' and 'profile')</p></li>
      </ul>
    </section>
  </SPECIFICATION>