default namespace = "http://csrc.nist.gov/ns/oscal/1.0"

# This module declares core components of catalogs. It includes the declarations model.

include "oscal-declarations.rnc" { 

  start = catalog

}

catalog = element catalog { catalog-contents } 

catalog-contents   = (title, declarations?, (section | controlGroup | control)*, references?)

section = element section { idAttr?, optionalClass,
  title, prose, section*, references? }

# groups may contain more groups, controls or subcontrols
# But controls should not appear in controls (even grouped)
# And subcontrols must not appear without control ancestors
# ... these constraints validated w/ Schematron

controlGroup = element group {
  idAttr?, optionalClass,
  title?, ( param | link |  prop | part )*, (controlGroup | control)+, references? }

# done with declarations - controls, subcontrols and groups are not declared
# (constrained) at the OSCAL layer so they don't get declaration elements.

# Now for the contents of the OSCAL doc proper ...

control =
  element control {
    idAttr?, optionalClass, title?, ( param | link |  prop)*, (part | subcontrol)*, references?
  }

#inControl =  title?, (control-components | subcontrol)*, references?
    
subcontrol =
  element subcontrol {
    idAttr?, optionalClass, title?, ( param | link |  prop | part )*, references?
  }

#inSubcontrol = title?, control-components, references?

# Rule of thumb for the difference:
# - prop if it's a simple scalar value, never markup of any kind, typically a controlled value
# - p if it's a paragraph or fragment; may contain inline markup
# - part for anything else (statements or more complex structures)

# see utility.xq for analytic breakdown of part types
# so far: description, guidance

# === Back to regular programming

# parts are addressable like controls, but can also have prose content
part =
  element part { asPart }

# asPart allows other things (in importing schemas) to declare themselves as parts or part-like
asPart = 
    idAttr?, optionalClass, title?,
    (param | prop)*, prose*, (link | part)*

title = element title { (text | q)* }

link    = element link { relAttr, hrefAttr, mix }


param   = element param { idAttr?, optionalClass, desc, label?, value? }

desc = element desc { mix }

label = element label { text }


prop =
  element prop { asProp }

# asProp allows other things (in importing schemas) to declare themselves as properties or property-like
asProp = idAttr?, optionalClass, text

prose = ( p | ul | ol | pre )*


references = element references { ref+ }

# JATS-like references
ref = element ref { idAttr?, (std | citation | prose )* }

# analogous to JATS mixed-citation[@citation-type='standard'] or equivalent
std =  element std {
         attribute href { xsd:anyURI }?,
         (mix | xref)*
  }

# analogous to JATS mixed-citation
citation =  element citation {
         attribute href { xsd:anyURI }?,
         (mix | xref)*
  }


# We can map more html in if/as needed

p = element p { asP }

# Anything p-like can be declared 'asP', which is to say mixed content (unlike parts and props)
asP = idAttr?, optionalClass, whatnot

pre = element pre { idAttr?, (mix | xref)* }

ol = element ol { element li { idAttr?, optionalClass, (whatnot | ol | ul )*  }+ }

ul = element ul { element li { idAttr?, optionalClass, (whatnot | ol | ul )* }+ }

# whatnot includes 'semantical' elements along with the inline mix

whatnot = (
  semantical | mix | xref)*

# note mix does not include anchors, which do not come for free
mix = (inlines | text)*

# declaring as zeroOrMore/choice avoids XSD substitution group
inlines = (  q | code | em | i | b | sub | sup | span )*

# q is a little special, it's not just mix
q = element q { (code | em | i | b | sub | sup | span | text)* }

# A bit of code (perhaps capable of evaluation in the correct context)
code = element code { optionalClass, mix }


em = element em { optionalClass, (mix | xref)* }
i  = element i  { optionalClass, (mix | xref)* }
b  = element b  { optionalClass, (mix | xref)* }

sub = element sub { optionalClass, text }
sup = element sup { optionalClass, text }


# An arbitrary span
span = element span { optionalClass, (mix | xref)* }

# Using HTML for this
xref = element a { attribute href { text }?, ( q | code | element em { optionalClass, text } | text )* }

# not html!

# declaring as zeroOrMore/choice avoids XSD substitution group
semantical = ( withdrawn | assign | select )*

# A placeholder status report typically with a cross-reference
withdrawn = element withdrawn { (inlines | text)* }

# A value to be assigned by responder via parameter
# (a parameter must be available)
assign = element insert { idAttr?,
  attribute param-id { xsd:IDREF } }

# A selection to be made by responder - tbd
select = empty
# select = element select { idAttr?, choice* }

# Within a selection, a choice - tbd
# unlike 'value', choice may have inline stuff as well as 'assign' elements
# choice = element choice { (assign | mix)* }

# IDs are required everywhere for now
idAttr      = attribute id { xsd:ID }

# we used to distinguish btw @type and @name the latter for components
# now we overload 'class' every which way
requiredClass = attribute class { text }

optionalClass = attribute class { text }?

hrefAttr = attribute href { text }?

#requiredClass = attribute name { xsd:NCName }
