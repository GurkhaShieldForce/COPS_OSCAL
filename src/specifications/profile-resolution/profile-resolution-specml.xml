<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="specml.rnc" type="application/relax-ng-compact-syntax"?><!--<?xml-stylesheet type="text/xsl" href="specml-html-xslt1.xsl"?>-->
<?xml-stylesheet type="text/css" href="specml.css"?>
<?xml-model href="spec-checkup.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?><!-- 
Standing list of general TODO:

-Check for proper usage of inline tags: <src><tgt><inter><term><code>
-Spelling/Grammar
-Term usage (may need group agreement):
  -Capitilization consistency
  -Word choice consistency (object,field,element,child,parent,etc)
-->
<SPECIFICATION xmlns="http://csrc.nist.gov/ns/oscal/specml">
  <head>OSCAL Profile Resolution</head>
  <section id="abstract">
    <head>Abstract</head>
    <p>This specification provides the requirements for transforming and rendering one or more OSCAL
      Profile and Catalog Documents as a new OSCAL Catalog Document. This process of applying
      profiles to a catalog to create a new catalog is called <term>Profile Resolution</term>. This
      specification is intended for software developers who are or who intend to develop an OSCAL
      Profile Resolver, or for OSCAL Profile authors who want a more in-depth understanding of
      profile resolution.</p>
  </section>
  <section id="intro">
    <head>Introduction</head>
    <section id="purpose">
      <head>Purpose</head>
      <p>This document defines the normative requirements for an OSCAL Profile Resolver. Profile resolution is core to addressing a 
      fundamental OSCAL requirement: the representation of baselines separately from the control catalogs on which they depend). The requirements for resolution must therefore be well-defined and deterministic, enabling tool developers and parties exchanging OSCAL profiles can work from a common understanding.</p>
      <p>No requirements are placed on implementation-level details, instead, requirements are laid
        out as what the output of resolution must look like given a certain input. By adhering to
        these requirements OSCAL producers, OSCAL consumers, and any other members of the OSCAL
        ecosystem can create and resolve Profiles deterministically, with repeatable results, regardless of the tool used. </p>
    </section>
    <section id="infocontext">
      <head>Informational Context and Scope</head>
      <p>A <term>profile</term> in OSCAL represents a selection and configuration of a set of
        <term>controls</term>. In the normal case, the set of controls available to a profile is
          provided by a catalog.For example, the three NIST SP 800-53 profiles representing the impact baselines HIGH, MODERATE and LOW: call on a Catalog representing the families, controls and control enhancements described in SP 800-53/53A. In a data
          processing system, this dependency can be modeled in the form of separate documents or
          data instances - the (nominal) <q>catalog</q> and its <q>profile</q>, the latter being a
          selection, adaptation and organization of controls, as distinct from the catalog from
          which those controls are derived.</p>
      <p>However, profiles may also select controls from profiles, thus deriving them from
          underlying catalogs as modified by those profiles. This feature enables an organization
          that wishes to promulgate guidelines or requirements to do so by publishing a set of
          customizations to an existing catalog, rather than create a catalog from scratch. Profiles
          can also arrange combinations of controls from more than one catalog or profile origin,
          making it possible to use them to support the creation of hybrid catalogs. </p>
      <p>In the general case OSCAL must support sourcing more than one catalog at once, in order
          to aggregate and organize controls from disparate sources. For example, it should be
          routine for a profile to acquire its controls from an authoritative standard catalog, plus
          a local supplement. But multiple catalog inputs, especially when they are produced and
          sourced independently of one another, may not combine without issues. In order to provide
          sensible and transparent results even for incoherent inputs, this specification defines
          these processes such that legible and testable results are produced even when they are
          formally invalid to constraints governing the outputs. Such downstream processing errors
          including validation errors are expected to be detectable and remediable. This especially
          applies to situations where multiple catalogs are sourced, or where the same catalog is
          sourced more than once, directly or indirectly.</p>
      <p>In order to support these semantics – because whatever data set is sourced by a profile,
          it must <q>look like a catalog</q> – the results of resolving a single profile must be in
          the form of a single catalog. Two different OSCAL processors that promise profile
          resolution, must deliver, for the same input, the same catalog with regard to its
          contents: which controls are included; their ordering (insofar as the target format
          represents ordering); and the structure (groups) in which they are embedded. This
          specification is designed to make this possible, by defining outputs with sufficient rigor
          that <q>the same</q> is meaningful and testable in this context.</p>
    </section>
    <section id="why-a-catalog">      <!-- TODO: Needs more in-depth editing pass -->
      <head>Why resolve a profile as a catalog</head>
      <p>A profile is a representation of a delta, a <q>here to there</q>. As such, a profile
          might be conceived of as a recipe or instruction set – a sequence of steps or procedures –
          whereby to create an OSCAL catalog (set of controls describing security requirements) from
          an OSCAL catalog (set of controls describing security requirements). The primary use case
          for this is when we need to make a new catalog to apply to a system or set of systems,
          starting from a canonical, received, mandated or standard catalog with a more general
          scope.</p>
      <p>This is because although catalogs - for example, the controls described in NIST SP 800-53
          - are published, available for use, and even standardized, they can never be used exactly
          in the form in which they are acquired. They must be taken from the packaging and placed
          into operational context before they mean anything. This typically requires that a few
          operations over <q>raw catalogs</q> be supported by a profiling mechanism. We must be able
          to select controls; we must be able to arrange them in order (or not); and we must be able
          to qualify or condition them by setting parameters defined for them and making adjustments
          to them. </p>
      <p>By representing the steps by which a base catalog can be sliced, sifted, amended and
          edited, into a (nominally) finished or ready set of control requirements, a profile makes
          it easier to codify and preserve even very incidental or temporary local revisions of a
          control catalog. Once expressed as a profile in OSCAL format, a set of amendments to a
          catalog (also known as "tailoring") can be managed entirely separately and independently from the catalog. Because a
          conformant processor can always create the customized catalog by resolving the profile
          against its sources (executing the transformation described in this document), the profile
          can also be examined and used as a proxy for that catalog for other purposes. The
          customized catalog can be made available wherever and for whatever purposes it is needed,
          while its revision and maintenance can be focused on the profile.</p>
      <p>This separation of concerns - between the originating catalog authors, who describe
          policy in only general terms, and the authors of the <q>user manual</q> catalog, who must
          describe policy in very particular and local terms - is a necessary factor in supporting
          sustainable processes with the potential for automation and process improvement. An OSCAL
          profile bridges the gap between a set of general guidelines, and actionable rules. Only by
          examining the system in the context of the actual intentions appropriate to that system,
          can we properly assess its security. Profiles make this possible.</p>
      <p>In order for this to work however we need a process that can perform the necessary
          operations, to apply the delta to an unmodified catalog, to produce the local view of the
          catalog as modified. This is profile resolution.</p>
    </section>
  </section>
  <section id="readingthis">
    <head>Reading This Document</head>
    <section id="terminology">      <!-- TODO: Parse document for additional terms to add -->
      <head>Terminology</head>
      <p>Due to the overload of technical terms used in this domain, the following terms have been
          defined to reduce ambiguity:</p>
      <ul>
        <li>
          <p>
            <term>profile</term> - an OSCAL Profile Document. Defines a set of selections,
              modifications, and transformations against a <term>catalog</term>. See <a href="https://pages.nist.gov/OSCAL/concepts/layer/control/profile/">OSCAL Profile
                Model</a>.
          </p>
        </li>
        <li>
          <p>
            <term>catalog</term> - an OSCAL Catalog Document. Contains a well-defined set of
            <term>controls</term>. See <a href="https://pages.nist.gov/OSCAL/concepts/layer/control/catalog/">OSCAL Catalog
                Model</a>.
          </p>
        </li>
        <li>
          <p>
            <term>control</term> - an individual item in an OSCAL Catalog. See <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r5.pdf">NIST Special Publication 800-53r5</a> for a more in-depth definition.</p>
        </li>
        <li>
          <p>
            <term>profile resolution</term> - The process of consuming one or more OSCAL Profiles
              and the OSCAL Catalogs that they reference to produce a new tailored
            <term>catalog</term>. See <a href="https://pages.nist.gov/OSCAL/concepts/layer/control/catalog/">OSCAL Catalog
                Model</a>.
          </p>
        </li>
        <li>
          <p>
            <term>source</term> - refers to a profile document, or in some cases, an object
              inside a profile document. The <term>source or sources</term> are the input into the
              processor. In this document, when referring to objects from a <term>source</term>
              document, the following style is used: <src>source-object</src>.
          </p>
        </li>
        <li>
          <p>
            <term>target</term> - the intended output of the transformation, a catalog
              document. In this document, when referring to objects of a <term>target</term>
              document, the following style is used: <tgt>target-object</tgt>.
          </p>
        </li>
        <li>
          <p>
            <term>directive</term> - refers to an object or combination of objects in source
              documents, which is designed to affect a particular outcome in the target catalog. For
              the most part, directives are in the source profile document – for example, a
            <src>set-parameter</src> object in a source profile is a directive to set a
              parameter value in the target catalog.</p>
        </li>
        <li>
          <p>
            <term>original order</term> - the order of objects as presented in the
            <term>source</term> document(s). See XYZ.</p>
        </li>
        <li>
          <p>
            <term>canonical order</term> - the order of objects as required in the appropriate
              OSCAL Model (Profile, Catalog, etc.). This can differ from the above order when
              converting between &quot;ordered&quot; formats (ex. XML), and &quot;non-ordered&quot; formats (ex.
              JSON).</p>
        </li>
        <li>
          <p>
            <term>control selection</term> - Collections of controls in an intermediate state
              while going through processing steps. <term>Control selections</term> are represented
              in this document as concrete for example only, no OSCAL Profile Processor is required
              or expected to actually produce or recognize such content.</p>
        </li>
      </ul>
    </section>
    <section>
      <head>Requirement Keywords</head>
      <p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD
          NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be
          interpreted as described in <a href="https://tools.ietf.org/pdf/bcp14.pdf">BCP 14</a>
        <a href="https://tools.ietf.org/pdf/rfc2119">[RFC2119]</a>
        <a href="https://tools.ietf.org/pdf/rfc8174">[RFC8174]</a> when, and only when, they
          appear in all capitals, as shown here.</p>
    </section>
    <section id="use-of-yaml">
      <head>Use of YAML</head>
      <p>OSCAL supports a variety of serialization formats, each of which having it&apos;s own benefits
          and drawbacks. In this document, YAML (YAML Ain&apos;t Markup Language) is used to represent
          the various objects of the <term>source</term> and <term>target</term>. All examples and
          in-line references will be represented using <a href="https://yaml.org/spec/1.2/spec.html">YAML 1.2</a>.
      </p>
      <p>YAML maps cleanly to JSON, thus allowing easy use of existing JSON/XML transformers where
          needed. With that in mind, the <a href="https://pages.nist.gov/OSCAL/reference/latest/complete/json-reference/">OSCAL
            Complete JSON Reference</a> is a valuable resource for understanding the YAML-based information structures used in this
          document. All JSON properties and objects defined in the reference equate to a YAML
          mapping, list, or dictionary.</p>
    </section>
    <section id="reading-examples">
      <head>Reading YAML Examples</head>
      <p>YAML is a particularly human-readable format. For those unfamiliar with the format, the
          basics: </p>
      <ul>
        <li>
          <p>Each line is a key-value pair, presented as <code>key:value</code>, or as
            <code>key:</code> with any number of list items on the following lines.</p>
        </li>
        <li>
          <p>Indentation, spacing, and white space matters. Items below a key and indented one
              level in are members (or children) of that key.</p>
        </li>
        <li>
          <p>List items are represented with a preceding dash <code>-
              listitemkey:value</code>.
          </p>
        </li>
      </ul>
      <p>The YAML specification is freely available here: <a href="https://yaml.org/spec/1.2/spec.html">YAML 1.2</a>.
      </p>
      <p>Additionally, in order to unambiguously express information, this specification uses
          additional conventions, as described below.</p>
      <p> There are some objects whose values must be determined dynamically at processing time.
          The most common example of this is timestamping output as it is processed. In this case,
          and any other dynamic-value cases, the expression <code>${{ }}</code> is used.</p>
      <p>For example: </p>
      <tagging whose="target_catalog">last-modified: ${{ timestamp }}</tagging>
      <p>Indicates the <tgt>last-modified</tgt> object should be produced with contents generated
          appropriately, in this case, the timestamp at the time of processing.</p>
      <p>Some examples may elide content to enhance readability or save space. In these cases, 
          the characters <code>~~~</code> will appear on their own line. This is not valid YAML, and
          is only a convention in this document.</p>
      <p>Finally, although examples are syntactically faithful to OSCAL, they are not necessarily
          always formally valid in every respect. For example, OSCAL defines allowed property names
            (        <src>props</src>) and values, and those rules may not be observed here. Examples are
          given for purposes of illustrating profile resolution semantics only, and should not be
          taken as normative for any actual use.</p>
    </section>
    <section id="document-layout">
      <head>Document Layout</head>
      <p>The specification is broken into the following major sections:</p>
      <ul>
        <li>
          <p>
            <term>Phases of Profile Resolution</term> - Lays out the necessary steps and phases
              of profile resolution. As each phase executes, the processor is understood to be
              creating and editing an intermediate representation of the output. There is one section for each of the three main phases.</p>
        </li>
        <li>
          <p>
            <term>Target Catalog Structure</term> - Provides the requirements for structuring the
              final output from the intermediate representation generated throughout the previous
              section.</p>
        </li>
      </ul>
      <p>
        <term>Please note</term>: As referenced in the Purpose section <xref rid="purpose"/>
,
          this specification makes no hard requirements on the specifics of implementation. It is
          feasible for an implementation to use no intermediate representation, and to directly and
          iteratively build the output. As long as all processing and output requirements are satisfied, any
          approach is allowed. With that said, the specification has been laid out to aid in
          implementation by providing a clear organization as a sequence of distinct operations.</p>
    </section>
    <section id="intermediate">
      <head>The Intermediate and Implementation Guidance</head>
      <p>The overall intent of this document, in addition to defining strict requirements, is to
          provide rough guidelines on implementing an OSCAL Profile Resolution Tool. To this end,
          each phase of resolution will be framed as a series of transformations applied to an
          internal data structure that is persistent throughout the process. We call this &quot;the
          intermediate&quot;.</p>
      <p>Any examples that are labelled as &quot;Intermediate&quot; are psuedo-code, designed to represent
          how this data structure might look as we apply different operations to it. The example
          intermediates are often not valid OSCAL, and are not to be taken as guidance, but rather a
          useful visualization tool for implementers.</p>
      <p>The authors believe that applying the steps of resolution in order against this
          intermediate representation is the simplest way to achieve full compliance with the
          specification. However, there is no requirement to implement Profile Resolution in this
          way. Requirements are given as rules on the output of resolution, and as such,
          tools can operate any way they would like internally.</p>
    </section>
  </section>
  <section id="phases">
    <head>Phases of Profile Processing</head>
    <p>An OSCAL Profile has three major sections, each which correspond to a phase of profile
      resolution. In order to complete the profile resolution process, each section must be fully
      parsed and a Catalog output created.</p>
    <p>It is strongly RECOMMENDED that implementations execute the following steps in the order that
      they are provided here. While it is possible to achieve compliance with a non-standard
      approach, the iterative nature of profile resolution lends itself to linear processing.</p>
    <p>The three steps are <term>import</term>;      <term>merge</term>; and <term>modify</term>. In
      brief:</p>
    <ul>
      <li>
        <p>
          <term>import</term> - identifies one or more control sources (catalogs or profiles) and
          defines the controls within them to be included in the result catalog. If nothing is
          imported, no resulting catalog is produced. Invoked by <src>import</src> directives in
          source profiles;</p>
      </li>
      <li>
        <p>
          <term>merge</term> - designates the rules for how controls will be organized (ordered
          and/or grouped) and merged (addressing conflicts or ambiguities) in the result catalog.
          Controlled by the <src>merge</src> directive in source profiles; if none are
          included, default merge rules are used;</p>
      </li>
      <li>
        <p>
          <term>modify</term> - indicates how controls and their parameters in the underlying
          catalog are to be altered, edited, amended or added in the final result catalog. Logical
          evaluation and parameter constraints provide advanced processing. Controlled by
          the <src>modify</src> directive in source profiles. If a <src>modify</src> directive is
          not provided, no changes will be made to the controls that have been imported/merged. </p>
      </li>
    </ul>
    <p>As described in the previous section, when resolved, an OSCAL profile takes the form of an
      OSCAL catalog. The phases described below will produce outputs conforming to the catalog model.</p>
  </section>
  <section id="import">
    <head>Import Phase</head>
    <p>A profile begins by listing a set of Catalogs and/or Profiles to be imported. Each is
        represented by a resolvable resource URI and a directive specifying which controls to import
        from that resource. These resources may be available as static resources, or they may be
        produced dynamically on request; such as is the case when a profile is imported. Imports are
        given in sequence after the metadata:</p>
    <tagging whose="source_profile">
      <![CDATA[
profile:
  uuid: ~~~
  metadata: ~~~
  imports:
    - href: ${{ catalog URI }}
      include-controls: ${{ list of selected controls }}
    - href: ${{ profile URI }}
      include-controls: ${{ list of selected controls }} ]]></tagging>
    <p>In an import directive, the reference to the resource to be imported appears on an
      <src>href</src> child object. It takes either of two forms, external or internal:</p>
    <p>An external reference appears as an absolute or relative URL:</p>
    <tagging whose="source_profile">
      <![CDATA[
profile:
  uuid: ~~~
  metadata: ~~~
  imports:
    - href: >-
        https://github.com/usnistgov/oscal-content/tree
        /master/nist.gov/SP800-53/rev4/yaml/NIST_SP-800-53_rev4_catalog.yaml
      include-controls: ${{ list of selected controls }}
    - href: "../../NIST_SP-800-53_rev5_catalog.yaml"
      include-controls: ${{ list of selected controls }} ]]></tagging>



    <p>While an internal reference appears as below (see <xref rid="internalref"/>
): </p>
    <tagging whose="source_profile">
      <![CDATA[
profile:
  uuid: ~~~
  metadata: ~~~
  imports:
    - href: #80052rev4
      include-controls: ${{ list of selected controls }}
    - href: #80052rev5
      include-controls: ${{ list of selected controls }} ]]></tagging>
    <!--TODO: Add Internal example-->
    <p>All import directives will contain either <src>include-all: ~</src> or
      <src>include-controls</src>. These directives indicate which controls from the imported
        document are explicitly selected <xref rid="select-phase"/>
.</p>
    <p>The following section contains requirements for processing the <source>import</source> child of a source <source>profile</source>
    </p>
    <section id="importhrefs">
      <head>Import href Requirements</head>
      <section id="resolving-uris">
        <head>Import URI Resolution</head>
        <p>Tools MUST resolve URIs by following <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-5">Section 5 of
              RFC3986</a>, with the exception of URI Fragments (URIs that start with &quot;#&quot;). URI
            Fragments MUST instead be resolved as defined in <xref rid="internalref"/>
.</p>
      </section>
      <section id="aquiring-resource">
        <head>Import Resource Acquisition</head>
        <p>Tools MUST acquire resources at the resolved URI by following <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-5">Section 5 of
              RFC3986</a>, with the exception of URI Fragments (URIs that start with &quot;#&quot;). URI
            Fragments MUST instead be acquired as defined in <xref rid="internalref"/>
.</p>
        <p>For the purposes of resolving URIs using the above specifiction, the Base URI MUST be considered to be the absolute URI of the containing profile. </p>
        <p>In the case that acquiring a resource fails, the tool MUST cease processing and provide
            an error. In order to ensure profile resolution results in the same Catalog regardless
            of which tool resolves it, all imports must successfully resolve. While this may cause
            inconvenience if resources are frequently not available, it ensures
            interoperability.</p>
        <p> Note that receiving a cached version of an import, or resolving an import that is otherwise unavilable through some other (but automatic) means still satisfies the above requirement. This specification does not put requirements on the precise function of the import, as long as the correct document is retrieved.</p>
      </section>
      <section id="internalref">
        <head>Internal References</head>
        <p>URI Fragments in OSCAL represent internal references to other OSCAL objects in the same
            document. These references follow the pattern of &quot;#{{objectID}}&quot;. For example, the URI
            Fragment &quot;#param1&quot; is referencing the Parameter with unique ID &quot;param1&quot;.</p>
        <p>Tools MUST resolve and acquire URI Fragments by fetching the OSCAL object referenced.
            The referenced identifier MUST only be searched for within the scope of IDs for which the reference type allows.</p>
        <p>If the object fetched cannot be found or is not a valid OSCAL object, the tool MUST
            cease processing and provide an error.</p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  metadata: ~~~
  imports:
    - href: "#nist-sp800-53_catalog"
      include-controls: ${{ list of selected controls }}
    
    ~~~
    
  backmatter:
    resources:
      - uuid: "nist-sp800-53_catalog"
        description: "NIST SP 800-53 rev5 OSCAL format, on Github."
        rlinks:
          - rlink:
              href: >-
                https://github.com/usnistgov/oscal-content/tree
                /master/nist.gov/SP800-53/rev4/xml/NIST_SP-800-53_rev5_catalog.xml   ]]></tagging>
      </section>
      <section id="URI-circular">
        <head>Resolving Imports of Profiles</head>
        <p>If the resource acquired is an OSCAL Profile, the tool MUST apply this specification to
            resolve it, then continue processing having imported the resulting catalog.</p>
        <p>When a profile imports a profile, the subordinate profile SHOULD be resolved first into a Derived Catalog using this specification, before it is imported. This presents the possibility of circular imports, when a
            profile is directed to import itself either directly or indirectly.</p>
        <p>A <term>circular import</term> occurs when a profile imports an already imported profile, which was called at an earlier place in the import hierarchy. For example, if Profile A imports
            Profile B, and Profile B imports Profile A, the second import is circular. (An import at
            the top can only be circular if a profile tries to import itself.) If A imports B, B
            imports C and C imports A, C’s import is circular.</p>
        <p>Note that an import can only be circular within the context of processing a particular
            profile. In the last example, C’s import would not be circular if invoked in the context
            of resolving B by itself.</p>
        <p>If a processor encounters a <term>circular import</term> as described above
            (self-imports are inherently circular), the processor MUST cease processing and generate
            an error. </p>
        <mapping unit-test="profile-resolution-examples/home_profile.xml">
          <p>A profile identified as <code>home_profile.yaml</code> imports another one identified
              as <code>circular_profile.yaml</code>:
          </p>
          <tagging whose="source_profile">
            <![CDATA[
profile:
  id: "home_profile.yaml"
  metadata: ~~~
  imports:
    - href: "circular_profile.yaml"
      include-controls: ${{ list of selected controls }} ]]></tagging>
          <p>In turn this file invokes <code>home_profile.xml</code>:
          </p>
          <tagging whose="source_profile">
            <![CDATA[
profile:
  id: "circular_profile.yaml"
  metadata: ~~~
  imports:
    - href: "home_profile.yaml"
      include-controls: ${{ list of selected controls }} ]]></tagging>
          <p>Once detected, this circular import will result in an error and no further processing
              will take place.</p>
          <tagging whose="target_catalog">
            <![CDATA[
  # Import at href: "circular_profile.yaml" failed.
  # Reason: Error during profile import:
  # Import at href: "home_profile.yaml" failed.
  # Reason: Circular import ]]></tagging>
        </mapping>
      </section>
      <section id="URI-multiple">
        <head>Multiple imports</head>
        <p>Each import directive is processed to produce a set of controls. Note that this occurs
            even if the same catalog is imported multiple times: each distinct import collects
            controls into a separate <int>selection</int>:
        </p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  uuid: ~~~
  metadata: ~~~
  imports:
    - href: "#catalog"
      include-controls:
       - with-ids:
          - ac-1
          - ac-2
    - href: "#catalog"
      include-controls:
       - with-ids:
          - ac-3
          - ac-4 ]]></tagging>
        <tagging whose="inter_catalog">
          <![CDATA[
intermediate:
  metadata: ~~~
  selections:
    - id: ${{uuid of #catalog}}
      included-controls:
          - ac-1
          - ac-2
    - id: ${{uuid of #catalog}}
      included-controls:
          - ac-3
          - ac-4 ]]></tagging>
        <p>The control selections are combined and collapsed in the next phase of processing,
          <term>merge</term> (see XYZ) .</p>
        <p>Multiple imports may result in outputs with clashing controls (see XYZ). Typically
            this will be because a control has been selected twice (in selection or in the
            selections of underlying profiles), and no merge behavior has been indicated to resolve
            the clash.</p>
        <p>Typical cases of multiple imports of the same (underlying) resource will be when
            profile A imports another profile B, which calls catalog Z, and then profile A calls
            catalog Z again to acquire other controls not included in profile B, or in an original
            form unmodified by profile B.</p>
      </section>
      <section id="mapping">        <!-- TODO: Remove generic definition, Add below types:
      mapping:
        control
        group
        param
        role 
        part 
       -->
        <head>Mapping Controls</head>
        <p>The optional <source>mapping</source> child of a given <source>import</source> provides a simple ID remapping for
          objects included from that specific import. This provides the means for profile authors to
          proactively avoid clashing IDs of controls and other objects. </p>
        <p>The Mapping section consists of 5 optional subsections, each covering a particular type
          of object. Each subsection is a list of ID mappings to be applied for objects that are the
          parent object type.</p>
        <p>When encountering a given mapping instruction, processors:</p>
        <ul>
          <li>
            <p>MUST locate the included object in the intermediate whose distinctive ID matches the
              value of the <source>from</source> object and whose object type is the same as the name as the
              parent. If none is found, the processor SHOULD provide a warning, but MAY continue
              processing. In the case there are more than one included objects of the specified type
              with the same distinctive ID, behavior is unspecified, as this means the source
              catalog was malformed.</p>
          </li>
          <li>
            <p>MUST change the distinctive ID of that object to be equal to the value of the <source>to</source>
              object.</p>
          </li>
          <li>
            <p>MUST update all references to the old ID, allowing the new ID to be used in subsequent profile sections.</p>
          </li>
        </ul>
        <p>Since mapping is a self contained process inside each import, the rest of this
          specification will continue to reference IDs with the assumption that mapping has already
          been applied if it was present. Since mapping is most commonly used to avoid clashing IDs,
          processors should take care to not handle duplicate IDs until after mapping is
          complete.</p>
      </section>
    </section>
    <section id="select-phase">
      <head>Including Controls</head>
      <p>Each import contains directives on which parts of the imported Catalog are to be
          included. Throughout the rest of this document, we will refer to &quot;explicit&quot; vs &quot;implicit&quot;
          inclusion. Explicit Inclusion refers to anything that has been referenced directly by any
          of the below directives. Implicit Inclusion refers to objects that have been included due
          to other circumstances, but that have not been directly referenced by the inclusion directives. </p>
      <p>It is REQUIRED that implementations track which objects are explicitly included vs
          implicitly included as the intermediate is built out. This information is required to be
          used during the pruning process <xref rid="cleanup"/>
. </p>
      <section id="include-all">
        <head>include-all</head>
        <p>When an import provides the <src>include-all</src> directive, all controls in the
            referenced document (including nested controls <xref rid="import-nested"/>
) MUST be
            explicitly included:</p>
        <tagging whose="source_profile">include-all: ~ </tagging>
        <p>Under the <src>include-all</src> directive, all non-control, non-parameter, children of controls MUST
            be explicitly included.</p>
        <p>Under the <src>include-all</src> directive, all &quot;loose params&quot; <xref rid="import-param"/>
 MUST be implictly included.</p>
      </section>
      <section id="include-by-id">
        <head>include-controls plus with-id</head>
        <p>When an import provides the <src>include-controls</src> directive, with a
          <src>with-id</src> child, all controls in the referenced document whose
          <code>id</code> match one of the listed <code>id</code> values MUST be explicitly
            included:</p>
        <tagging whose="source_profile">
          <![CDATA[
include-controls:
  - with-ids:
    - id: ac-1
    - id: ac-2]]></tagging>
        <p>Using <source>with-id</source>, all non-control, non-parameter, children of included controls MUST also be explicitly
            included.</p>
      </section>
      <section id="include-by-match">
        <head>include-controls plus matching</head>
        <p>Controls may also be included using match patterns against their IDs. This is useful
            because related controls (either in a hierarchy, or together in a group) frequently have
            related IDs as well.</p>
        <p>When an import provides the <src>include-controls</src> directive, with a
          <src>matching</src> child, all controls in the referenced document whose
          <code>id</code> matches one of the listed <code>pattern</code> values (Glob matching)
            MUST be explicitly included:</p>
        <p>If a <code>matching</code> object is provided with no <code>pattern</code>, it MUST be
            treated as matching nothing.</p>
        <tagging whose="source_profile">
          <![CDATA[
include-controls:
  - matching:
    - pattern: "ac*" ]]></tagging>
        <p>Using <source>matching</source>, all non-control children of included controls MUST also be explicitly
            included.</p>
      </section>
      <section id="include-child-controls">
        <head>with-child-controls</head>
        <p>In OSCAL, controls may contain controls. For example, in SP 800-53 many controls are
            supplemented with control enhancements; in OSCAL these are represented as child controls
            within parent controls. So parent AC-2 (in a given catalog) has children AC-2(1) through
            AC-2(13), for example.</p>
        <p>Child controls can be included by the same mechanism as controls, i.e. by means of an
            ID call. Alternatively a match can frequently be applied (at least given most ID
            assignment schemes) to match controls and child controls together.</p>
        <p> A <src>with-child-controls: yes</src> directive on an <src>include-controls</src>
            indicates that <em>all descendant controls </em> of the explicitly included control MUST
            also be explicitly included. </p>
        <p> A <src>with-child-controls: no</src> directive on an <src>include-controls</src>
            indicates that ONLY the explicitly matching control is explicitly included, any
            descendants are not included. </p>
        <p> If no <src>with-child-controls</src> is provided, the processor MUST consider the
            directive as being equivalent to one having <src>with-child-controls:no</src>. 
        </p>
      </section>
      <section id="exclude-directive">
        <head>exclude-controls</head>
        <p>Exclusions work the same way as inclusions, except with the opposite effect - the
            indicated control(s) do not appear in the target catalog.</p>
        <p>Any control designated to be both included and excluded, MUST be excluded. This holds
            irrespective of the specificity of the selection for inclusion or exclusion. For
            example, if AC-1 is included by id <code>ac-1</code> and excluded by matching
          <code>ac.*</code>, it is excluded. Selection for exclusion prevails.</p>
        <p>
          <src>exclude-controls</src> will also have at least one <src>with-ids</src> and
          <src>matching</src> directive, the processor MUST follow the same rules as defined in
            the above sections for these directives, but exclude instead of include any
            controls.</p>
      </section>
      <section id="redundant-calls">
        <head>Redundant Inclusions</head>
        <p>
          <src>with-id</src> and <src>matching</src> may be combined in a single import. Their
            effect is cumulative; any control that is included by both <src>with-id</src> and
          <src>matching</src> from a given <src>include-controls</src> directive, or by matching
            more than one pattern, MUST be included only once (unless it is also marked for
            exclusion, see <xref rid="exclude-directive"/>
). This applies to both explicit and
            implicit inclusion.</p>
        <p>Note that this requirement only applies to controls included within the context of a
            single import. Controls with duplicate IDs included with a different <source>import</source> are not
            discarded.</p>
      </section>
      <section id="import-groups">
        <head>Handling Groups</head>
        <p>Catalogs are sometimes organized using the <src>groups</src> structure, which brings
            controls and other data into one logical grouping. </p>
        <p>In the Import Phase, the Processor MUST search all <src>groups</src> for controls when
            executing inclusion and exclusion directives. This includes nested groups.</p>
        <p>If a control inside a <src>group</src> is selected, the parent <src>group</src> and all
            of it&apos;s non-control, non-group children MUST be implicitly included. This applies
            recursively if the parent group has a parent group, until the top level group has been
            implicitly included in this way as well.</p>
        <p>If a parent group is to be implicitly included by the above requirement, but has
            already been implicitly included within the same import statement, the control MUST be
            placed into that group instead. </p>
      </section>
      <section id="import-nested">
        <head>Handling Nested Controls</head>
        <p>Controls are sometimes nested under other controls, with varying levels of dependencies
            between them. </p>
        <p>If a control inside a <src>control</src> is selected, the parent <src>control</src> and
            all of it&apos;s non-control children MUST be implicitly included. This applies recursively
            if the parent control has a parent control, until the top level control has been
            implicitly included in this way as well.</p>
      </section>
      <section id="import-param">
        <head>Handling Params</head>
        <p>Any <src>param</src> that is not directly under a control is referred to as a
          <q>loose</q> param. </p>
        <p>All loose params from both imported documents and the profile source MUST be included
            implicitly. Enterprising implementations may consider pruning unused params at this
            point <xref rid="cleanup"/>
, but care should be taken to not prune future needed
            params.</p>
      </section>
    </section>

    <section id="import-wrap-up">
      <head>Wrapping up the Import Phase</head>
      <p>At this point the processor should have an intermediate that contains: a set of explicitly
          included controls and all of their child informational (non-control, non-group) objects; a
          set of implicitly included controls and groups that were parents of the previous (zero to
          many); and a set of implicitly included &quot;loose params&quot; <xref rid="import-param"/>
 (zero to
          many).</p>
      <p>The general structure of explicitly included controls should match that of those controls
          in the imported catalogs (i.e. Nested controls remain nested, grouped controls remain
          grouped).</p>
    </section>
  </section>
  <section id="merge-phase">    <!-- TODO: Suggestion. Refactor merge into:
        merge:
          combine: 
            {{keep or use-first}}
              config
          structure: {{flat, as-is, or custom}}
            
            /////
              OR
            /////
            
        merge:
          combine: {{keep or use-first}}
          structure: {{flat, as-is, or custom}}
          
      The object is way overcomplicated at the moment. 
      
      TODO: Add the above as a Github Issue
      -->
    <head>Merge Phase</head>
    <p>Profiles may contain a <src>merge</src> section, where directives are given to instruct the
        processor how to combine the set of included objects collected during the Import Phase.
      <code>merge</code> has two parts: a &quot;combine&quot; directive, and a &quot;structuring&quot;
        directive.</p>
    <p>It is RECOMMENDED that tools apply the &quot;combine&quot; directive to the intermediate generated by
        the Import phase first, then apply the &quot;structuring&quot; directive.</p>
    <p>The following section contains requirements for processing the <source>merge</source> child of a source
        profile.</p>
    <section id="merge-combine">
      <head>The &quot;combine&quot; Directive</head>
      <p>
        <code>combine</code> is an optional child of <code>merge</code> that provides the rules
          for dealing with objects that have duplicate (or clashing) distinct IDs <xref rid="id"/>
.</p>
      <p>There are two valid combination methods provided by OSCAL, provided by the
        <src>method</src> child of <src>combine</src>: 
      </p>
      <ul>
        <li>
          <p>use-first: Use the first definition - the first control with a given ID is used;
              subsequent ones are discarded</p>
        </li>
        <li>
          <p>keep: Keep - controls with the same ID are kept, retaining the clash</p>
        </li>
        <li>
          <p>merge: Unspecified behaviour.</p>
        </li>
      </ul>
      <p>In order to apply the combination method, IDs of each control explicitly included are
          compared against one another. As IDs are unique across entire OSCAL documents, different
          imports or any groupings have no bearing on collision. Processing requirements for each
          method are described below.</p>
      <section id="no-merge-explicit">
        <head>No Combine Directive</head>
        <p>If no <src>merge</src> directive is given in the profile, or if a <src>merge</src> is
            given without a <src>combine</src>, merge conflicts MUST be treated as if <src>method:
              keep</src> was given. For example, a profile with no <src>merge</src> directive:</p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-all: ~ ]]></tagging>
        <p>is the same as</p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-all: ~
  merge:
    combine:
      method: keep
      flat: ~ ]]></tagging>
      </section>
      <section id="no-merge-combination-rule">
        <head>
          <q>method:keep</q>
        </head>
        <p>When a merge is indicated by <src>method:keep</src>, or not given, the <q>keep</q>
            combination rule is used. Any objects with the same distinctive ID <xref rid="id"/>
 MUST
            NOT not merged. (They are kept.)</p>
        <tagging whose="source_profile">
          <![CDATA[
  merge:
    combine:
      method: keep ]]></tagging>
        <p>Under this directive, colliding controls will result in invalid results, as they will
            both appear in the results with the same ID. Accordingly, this setting may be useful in
            ensuring integrity of references to controls as given in the profile: if any included
            control is called only once, clashing controls will not be produced and validation will
            succeed.</p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2 
  merge:
    combine:
      method: keep]]></tagging>
        <p>In the intermediate (showing control selections):</p>
        <tagging whose="inter_catalog">
          <![CDATA[
intermediate:
  inclusions:
    - explicitly-included-controls:
          - ac-1
          - ac-2
          - ac-1
          - ac-2 ]]></tagging>
        <p>In this case, downstream errors should be expected: the two <code>ac-1</code> controls
            clash with each other, as do the two <code>ac-2</code> controls.</p>
        <p>Processors SHOULD provide a warning under this directive when duplicate controls are
            detected. The processor MAY throw an error and cease processing (short-circuiting a
            certain future error). </p>
      </section>
      <section id="use-first-combination-rule">
        <head>
          <q>method:use-first</q>
        </head>
        <tagging whose="source_profile">
          <![CDATA[
  merge:
    combine:
      method: use-first ]]></tagging>
        <p>When the <q>use-first</q> combination rule is applied, and objects that share a
            distinctive ID are found, the first object encountered MUST be kept, the rest MUST be
            discarded. <q>First</q> MUST be determined by a top-down, depth-first traversal of the
            source profile&apos;s import hierarchy. </p>
        <mapping>
          <tagging whose="source_profile">
            <![CDATA[
profile:
  imports:
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-3
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2 
  merge:
    combine:
      method: use-first]]></tagging>
          <p>In the intermediate(showing control selections):</p>
          <tagging whose="inter_catalog">
            <![CDATA[
intermediate:
  inclusions:
    - explicitly-included-controls:
          - ac-1 (From catalog1)
          - ac-3
          - ac-2 ]]></tagging>
        </mapping>
      </section>
      <section id="merge-combination-rule">
        <head>
          <source>method:merge</source>
        </head>
        <p>Unspecified behaviour.</p>
      </section>
    </section>
    <section id="structuring-result">
      <head>The &quot;structuring&quot; Directive</head>
      <p>This section describes how a profile may dictate the body of the target
        <tgt>catalog</tgt>, apart from its <tgt>metadata</tgt> or <tgt>back-matter</tgt>.
          Optionally, one of three &quot;structuring&quot; directives can be included as a child of <source>merge</source>:
        <src>flat</src>,        <src>as-is</src> and <src>custom</src>. When one of these appears with
          a value of &quot;true&quot;, it is the selected structuring directive. If more than one appears with
          a value of &quot;true&quot;, processors MUST generate an error and cease processing. Processing
          requirements for each are given below:</p>
      <section id="structure-none">
        <head>No Structuring Directive</head>
        <p>If no <src>merge</src> directive is given in the profile, or if a <src>merge</src> is
            given without a structuring directive, structuring the output MUST be treated as if the
            structuring directive <src>flat</src> was given. For example, a profile with no
          <src>merge</src> directive:</p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-all: ~ ]]></tagging>
        <p>is the same as</p>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-all: ~
  merge:
    combine:
      method: keep 
      flat: ~ ]]></tagging>
      </section>
      <section id="merge-flat">        <!-- TODO: Suggestion, see below. structure:flat
          
          TODO: Submit github issue for adding flat child
          TODO: Submit github issue for changing as is and flat to empty rather tham boolean
          
          -->
        <head>&quot;flat&quot;</head>
        <p>Profiles with the &quot;flat&quot; merge directive are resolved as unstructured catalogs, with no
            groupings of controls.</p>
        <p>Unstructured catalog output MUST be produced by adhering to the following requirements: </p>
        <ul>
          <li>
            <p>All explicitly selected controls are output to the target as a flat list directly
                under &quot;catalog&quot;.</p>
          </li>
          <li>
            <p>Any implicitly included control parents are flattened (all controls will be on the
                same level).</p>
          </li>
          <li>
            <p>Any implicitly included group parents are flattened (all groups will be on the same
                level).</p>
          </li>
          <li>
            <p>Any included (explicit or implicit) &quot;loose params&quot; are output to the target.</p>
          </li>
        </ul>
        <p>Note that it is likely for implicitly included control and group parents to be pruned
            later <xref rid="cleanup"/>
. An example of flat structuring is provided below</p>
        <tagging whose="source_catalog">
          <![CDATA[
catalog:
  groups:
    - groupA
      - ac-1
      - ac-2
    - groupB
      - bc-1 ]]></tagging>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-controls:
        with-ids:
          - ac-1
          - ac-2
          - bc-1
  merge:
    combine:
      method: keep 
      flat: true ]]></tagging>
        <tagging whose="inter_catalog">
          <![CDATA[
intermediate:
  controls:
    - ac-1
    - ac-2
    - bc-1
  groups:
    - groupA
    - groupB ]]></tagging>
      </section>
      <section id="merge-as-is">
        <head>
          <q>as-is</q>
        </head>
        <p>An <src>as-is</src>directive is used to reproduce the structure of the source documents
            in the target catalog. </p>
        <p>Processors MUST handle the <src>as-is</src>directive by adhering to the following
            requirements: </p>
        <ul>
          <li>
            <p>All explicitly and implicitly included controls and groups are output to the
                target, keeping the structure of the groups and nested controls. Controls keep their
                location and structure from the source documents (which should be preserved in the
                intermediate).</p>
          </li>
          <li>
            <p>Any included (explicit or implicit) &quot;loose params&quot; are output to the target.</p>
          </li>
        </ul>
        <p>Example:</p>
        <tagging whose="source_catalog">
          <![CDATA[
catalog:
  groups:
    - groupA
      - ac-1
      - ac-2
    - groupB
      - bc-1 ]]></tagging>
        <tagging whose="source_profile">
          <![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-controls:
        with-ids:
          - ac-1
          - ac-2
          - bc-1
  merge:
    combine:
      method: keep 
      as-is: true ]]></tagging>
        <tagging whose="inter_catalog">
          <![CDATA[
intermediate:
  controls:
    - ac-1
    - ac-2
    - bc-1
  groups:
    - groupA
    - groupB ]]></tagging>
      </section>
      <section id="merge-custom">        <!-- TODO: Section nesting may be too deep here. -->
        <head>
          <q>custom</q>
        </head>
        <p>The <src>custom</src> directive provides the target catalog with a custom
            structure. A one-to-one mapping of the desired structure of the target catalog is
            defined alongside control matching instructions, resulting in a strictly controlled
            output catalog.</p>
        <section id="custom-groups">
          <head>Creating Custom Groups</head>
          <p>A <src>group</src> object given under <source>custom</source> MUST result in a <tgt>group</tgt> with
              the exact same content (excluding <source>insert-controls</source>) in the target catalog. </p>
          <p>If the ID of the group matches the ID of a group that has been included during the
              import phase, all contents inside the group, including <src>title</src>,
            <src>param</src>,            <src>prop</src> and <src>part</src> objects MUST be copied into
              the target, appearing in the same order as in the source.</p>
          <p>Note that groups defined in <source>custom</source> may vary from fully featured to minimally
              instantiated. This includes arbitrary nesting of such groups inside of one another. No
              groups other than those explicitly declared should appear in the output catalog. </p>
        </section>
        <section id="custom-selection">
          <head>Inserting Controls</head>
          <p>The <source>insert-controls</source> directive may appear anywhere under <source>custom</source>, whether as a
              direct child or inside any of the defined groups. Inside insert-controls,
            <source>include-controls</source> and <source>include-all</source> from the Import Phase <xref rid="import"/>
 are
              used with the same basic behavior to configure which controls are selected and
              inserted at the current location.</p>
          <p>In order to provide clarity, controls that match the various conditions of these
              inclusion directives inside the <source>custom</source> object will be referred to as &quot;selected&quot;
              instead of &quot;included&quot;. There is no concept of &quot;explicit&quot; vs &quot;implicit&quot; when using
              these directives in <source>custom</source>. Only directly selected controls will appear in the
              target catalog.</p>
          <p>A <source>insert-controls</source> with an <source>include-controls</source> child results in the following
              behavior: </p>
          <ul>
            <li>
              <p>
                <src>with-id</src> results in selecting and inserting, at that point inside the
                  new grouping, the explicitly included controls with the <src>id</src> given by
                <src>with-id</src>. They should be given in the same order as they appear in the
                  control selection(s).</p>
            </li>
            <li>
              <p>A <src>matching</src> directive results in selecting and inserting, at that point
                  inside the new grouping, all explicitly included controls whose <src>id</src>
                  match, as a Glob expression, the pattern given in the <src>pattern</src>. They are
                  given in the same order as they appear in the input control selection(s).</p>
            </li>
          </ul>
          <p>An <source>insert-controls</source> with an <source>include-all</source> child results in all explicitly included
              controls being selected and inserted. They are given in the same order as they appear
              in the input control selection(s).</p>
          <p>
            <source>insert-controls</source> can also indicate the order that the selected controls are to be
              emitted in the result catalog using an <src>order</src> child. Three values MUST be
              supported and handled as specified below:</p>
          <ul>
            <li>
              <p>
                <code>ascending</code> will sort all selected controls into ascending
                  alphanumeric order by their ID.</p>
            </li>
            <li>
              <p>
                <code>descending</code> will sort all selected controls into descending
                  alphanumeric order by their ID.</p>
            </li>
            <li>
              <p>
                <code>keep</code> indicates that controls should be inserted in the order of
                  their appearance, using a depth-first traversal of the source profile&apos;s
                  imports.</p>
            </li>
          </ul>
          <p>In the case that a control selection matches none of the included controls, it MUST
              be ignored; a warning SHOULD be provided. If a control that was included by the Import
              Phase is never selected, no error occurs, that control simply does not appear in the
              output catalog.</p>
        </section>
      </section>
    </section>
    <section id="merge-wrapup">
      <head>Wrapping up the Merge Phase</head>
      <p>After the merge phase, the intermediate should now closely resemble the content and
          structure of the final output catalog. Controls and groups have been included, remapped,
          de-duplicated, then placed into their final location within the output&apos;s structure. If
          using the <source>custom</source> structuring directive, tools MAY discard unused (unreferenced and unselected) controls and groups. If
          using &quot;flat&quot; or &quot;as-is&quot;, there is still an opportunity for implicitly included controls or
          groups to become referenced; and therefore, not eligible for pruning <xref rid="cleanup"/>
. </p>
      <p>Regardless of any merge directives, there also likely remains implicitly selected &quot;loose
          params&quot; that have been propagated forward; these too must be persisted.</p>
    </section>
  </section>
  <section id="modify-phase">
    <head>Modify Phase</head>
    <p>There are two ways profiles may further modify the results of profile resolution: setting
        parameters, and altering controls. These activities are defined as two child objects inside
        the third step of profile resolution, the Modify Phase. </p>
    <p>The following section contains requirements for processing the <source>modify</source> child of a source
        profile.</p>
    <section id="param-setting">
      <head>Setting Parameters</head>
      <p>Modification of parameter settings is indicated using the <src>set-parameter</src> object
          under <source>modify</source>. For this section, a given <source>set-parameter</source> object will be referred to as
          the <source>source</source>.
      </p>
      <p>Profile Resolution Tools MUST adhere to the following requirements for processing
          &quot;set-parameter&quot;:</p>
      <ul>
        <li>
          <p>First, the list of included params (among &quot;loose params&quot; and remaining included
              controls and groups) is searched for a param who has a &quot;id&quot; equal to this object&apos;s
              &quot;param-id&quot;. This is the &quot;target&quot;. If no such parameter is found, a warning SHOULD be
              issued, but processing MUST continue.</p>
        </li>
        <li>
          <p>When encountering the following objects in the source: class, depends-on, label,
              usage, values, select; overwrites the object of the same name in the target. If no
              such object exists in the target, it is created. </p>
        </li>
        <li>
          <p>When encountering the following objects in the source: props, links, constraints,
              guidelines; adds the contents of the source object to the contents of the target
              object of the same name. If no such object exists in the target, it is created. For
              each individual child object of &quot;props&quot; and &quot;links&quot; in the source, if an individual
              child inside the target object has the same distinctive ID, it is instead overwritten
              by the source object <xref rid="id"/>
          </p>
        </li>
        <li>
          <p>If more than one <src>set-parameter</src> directive is given for the same parameter,
              all are applied, in the sequence given in the profile.</p>
        </li>
      </ul>
    </section>
    <section id="control-altering">
      <head>Altering controls</head>
      <p>A control can be altered by an <src>alter</src> object inside &quot;modify&quot;. The
        <src>control-id</src> child object under the <src>alter</src> indicates the control to which the
          alteration is applied.</p>
      <section id="add-directive">
        <head>Adding contents to controls</head>
        <p>Contents may be added to controls using an add directive inside an alter directive.
            There are two forms of alteration: with implicit and explicit bindings.</p>
        <section id="add-to-control">
          <head>Implicit binding</head>
          <p>An <src>add</src> directive with no <src>by-id</src> is taken to apply to the
              control as a whole. Its <src>position</src> may be either of two values:
            <code>starting</code> and <code>ending</code>.
          </p>
          <p>The contents of the add directive are then added to the control contents in the
              target, either after its <tgt>title</tgt> when <src>position</src> is
            <code>starting</code>, or at the end if its position is <code>ending</code>, or not
              given.</p>
          <p>However, control contents in catalogs must appear in the order <code>title, param,
                prop, link, part, control</code>. Subsequent to adding new objects, the control
              contents are sorted to appear in the required order. As a consequence, a new
            <tgt>prop</tgt> appears after any <src>prop</src> already in the control, when
            <src>position</src> is <code>ending</code>, or not given, or before any
            <src>prop</src> in the control when <src>position</src> is
            <code>starting</code>.
          </p>
          <p>When add has no <src>ref-id</src> (has an implicit binding), the <src>position</src>
              values <code>before</code> and <code>after</code> are treated like
            <code>starting</code> and <code>ending</code>, respectively. <revisit>The schema
                permits these values.</revisit>
          </p>
          <mapping>
            <p>An addition operating on a control with implicit binding and position
              <code>starting</code>
            </p>
            <tagging whose="source_catalog">
              <![CDATA[ 
control:
  id: a1
  title: Basic precautions
  props:
    - name: status
      value: ready ]]></tagging>
            <tagging whose="source_profile">
              <![CDATA[ 
alter:
  control-id: a1
  add:
    position: starting
    props:
      - name: basis
        value: enumerated
    parts:
      - name: caution
        prose: \\n\\nPending scheduled testing. ]]></tagging>
            <tagging whose="target_catalog">
              <![CDATA[ 
control:
  id: a1
  title: Basic precautions
  props:
    - name: basis
      value: enumerated
    - name: status
      value: ready
  parts:
    - name: caution
      prose: \\n\\nPending scheduled testing. ]]></tagging>
            <p>Position is <code>starting</code> but the new <tgt>part</tgt> is added after the
                existing <tgt>prop</tgt>, because <tgt>prop</tgt> objects must always occur
                first.</p>
          </mapping>
          <mapping>
            <p>An addition operating on a control with implicit binding and position
              <code>ending</code>
            </p>
            <tagging whose="source_catalog">
              <![CDATA[ 
control:
  id: a1
  title: Basic precautions
  props:
    - name: status
      value: ready ]]></tagging>
            <tagging whose="source_profile">
              <![CDATA[ 
alter:
  control-id: a1
  add:
    position: starting
    props:
      - name: basis
        value: enumerated
    parts:
      - name: caution
        prose: \\n\\nPending scheduled testing. ]]></tagging>
            <tagging whose="target_catalog">
              <![CDATA[ 
control:
  id: a1
  title: Basic precautions
  props:
    - name: status
      value: ready
    - name: basis
      value: enumerated
  parts:
    - name: caution
      prose: \\n\\nPending scheduled testing. ]]></tagging>
            <p>The <src>position</src> is <code>ending</code> so the new <tgt>prop</tgt> appears
                after the existing <tgt>prop</tgt>.
            </p>
          </mapping>
        </section>
        <section id="add-to-element">
          <head>Explicit binding</head>
          <p>An explicit binding on an addition permits inserting new contents anywhere in a
              control, not only at the top level. It is given by a <src>ref-id</src> on the
            <src>add</src> directive. The value of the <src>ref-id</src> must correspond to the
              value of an <src>id</src> on an object inside the control, and not the control
              itself. If <src>ref-id</src> does not correspond to such a value, the <src>add</src>
              directive is inoperative. A warning MAY be issued in such a case.</p>
          <p>The object with <src>id</src> equal to the <src>ref-id</src> is considered the
            <term>target</term> of the addition.</p>
          <p>Additionally, with an explicit binding given by a <src>ref-id</src>,
            <src>position</src> may have any of the values <code>starting</code>,
            <code>ending</code>,            <code>before</code> and <code>after</code>.
          </p>
          <p>When <src>position</src> is <code>starting</code> or <code>ending</code>, the new
              contents are added at the beginning or ending of the target object, inside that
              object, as are additions into controls (using implicit bindings).</p>
          <p>Additionally, a <src>position</src> given as <code>before</code> indicates the
              addition should be made directly before the target object, while <code>after</code>
              indicates the addition should appear directly after the target object.</p>          <!-- <p><revisit>Unlike additions with implicit bindings, an explicit binding does not
                provide for sorting of newly added objects to ensure correct ordering.
                Consequently, profile authors must take care that additions they make into control
                contents using explicit bindings will produce results valid to the catalog
                schema.</revisit></p> -->
          <mapping>
            <p>An addition operating on a control with explicit binding and position
              <code>after</code>
            </p>
            <tagging whose="source_catalog">
                YAML Example
                                                                                                                                                          <!--TODO &lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="status" value="ready"/> &lt;part id="a1.b" name="recommendations"> &lt;part id="a1.b1">&lt;p>Collect recycling for
                pickup.&lt;/p>&lt;/part> &lt;part id="a1.b2">&lt;p>Sweep surfaces free of
                dust.&lt;/p>&lt;/part> &lt;/part> &lt;/control>--></tagging>
            <p>Note that the <src>add</src> directive identifies the object with <src>id</src>
              <code>a1.b1</code> as its target.</p>
            <tagging whose="source_profile">YAML Example
                
                                                                                                                                                          <!--TODO &lt;alter control-id="a1"> &lt;add position="after" ref-id="a1.b1"> &lt;prop name="basis" value="allocated"/> &lt;part name="caution">&lt;p>Unavailable on weekends.&lt;/p>&lt;/part> &lt;/add>
                &lt;/alter>
                -->            </tagging>
            <tagging whose="target_catalog">
                YAML Example
                
                                                                                                                                                          <!-- TODO &lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="status" value="ready"/> &lt;part id="a1.b" name="recommendations"> &lt;part id="a1.b1">&lt;p>Collect recycling for
                pickup.&lt;/p>&lt;/part> &lt;prop name="basis" value="allocated"/> &lt;part name="caution">&lt;p>Unavailable on weekends.&lt;/p>&lt;/part> &lt;part id="a1.b2">&lt;p>Sweep surfaces free of dust.&lt;/p>&lt;/part> &lt;/part>
                &lt;/control> --></tagging>
            <p>The <src>position</src> is <code>after</code> so both objects inside
              <src>add</src> are added after (not inside) the target object. Since the target
                object is inside another <tgt>part</tgt> in the control, the new additions appear
                there as well.</p>
            <p>Note that the result in this case will be schema-invalid since a <tgt>prop</tgt>
                may not occur directly following a <tgt>part</tgt>. A better result can be obtained
                (a better target may be defined) by using two <src>add</src> directives, to insert
                the new <tgt>prop</tgt> separately before any <tgt>part</tgt> objects in the
                target.</p>
          </mapping>
        </section>
        <section>
          <head>Usage of <src>add</src> directives modifying controls inside controls</head>
          <p>OSCAL supports control extensions inside controls in the form of <src>control</src>
              objects inside <src>control</src> objects. Because the semantics of the
            <src>add</src> directive target any (object) contents of controls, they can be used
              to target these control extensions for modification as well as other contents.</p>
          <p>Because such a control can already be modified using implicit bindings, it is
              recommended that they not be targeted with explicit bindings. Using an implicit
              binding supports more robust alteration since contents in the target can be ordered
              properly by the resolution processor. <revisit>XXX can we guarantee valid results here
                and do we have to specify a sort/order?</revisit> However, it is not an error to
              target control objects in this way, manipulating them in the same way as other
              targets may be manipulated.</p>
        </section>
      </section>
      <section id="remove-directive">
        <head>Removing contents from controls</head>
        <p>Contents inside controls can be removed from them in catalog targets. In combination
            with adding new contents, this feature can be used to edit controls as well as amend
            them.</p>
        <p>A <src>remove</src> directive inside an <src>alter</src> directive identifies an
            object or set of objects inside a control to be removed. It does this using any of
            five child objects. These are <em>additive</em>; that is, if more than one is given, all must
            match:</p>
        <ul>
          <li>
            <p>
              <src>by-id</src>, like <src>add:by-id</src>, matches an object by its
              <src>id</src> value.</p>
            <p>Because <src>id</src> values are unique, the remove directive will remove only a
                single object. Ordinarily this would not combined with other identifiers for
                removal.</p>
          </li>
          <li>
            <p>
              <src>name-ref</src> keys to the <src>name</src> child object on any object inside
                the control.</p>
            <p>Any object inside the control with the assigned <src>name</src>, is removed
                (typically providing there is also a match on <src>ns</src>).
            </p>
          </li>
          <li>
            <p>
              <src>ns-ref</src> keys to the <src>ns</src> child object on any object inside the
                control.</p>
            <p>Any object inside the control with the assigned <src>name</src>, is removed
                (typically providing there is also a match on <src>name</src>).
            </p>
          </li>
          <li>
            <p>
              <src>class-ref</src> keys to the <src>class</src> child object on any object inside
                the control. All objects with matching <src>class</src> are removed.</p>
          </li>
          <li>
            <p>
              <src>item-name</src> keys to the object or property name; for example,
              <code>remove: item-name: prop</code> has the effect of removing all
              <src>prop</src> objects from inside the control. </p>            <!-- <revisit>(NB: explain how this
                  maps into JSON when items are grouped)</revisit> -->
          </li>
        </ul>
        <p>Unlike an <src>add</src> directive, a <src>remove</src> may not be bound implicitly to
            the control; its binding, to contents inside the control, must be explicit.</p>
        <p>To remove an control, simply avoid selecting it into the profile, or exclude it
            specifically using <src>import/exclude-controls</src>.
        </p>
        <p>As with <src>add</src>, a remove that targets any object outside the control, is
            inoperative. Similarly, a remove directive that indicates that all <tgt>prop</tgt>
            objects should be removed from the target catalog, applies only to <src>prop</src>
        </p>
      </section>
    </section>
  </section>
  <section id="finalphase">
    <head>Final Operations</head>
    <section id="target-back-matter">
      <head>Backmatter Resolution</head>
      <p>
        <tgt>back-matter</tgt> in the result is produced by combining all objects within
        <src>back-matter</src> in all source catalogs, with the <src>back-matter</src> in the
          input profile. The merge method and merge structuring directives are ignored. The
          following requirements MUST be adhered to by the processor: </p>
      <ul>
        <li>
          <p>Each import&apos;s backmatter is processed in order it was provided in the source profile,
              then the source profile&apos;s backmatter is processed.</p>
        </li>
        <li>
          <p>Each <src>resource</src> is added to the target in the order given inside the
              import.</p>
        </li>
        <li>
          <p>If a <src>resource</src> has the same <src>uuid</src> as a resource that has already
              been added, the previous resource is removed, and the more recent one added.</p>
        </li>
        <li>
          <p>A resource with a child prop of name:keep and value:always can only be replaced
              following the above rule by a duplicate that also has the keep always prop.</p>
        </li>
      </ul>
      <p>Tools MAY check for pruning conditions <xref rid="cleanup"/>
 as resources are added as
          long as the final result is the same as if the pruning had taken place at the end of all
          resource addition.</p>
      <p>Placing the keep always prop on a resource in a catalog has the effect of ensuring it
          will always appear in the output produced by any profile importing that catalog, even if
          nothing links to the resource. This version of the resource will also be the one copied,
          unless a later-imported catalog or importing profile offers its own version marked to keep
          always.</p>
    </section>
    <section id="target-metadata">      <!-- TODO: Add a section here that defines carrying over metadata:roles and parties if they have the prop:keep -->
      <head>Metadata Resolution</head>
      <p>The following requirements MUST be followed with regards to the Metadata section of the
          output Catalog:</p>
      <ul>
        <li>
          <p>The output catalog MUST have a unique top-level UUID (metadata:uuid). This UUID may
              be generated as seen fit by the tool, as long as it is reasonable to assume it is
              globally unique. It is RECOMMENDED that tools use a combination of meaningful text and
              a uniquely generated value (Ex.
            <code>{{sourceprofilename}}-RESOLVED-{{GUIDv5}}</code>).
          </p>
        </li>
        <li>
          <p>The value of metadata:version in the target MUST be set with a string that identifies
              the version of this document. This SHOULD be used to track updates to this specific output document. </p>
        </li>
        <li>
          <p>The value of metadata:oscal-version in the target MUST be set with a string that
              identifies the version of OSCAL used by this tool to resolve the profile (ex. 1.0.0).
              This value MUST be determined by compiling the oscal-versions from each imported
              document and the source profile, and taking the most recent minor version. If this
              version is more recent than what the resolution tool is using, then the value of the
              output oscal-version MUST be the version that the tool used internally. If any of the
              above OSCAL versions (imported document versions, source profile version, tool
              version) are of a different major version (the first digit differs), the tool SHOULD
              provide an error and cease processing. </p>
        </li>
        <li>
          <p>The value of metadata:last-modified in the target MUST be set with a valid timestamp
              representing the time the profile resolution completed. </p>
        </li>
        <li>
          <p>The value of metadata:source-profile in the target SHOULD be set with a valid URI
              that points to the profile that resulted in this catalog. If there are privacy or
              security concerns, the value MAY be set to anything, in which case the simple
              existence of the source-profile property indicates that this is a resolved
              profile.</p>
        </li>
        <li>
          <p>The value of metadata:resolution-tool in the target SHOULD be set with a string that
              represents the tool that was used to resolve this Catalog. </p>
        </li>
      </ul>
      <p>Beyond these requirements, tools are free to use any and all of the objects inside
          metadata to provide additional information downstream.</p>
      <p>Because of options in producing metadata and especially the requirement for a timestamp,
          developers and users should note that two different resolutions of the same profile will
          not, ordinarily, be identical inside <tgt>metadata</tgt>.
      </p>
    </section>
    <section id="cleanup">
      <head>Pruning and Ordering</head>
      <p>The processor SHOULD prune the result catalog to remove unused values. A given object is
          considered unused if it meets ALL of the following criteria:</p>
      <ul>
        <li>
          <p>The object does not have a child prop with name:keep and value:always</p>
        </li>
        <li>
          <p>The object is not explicitly included <xref rid="select-phase"/>
.</p>
        </li>
        <li>
          <p>There are no references to the object anywhere in the final result catalog, except in
              other objects that also meet all other pruning criteria. A reference to a given object
              exists if &quot;#{distinctiveID}&quot; appears anywhere, where {distinctiveID} is the
              distinctive ID of the object <xref rid="id"/>
. </p>
        </li>
      </ul>
      <p>Implementers should note that pruning need not take place after all other steps. As long
          as all above criteria are respected, pruning can happen at any time, and doing so is a
          likely performance and memory overhead improvement. </p>
      <p>Tools MUST reorder the output catalog into canonical order <xref rid="order"/>
, except where this specification provides different ordering requirements.</p>
    </section>
  </section>
  <section id="target">
    <head>Target Catalog Requirements</head>
    <p>The following requirements are largely derived from requirements already present in this
      specification, but are repeated here for additional clarity.</p>
    <ul>
      <li>
        <p>The output of a profile resolution MUST take the form of a catalog. Catalog results (the
          output of a conformant profile resolution) MUST be valid to the OSCAL catalog schema.</p>
      </li>
      <li>
        <p>The output of a profile resolution MUST be in the canonical order of an OSCAL catalog as
          defined by the OSCAL Catalog Metaschema: <code>(metadata, param*, control*, group*,
            back-matter?)</code> where <code>group</code> has the model <code>(title?, prop*, part*,
            param*, control*, group*)</code>.
        </p>
      </li>
      <li>
        <p>The output of a profile resolution MUST obey the ID uniqueness rules of OSCAL. Any
          violations of this rule MUST result in an error.</p>
      </li>
      <li>
        <p>If <src>combine:as-is</src> is used, the structure of the target MUST reflect the
          structure(s) of the source catalog(s). </p>
      </li>
      <li>
        <p>If <src>merge:keep</src> is used (or there is no merge object), the order of the controls
          MUST be placed in import order, with controls within an import keeping the order given by
          the imported catalog. </p>
      </li>
      <li>
        <p>Unless it be for special purposes in a debugging or tracing mode, profile results SHOULD
          not create any groups or structures not described by the source profile. Depending on the
          merge directive, all groups will be given either by the catalog source(s)
            (          <src>merge:as-is</src>) or the profile (<src>merge:custom</src>), or there will be no
          groups at all (no merge directive).</p>
      </li>
    </ul>
  </section>
  <section id="other">
    <head>Items of Note</head>
    <section id="id">
      <head>Distinct ID of Objects</head>
      <p>Whenever this specification refers to <q>distinctiveness</q>, it MUST be interpreted as is
        defined in this section with regards to the object in question. </p>
      <p>control,param,group - distinctiveness is defined by the value of the <q>id</q> child
        object.</p>
      <p>resource - distinctiveness is defined by the value of the <q>uuid</q>
        <xref rid="target-back-matter"/>
.</p>
      <p>link - distinctiveness is defined by the union of the values of href, rel, and media-type.
        An empty value is considered to be unique. </p>
    </section>
    <section id="multiformat">      <!-- TODO: How likely is it for new format support to be added? Does this section need to be handle entirely by reference to make the spec static even if new formats are added? -->      <!-- TODO -->
      <head>Dealing with Multiple Formats</head>
      <p>Profile Resolution tools MUST be able to handle source profiles, imported catalogs, and
        imported profiles that are serialized in XML, JSON, or YAML. A different serialization
        format of any given input MUST NOT result in a differing output catalog. </p>
      <p>In order to help bootstrap this format management, the following resources are provided for
        implementers:</p>
      <ul>
        <li>
          <p>.
                                                                                                                                  <!-- TODO: Add links to OSCAL conversion libraries, format guidance pages, etc. --></p>
        </li>
      </ul>
      <p>The following sections provide additional requirements and guidance for each format.</p>
      <section id="xmlrequirements">
        <head>Requirements and Guidance for XML Output</head>
        <p>See <a href="https://pages.nist.gov/OSCAL/reference/latest/complete/xml-definitions/">the
            complete XML reference</a> for model requirements.</p>        <!-- TODO: Add Namespace -->        <!-- TODO: Consult XML Wizards on namespacing and other XML requirements -->
      </section>
      <section id="jsonrequirements">
        <head>Requirements and Guidance for JSON Output</head>
        <p>See the <a href="https://pages.nist.gov/OSCAL/reference/latest/complete/json-reference/">
            complete JSON reference</a> for model requirements.</p>
        <p>The JSON format, in general use, does not require the preservation of order of fields. As
          order matters in OSCAL, care should be taken to adhere to the canonical OSCAL order <xref rid="order"/>
 when outputting a catalog in JSON.</p>        <!-- TODO: Add Namespace (BaseURI) -->
      </section>
      <section id="yamlrequirements">
        <head>Requirements and Guidance for YAML Output</head>
        <p>YAML is considered a simple variation on the JSON format. Beyond cosmetic differences
          there are no differences in the information structure between these formats. Therefore,
          the <a href="https://pages.nist.gov/OSCAL/reference/latest/complete/json-reference/">
            complete JSON reference</a> provides model requirements.</p>
        <p>The YAML format, in general use, does not require the preservation of order of fields. As
          order matters in OSCAL, care should be taken to adhere to the canonical OSCAL order <xref rid="order"/>
 when outputting a catalog in YAML.</p>        <!-- TODO: Add Namespace (BaseURI) -->
      </section>
      <section id="order">
        <head>Order of objects in serialization</head>
        <p>In OSCAL, order of objects is always considered important, regardless of the
          serialization used. To facilitate this, OSCAL provides the concept of <term>canonical
            order</term>. This order is provided by the OSCAL Metaschema files for a given document
          type (see <a href="https://pages.nist.gov/OSCAL/concepts/layer/overview/#modeling-approach">an
            overview of Metaschema</a>.
        </p>
        <p>Except where required otherwise, the output catalog MUST be reordered into canonical
          order.</p>
      </section>
      <section id="comments-in-result">        <!-- Unsure what to do with this -->
        <head>Comments in result documents</head>
        <p>In an XML-based profile resolution, XML comments are one straightforward way for a
          processor to record events or conditions without affecting the output&apos;s nominal semantics.
          To support this, while two processors are obliged to return the same catalog XML for the
          same profile XML inputs, they are not required to match one another&apos;s comments, white
          space usage, attribute order, or processing instructions, only each other&apos;s objects,
          attributes and data content.</p>
        <p>One consequence of this is that processes intended to compare two profile resolutions may
          have to accommodate differences in comments, considering them as insignificant along with
          other differences in serialization.</p>
      </section>
    </section>    <!-- TODO: Suggest removal of this section, or move to seperate XML guidance doc
    <section id="valid-endpoints">
      <head>Formal validation of source and result</head>
      <p>In an XML context, document validation is available as a means of determining whether an
        arbitrary XML document entity conforms to structural and naming constraints such as must be
        assumed by processors respecting application semantics. These specifications assume that XML
        inputs for profile resolution will be <em>schema-valid</em> with respect to the OSCAL
          <term>profile</term> model, and hence will be tagged in the namespace
          <code>http://csrc.nist.gov/ns/oscal/1.0</code>.</p>
      <p>Similarly, the definition of the output format or results, is constrained by the OSCAL
          <term>catalog</term> model as defined by its schema.</p>
    </section>
-->
  </section>
</SPECIFICATION><!-- Here lies Merge
          <tagging whose="source_profile"><![CDATA[
  merge:
    combine:
      method: merge ]]></tagging>
<p>When the <term>merge</term> combination rule is applied, the processor will merge all
            representations of a given control, as distinguished by ID, into a single unified
            representation.</p>
<p>Processors MUST adhere to the following requirements for the <src>method:merge</src>
            directive for any given control:</p>
<ul>
<li>
<p>The first time a given control is encountered, the control and all objects inside
                it are kept.</p>
</li>
<li>
<p>For all subsequent encounters with the same control, any duplicate of a distinctive
                object <xref rid="id"/> is discarded, regardless of any difference in content.</p>
</li>
<li>
<p>"First" is determined in the same way as in <xref rid="use-first-combination-rule" />, by order of the source document.</p>
</li>
<li>
<p>At the conclusion of merging the control, it's contents are reordered according to
                  <term>canonical order</term>.</p>
</li>
</ul>
<p>Example:</p>
<tagging whose="source_catalog"><![CDATA[
  control:
    id: ac-1
    title: Control ac-1
    props:
      - name: label
        value: ac-1
      - name: status
        value: ready ]]></tagging>
<p>merging with</p>
<tagging whose="source_catalog"><![CDATA[
  control:
    id: ac-1
    title: Control ac-1
    props:
      - name: marking
        value: unclassed
      - name: label
        value: ac-1
      - name: status
        value: pending ]]></tagging>
<p>produces</p>
<tagging whose="target_catalog"><![CDATA[
  control:
    id: ac-1
    title: Control ac-1
    props:
      - name: marking
        value: unclassed
      - name: label
        value: ac-1
      - name: status
        value: ready ]]></tagging>
<p>Note that groups are not merged by this rule; for that purpose, <src>as-is</src> or
              <src>custom</src> should be used (in addition to the combine directive) <xref rid="structuring-result"/>.</p>
<p>Since the effect of this merge rule is to drop data silently (when it is considered to
            be redundant or duplicative), it should only be used on well-understood, well-controlled
            catalog and profile inputs, whose potential clashes or collisions are known in
            advance.</p>
</section>
<section id="combining-other">
<head>Combination Rules with Other Data</head>
<p>When profiles import from more than one resource (catalog or profile), not only is
            there a potential for clashing controls, but also groups, params, and backmatter.</p>
<p>If no structuring directives are given, the processor MUST merge all other data using
            the given merge directive, following the rules given for controls, but applied to each
            object.</p>
<p>With many imports or large catalogs, errors or data loss is likely. This is
            particularly likely in backmatter resources that are grouped under single distinctive
            keys, such as citations. The processor SHOULD provide warnings when non-control data is
            lost as part of a merging process.</p>

          -->