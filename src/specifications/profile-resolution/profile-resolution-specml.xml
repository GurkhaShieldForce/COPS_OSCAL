<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="specml.rnc" type="application/relax-ng-compact-syntax"?>
<!--<?xml-stylesheet type="text/xsl" href="specml-html-xslt1.xsl"?>-->
<?xml-stylesheet type="text/css" href="specml.css"?>
<?xml-model href="spec-checkup.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<SPECIFICATION xmlns="http://csrc.nist.gov/ns/oscal/specml">
  <head>OSCAL Profile Resolution</head>
  <section id="abstract">
    <head>Abstract</head>
    <p>This specification provides the requirements for transforming and rendering one or more
      OSCAL Profile and Catalog Documents as a new OSCAL Catalog Document. This process of applying
      profiles to a catalog to create a new catalog is called <term>Profile Resolution</term>. This
      specification is intended for software developers who are or who intend to develop an OSCAL
      Profile Resolver, or for OSCAL Profile authors who want a more in-depth understanding of
      profile resolution.</p>
  </section>
  <section id="intro">
    <head>Introduction</head>
    <section id="purpose">
      <head>Purpose</head>
      <p>This document provides the normative requirements for an OSCAL Profile Resolver. As
          <term>profile resolution</term> is a core component to the functional use of OSCAL it is
        important for requirements to be well-defined, such that OSCAL is fully interoperable
        between parties.</p>
      <p>No requirements are placed on implementation-level details, instead, requirements are laid
        out as what the output of resolution must look like given a certain input. By adhering to
        these requirements OSCAL producers, OSCAL consumers, and any other members of the OSCAL
        ecosystem can share OSCAL Profiles with the assurance that they will be understood in the
        same way as they were written to be. </p>
    </section>
    <section id="infocontext">
      <head>Informational Context</head>
      <section id="processing-context">
        <head>Scope</head>
        <p>A <term>profile</term> in OSCAL represents a selection and configuration of a set of
            <term>controls</term>. In the normal case, the set of controls available to a profile is
          provided by a catalog. For example, the three NIST SP 800-53 profiles representing the
          impact baselines HIGH, MODERATE and LOW: each of these calls on a catalog representing the
          families, controls and control enhancements described in SP 800-53/53A. In a data
          processing system, this dependency can be modeled in the form of separate documents or
          data instances - the (nominal) <q>catalog</q> and its <q>profile</q>, the latter being a
          selection, adaptation and organization of controls, as distinct from the catalog from
          which those controls are derived.</p>
        <p>However, profiles may also select controls from profiles, thus deriving them from
          underlying catalogs as modified by those profiles. This feature enables an organization
          that wishes to promulgate guidelines or requirements to do so by publishing a set of
          customizations to an existing catalog, rather than create a catalog from scratch. Profiles
          can also arrange combinations of controls from more than one catalog or profile origin,
          making it possible to use them to support the creation of hybrid catalogs. </p>
        <p>In the general case OSCAL must support sourcing more than one catalog at once, in order
          to aggregate and organize controls from disparate sources. For example, it should be
          routine for a profile to acquire its controls from an authoritative standard catalog, plus
          a local supplement. But multiple catalog inputs, especially when they are produced and
          sourced independently of one another, may not combine without issues. In order to provide
          sensible and transparent results even for incoherent inputs, this specification defines
          these processes such that legible and testable results are produced even when they are
          formally invalid to constraints governing the outputs. Such downstream processing errors
          including validation errors are expected to be detectable and remediable. This especially
          applies to situations where multiple catalogs are sourced, or where the same catalog is
          sourced more than once, directly or indirectly.</p>
        <p>In order to support these semantics – because whatever data set is sourced by a profile,
          it must <q>look like a catalog</q> – the results of resolving a single profile must be in
          the form of a single catalog. Two different OSCAL processors that promise profile
          resolution, must deliver, for the same input, the same catalog with regard to its
          contents: which controls are included; their ordering (insofar as the target format
          represents ordering); and the structure (groups) in which they are embedded. This
          specification is designed to make this possible, by defining outputs with sufficient rigor
          that <q>the same</q> is meaningful and testable in this context.</p>
      </section>
      <section id="why-a-catalog">
        <head>Why resolve a profile as a catalog</head>
        <p>A profile is a representation of a delta, a <q>here to there</q>. As such, a profile
          might be conceived of as a recipe or instruction set – a sequence of steps or procedures –
          whereby to create an OSCAL catalog (set of controls describing security requirements) from
          an OSCAL catalog (set of controls describing security requirements). The primary use case
          for this is when we need to make a new catalog to apply to a system or set of systems,
          starting from a canonical, received, mandated or standard catalog with a more general
          scope.</p>
        <p>This is because although catalogs - for example, the controls described in NIST SP 800-53
          - are published, available for use, and even standardized, they can never be used exactly
          in the form in which they are acquired. They must be taken from the packaging and placed
          into operational context before they mean anything. This typically requires that a few
          operations over <q>raw catalogs</q> be supported by a profiling mechanism. We must be able
          to select controls; we must be able to arrange them in order (or not); and we must be able
          to qualify or condition them by setting parameters defined for them and making adjustments
          to them. </p>
        <p>By representing the steps by which a base catalog can be sliced, sifted, amended and
          edited, into a (nominally) finished or ready set of control requirements, a profile makes
          it easier to codify and preserve even very incidental or temporary local revisions of a
          control catalog. Once expressed as a profile in OSCAL format, a set of emendations to a
          catalog can be managed entirely separately and independently from the catalog. Because a
          conformant processor can always create the customized catalog by resolving the profile
          against its sources (executing the transformation described in this document), the profile
          can also be examined and used as a proxy for that catalog for other purposes. The
          customized catalog can be made available wherever and for whatever purposes it is needed,
          while its revision and maintenance can be focused on the profile.</p>
        <p>This separation of concerns - between the originating catalog authors, who describe
          policy in only general terms, and the authors of the <q>user manual</q> catalog, who must
          describe policy in very particular and local terms - is a necessary factor in supporting
          sustainable processes with the potential for automation and process improvement. An OSCAL
          profile bridges the gap between a set of general guidelines, and actionable rules. Only by
          examining the system in the context of the actual intentions appropriate to that system,
          can we properly assess its security. Profiles make this possible.</p>
        <p>In order for this to work however we need a process that can perform the necessary
          operations, to apply the delta to an unmodified catalog, to produce the local view of the
          catalog as modified. This is profile resolution.</p>
      </section>
    </section>


    <section id="readingthis">
      <head>Reading This Document</head>
      <section id="terminology">
        <head>Terminology</head>
        <p>Due to the overload of technical terms used in this domain, the following terms have been
          defined to reduce ambiguity:</p>
        <ul>
          <li>
            <p><term>profile</term> - an OSCAL Profile Document. Defines a set of selections,
              modifications, and transformations against a <term>catalog</term>. See <a
                href="https://pages.nist.gov/OSCAL/concepts/layer/control/profile/">OSCAL Profile
                Model</a>.</p>
          </li>
          <li>
            <p><term>catalog</term> - an OSCAL Catalog Document. Contains a well-defined set of
                <term>controls</term>. See <a
                href="https://pages.nist.gov/OSCAL/concepts/layer/control/catalog/">OSCAL Catalog
                Model</a>.</p>
          </li>
          <li>
            <p><term>control</term> - an indivudual item in an OSCAL Catalog. See <a
                href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r5.pdf"
                >NIST Special Publication 800-53r5</a> for a more in-depth definition.</p>
          </li>
          <li>
            <p><term>profile resolution</term> - The process of consuming one or more OSCAL Profiles
              and the OSCAL Catalogs that they reference to produce a new tailored
                <term>catalog</term>. See <a
                href="https://pages.nist.gov/OSCAL/concepts/layer/control/catalog/">OSCAL Catalog
                Model</a>.</p>
          </li>
          <li>
            <p><term>source</term> - refers to a profile document, or in some cases, an element
              inside a profile document. The <term>source or sources</term> are the input into the
              processor. In this document, when referring to elements from a <term>source</term>
              document, the following style is used: <src>source-element</src>.</p>
          </li>
          <li>
            <p><term>target</term> - the intended output of the transformation, typically a catalog
              document. In this document, when referring to elements of a <term>target</term>
              document, the following style is used: <tgt>target-element</tgt>.</p>
          </li>
          <li>
            <p><term>directive</term> - refers to an element or combination of elements in source
              documents, which is designed to affect a particular outcome in the target catalog. For
              the most part, directives are in the source profile document – for example, a
                <src>set-parameter</src> element in a source profile is a directive to set a
              parameter value in the target catalog.</p>
          </li>
          <li>
            <p><term>original order</term> - the order of elements as presented in the
                <term>source</term> document(s). See Below.</p>
          </li>
          <li>
            <p><term>canonical order</term> - the order of elements as required in the appropriate
              OSCAL Model (Profile, Catalog, etc.). This can differ from the above order when
              converting between "ordered" formats (ex. XML), and "non-ordered" formats (ex.
              JSON).</p>
          </li>
          <li>
            <p><term>control selection</term> - Collections of controls in an intermediate state
              while going through processing steps. <term>Control selections</term> are represented
              in this document as concrete for example only, no OSCAL Profile Processor is required
              or expected to actually produce or recognize such content.</p>
          </li>
        </ul>
      </section>
      <section>
        <head>Requirement Keywords</head>
        <p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in <a href="https://tools.ietf.org/pdf/bcp14.pdf">BCP 14</a>
          <a href="https://tools.ietf.org/pdf/rfc2119">[RFC2119]</a>
          <a href="https://tools.ietf.org/pdf/rfc8174">[RFC8174]</a> when, and only when, they
          appear in all capitals, as shown here.</p>
      </section>
      <section id="use-of-yaml">
        <head>Use of YAML</head>
        <p>OSCAL supports a variety of serialization formats, each of which having it's own benefits
          and drawbacks. In this document, YAML (YAML Ain't Markup Language) is used to represent
          the various objects of the <term>source</term> and <term>target</term>. All examples and
          in-line references will be represented using <a href="https://yaml.org/spec/1.2/spec.html"
            >YAML 1.2</a>.</p>
        <p>YAML maps cleanly to JSON, thus allowing easy use of existing JSON/XML transformers where
          needed. With that in mind, the <a
            href="https://pages.nist.gov/OSCAL/reference/latest/complete/json-reference/">OSCAL
            Complete JSON Reference</a> is a valuable resource for parsing the YAML in this
          document. All JSON properties and objects defined in the reference equate to a YAML
          mapping, list, or dictionary.</p>
      </section>
      <section id="reading-examples">
        <head>Reading YAML Examples</head>
        <p>YAML is a particularly human-readable format. For those unfamiliar with the format, the
          basics: </p>
        <ul>
          <li>
            <p>Each line is a key-value pair, presented as <code>key:value</code>, or as
                <code>key:</code> with any number of list items on the following lines.</p>
          </li>
          <li>
            <p>Indentation, spacing, and whitespace matters. Items below a key and indented one
              level in are members (or children) of that key.</p>
          </li>
          <li>
            <p>List items are represented with a preceeding dash <code>-
              listitemkey:value</code>.</p>
          </li>
        </ul>
        <p>The YAML specification is freely available here: <a
            href="https://yaml.org/spec/1.2/spec.html">YAML 1.2</a>.</p>
        <p>Additionally, in order to unambigulously express information, this specification uses
          additional conventions, as described below.</p>

        <p> There are some objects whose values must be determined dynamically at processing time.
          The most common example of this is timestamping output as it is processed. In this case,
          and any other dynamic value cases, the expression <code>${{ }}</code> is used.</p>
        <p>For example: </p>
        <tagging whose="target_catalog">last-modified: ${{ timestamp }}</tagging>
        <p>Indicates the <tgt>last-modified</tgt> element should be produced with contents generated
          appropriately, in this case, the timestamp at the time of processing.</p>
        <p>Some examples may elide content to enhance readability or save space. This these cases
          the characters <code>~~~</code> will appear on their own line. This is not valid YAML, and
          is only a convention in this document.</p>
        <p>Finally, although examples are syntactically faithful to OSCAL, they are not necessarily
          always formally valid in every respect. For example, OSCAL defines allowed property names
            (<src>props</src>) and values, and those rules may not be observed here. Examples are
          given for purposes of illustrating profile resolution semantics only, and should not be
          taken as normative for any actual use.</p>
      </section>
      <section id="document-layout">
        <head>Document Layout</head>
        <p>The specification is broken into two major sections:</p>
        <ul>
          <li>
            <p><term>Phases of Profile Processing</term> - Lays out the necessary steps and phases
              of profile resolution. As each phase executes, the processor is understood to be
              creating and editing an intermediate representation of the output.</p>
          </li>
          <li>
            <p><term>Target Catalog Structure</term> - Provides the requirements for structuring the
              final output from the intermediate representation generated throughout the previous
              section.</p>
          </li>
        </ul>
        <p><term>Please note</term>: As referenced in the Purpose section <xref rid="purpose"/>,
          this specification makes no hard requirements on the specifics of implementation. It is
          feasible for an implementation to use no intermediate representation, and to directly and
          interatively build the output. As long as all output requirements are satisfied, any
          approach is allowed. With that said, the specification has been laid out to aid in
          implementation by providing a firm organization structure.</p>
      </section>
    </section>

  </section>
  <section id="phases">
    <head>Phases of Profile Processing</head>
    <p>An OSCAL Profile has three major sections, each which correspond to a phase of profile
      resolution. In order to complete the profile resolution process, each section must be fully
      parsed and a Catalog output created.</p>
    <p>While the steps are described in this specification as occurring in sequence, a profile
      processor is not obliged to perform them in the order described. Conformance to these
      specifications is determined by whether the results of processing appear as described <xref
        rid="target"/>, not on whether the means to produce those results work in exactly the manner
      described here.</p>
    <p>The three steps are <term>import</term>; <term>merge</term>; and <term>modify</term>. In
      brief:</p>
    <ul>
      <li>
        <p><term>import</term> - identifies one or more control sources (catalogs or profiles) and
          defines the controls within them to be included in the result catalog. If nothing is
          imported, no resulting catalog is produced. Invoked by <src>import</src> directives in
          source profiles;</p>
      </li>
      <li>
        <p><term>merge</term> - designates the rules for how controls will be organized (ordered
          and/or grouped) and merged (fixing conflicts or ambiguities) in the result catalog.
          Optionally controlled by the <src>merge</src> directive in source profiles; if none are
          included, default merge rules are used;</p>
      </li>
      <li>
        <p><term>modify</term> - indicates how controls and their parameters in the underlying
          catalog are to be altered, edited, amended or added in the final result catalog. Logical
          evaluation and parameter constraints provide advanced processing. Optionally controlled by
          the <src>modify</src> directive in source profiles. If a <src>modify</src> directive is
          not provided, no changes will be made to the controls that have been imported/merged. </p>
      </li>
    </ul>
    <p>As described in the previous section, when resolved, an OSCAL profile takes the form of an
      OSCAL catalog. The phases described below will produce outputs conforming to this model.</p>
    <section id="import">
      <head>Import Phase</head>
      <p>A profile begins by listing a set of Catalogs and/or Profiles to be imported. Each is
        represented by a resovlable resource URI and a directive specifying which controls to import
        from that resource. These resources may be available as static resources, or they may be
        produced dynamically on request; such as is the case when a profile is imported. Imports are
        given in sequence after the metadata:</p>
      <tagging whose="source_profile"><![CDATA[
profile:
  uuid: ~~~
  metadata: ~~~
  imports:
    - href: ${{ catalog URI }}
      include-controls: ${{ list of selected controls }}
    - href: ${{ profile URI }}
      include-controls: ${{ list of selected controls }} ]]>
      </tagging>

      <p>In an import directive, the reference to the resource to be imported appears on an
          <src>href</src> flag. It takes either of two forms, external or internal:</p>

      <p>An external reference appears as an absolute or relative URL:</p>
      <tagging whose="source_profile"><![CDATA[
profile:
  uuid: ~~~
  metadata: ~~~
  imports:
    - href: >-
        https://github.com/usnistgov/oscal-content/tree
        /master/nist.gov/SP800-53/rev4/xml/NIST_SP-800-53_rev4_catalog.xml
      include-controls: ${{ list of selected controls }}
    - href: "../../NIST_SP-800-53_rev5_catalog.xml"
      include-controls: ${{ list of selected controls }} ]]>
      </tagging>

      <p>A catalog or profile can also be imported using an internal link via a URI fragment
        identifier (starting with <code>#</code>). If an import href resolves to a
          <code>resource</code> elsewhere in the profile (typically in back matter), that resource
        MUST be retrieved to provide the source catalog.</p>
      <tagging whose="source_profile"><![CDATA[
profile:
  metadata: ~~~
  imports:
    - href: "#nist-sp800-53_catalog"
      include-controls: ${{ list of selected controls }}
    
    ~~~
    
  backmatter:
    resources:
      - uuid: "nist-sp800-53_catalog"
        description: "NIST SP 800-53 rev5 OSCAL format, on Github."
        rlinks:
          - rlink:
              href: >-
                https://github.com/usnistgov/oscal-content/tree
                /master/nist.gov/SP800-53/rev4/xml/NIST_SP-800-53_rev5_catalog.xml   ]]>
      </tagging>
      <p>All import directives will contain either <src>include-all: ~</src> or
          <src>include-controls</src>. These directives indicate which controls from the imported
        document are actually selected <xref rid="select-phase"/>.</p>
      <section id="resolving-uris">
        <head>Import URI Resolution and Requirements</head>
        <p>Below, requirements are given for handling non-trivial imports.</p>
        <section id="profile-import">
          <head>Importing Profiles</head>
          <p>Profiles may import other profiles. In this case, the processor MUST fetch the profile
            given by the URI and process it using this specification, and import the result
            catalog.</p>
          <p>As any given profile may then reference other profiles, care should be taken to
            mitigate circular imports <xref rid="URI-circular"/>. </p>

          <tagging whose="source_profile"><![CDATA[
profile:
  metadata: ~~~
  imports:
    - href: "other_profile.yaml"
      include-controls: ${{ list of selected controls }}]]>
          </tagging>
        </section>
        <section id="URI-unavailable">
          <head>Unavailable Resource Given by URI</head>
          <p>It is assumed that all calls to a given URI reference will return the same result,
            regardless of when the request is made.</p>
          <p>If documents called for import are determined to be unavailable, the processor MUST cease processing and generate an error.</p>
          <p>Processors MUST use a http request as the default behavior for fetching resources at a
            given URI. However, processors MAY provide fallback behaviors for failed requests, and
            MAY be configured to use an alternative method to retrieve a document identified by a
            URI.</p>

          <tagging whose="source_profile"><![CDATA[
profile:
  metadata: ~~~
  imports:
    - href: "missing_profile.yaml"
      include-controls: ${{ list of selected controls }}]]>
          </tagging>

          <tagging whose="target_catalog"><![CDATA[
catalog:
  metadata: ~~~
  # Import at href: "brokenprofile.yaml" failed.
  # Reason: Resource unavailable: 404 ]]></tagging>

        </section>

        <section id="URI-non-valid">
          <head>Non-Valid Resource Given by URI</head>
          <p>If a resource given by a URI is not a valid OSCAL Catalog or an OSCAL profile that
            resovles to a valid OSCAl catalog, the processor MUST cease processing and generate an error. </p>

          <mapping unit-test="profile-resolution-examples/broken_profile.xml">

            <tagging whose="source_profile"><![CDATA[
profile:
  metadata: ~~~
  imports:
    - href: "broken_profile.yaml"
      include-controls: ${{ list of selected controls }}]]>
            </tagging>


            <tagging whose="target_catalog"><![CDATA[
catalog:
  metadata: ~~~
  # Import at href: "broken_profile.yaml" failed.
  # Reason: Not a valid OSCAL document ]]></tagging>


          </mapping>

        </section>
        <section id="URI-circular">
          <head>Circular imports</head>
          <p>When a profile imports a profile, the subordinate profile is resolved into a catalog
            using this specification. This presents a possibility of circular imports, when a
            profile is directed to import itself either directly or indirectly.</p>
          <p>A <term>circular import</term> is defined as a directive to import a profile, which has
            already been called higher in the import hierarchy. For example, if Profile A imports
            Profile B, and Profile B imports Profile A, the second import is circular. (An import at
            the top can only be circular if a profile tries to import itself.) If A imports B, B
            imports C and C imports A, C’s import is circular.</p>
          <p>Note that an import can only be circular within the context of processing a particular
            profile. In the last example, C’s import would not be circular if invoked in the context
            of resolving B by itself.</p>
          <p>If a processor encounters a <term>circular import</term> as described above (self-imports
            are inherently circular), the processor MUST cease processing and generate an error. </p>


          <mapping unit-test="profile-resolution-examples/home_profile.xml">
            <p>A profile identified as <code>home_profile.yaml</code> imports another one identified
              as <code>circular_profile.yaml</code>:</p>
            <tagging whose="source_profile"><![CDATA[
profile:
  id: "home_profile.yaml"
  metadata: ~~~
  imports:
    - href: "circular_profile.yaml"
      include-controls: ${{ list of selected controls }} ]]></tagging>
            <p>In turn this file invokes <code>home_profile.xml</code>:</p>


            <tagging whose="source_profile"><![CDATA[
profile:
  id: "circular_profile.yaml"
  metadata: ~~~
  imports:
    - href: "home_profile.yaml"
      include-controls: ${{ list of selected controls }} ]]></tagging>
            <p>No control selection is produced for the circular import:</p>
            <tagging whose="target_catalog"><![CDATA[
catalog:
  metadata: ~~~
  # Import at href: "circular_profile.yaml" failed.
  # Reason: Error during profile import:
  # Import at href: "home_profile.yaml" failed.
  # Reason: Circular import ]]></tagging>
          </mapping>
        </section>

        <section id="URI-multiple">
          <head>Multiple imports</head>
          <p>Each import directive is processed to produce a set of controls. Note that this occurs
            even if the same catalog is imported multiple times: each distinct import collects
            controls into a seperate <int>selection</int>:</p>

          <tagging whose="source_profile"><![CDATA[
profile:
  uuid: ~~~
  metadata: ~~~
  imports:
    - href: "#catalog"
      include-controls:
       - with-ids:
          - ac-1
          - ac-2
    - href: "#catalog"
      include-controls:
       - with-ids:
          - ac-3
          - ac-4 ]]>
          </tagging>

          <tagging whose="inter_catalog"><![CDATA[
intermediate:
  metadata: ~~~
  selections:
    - id: ${{uuid of #catalog}}
      included-controls:
          - ac-1
          - ac-2
    - id: ${{uuid of #catalog}}
      included-controls:
          - ac-3
          - ac-4 ]]>
          </tagging>

          <p>The control selections are combined and collapsed in the next phase of processing,
              <term>merge</term> (see below) .</p>
          <p>Multiple imports may result in outputs with clashing controls (see below). Typically
            this will be because a control has been selected twice (in selection or in the
            selections of underlying profiles), and no merge behavior has been indicated to resolve
            the clash.</p>
          <p>Typical cases of multiple imports of the same (underlying) resource will be when a
            profile A imports another profile B, which calls catalog Z, and then profile A calls
            catalog Z again to acquire other controls not included in profile B, or in an original
            form unmodified by profile B.</p>
        </section>
      </section>
      <section id="select-phase">
        <head>Selecting Controls</head>
        <p>Imports can specify controls by some combination of explicit inclusion and exclusion,
          given in each import by the following directives: </p>
        <section id="include-all">
          <head>include-all</head>
          <p>When an import provides the <src>include-all</src> directive, all controls in the
            referenced document MUST be selected:</p>

          <tagging whose="source_profile">include-all: ~ </tagging>
        </section>
        <section id="include-by-id">
          <head>include-controls plus with-id</head>
          <p>When an import provides the <src>include-controls</src> directive, with a
              <src>with-id</src> child, all controls in the referenced document whose
              <code>id</code> match one of the listed <code>id</code> values MUST be selected:</p>
          <tagging whose="source_profile"><![CDATA[
include-controls:
  - with-ids:
    - id: ac-1
    - id: ac-2]]>
          </tagging>
        </section>
        <section id="include-by-match">
          <head>include-controls plus matching</head>
          <p>Controls may also be selected using match patterns against their IDs. This is useful
            because related controls (either in a hierarchy, or together in a group) frequently have
            related IDs as well.</p>
          <p>When an import provides the <src>include-controls</src> directive, with a
              <src>matching</src> child, all controls in the referenced document whose
              <code>id</code> matches one of the listed <code>pattern</code> values (XPath regular
            expression syntax) MUST be selected:</p>
          <p>If a <code>matching</code> element is provided with no <code>pattern</code>, it SHOULD
            be treated as matching nothing.</p>

          <tagging whose="source_profile"><![CDATA[
include-controls:
  - matching:
    - pattern: "ac*" ]]></tagging>
        </section>

        <section id="include-child-controls">
          <head>with-child-controls</head>
          <p>In OSCAL, controls may contain controls. For example, in SP 800-53 many controls are
            supplemented with control enhancements; in OSCAL these are represented as child controls
            within parent controls. So parent AC-2 (in a given catalog) has children AC-2(1) through
            AC-2(13), for example.</p>
          <p>Child controls can be included by the same mechanism as controls, i.e. by means of an
            ID call. Alternatively a match can frequently be applied (at least given most ID
            assignment schemes) to match controls and child controls together.</p>

          <p> A <src>with-child-controls: yes</src> directive on an <src>include-controls</src>
            indicates that <em>all descendant controls </em> of the selected control MUST also be selected. </p>

          <p> A <src>with-child-controls: no</src> directive on an <src>include-controls</src> indicates that ONLY the explictly matching control is selected, any decendents are not selected. </p>
          
          <p> If no <src>with-child-controls</src> is provided, the processor MUST consider the directive as being equivilent to one having <src>with-child-controls:yes</src>. </p>

          <tagging whose="target_catalog"> </tagging>
          <!-- TODO: Example -->
        </section>

        <section id="exclude-directive">
          <head>exclude-controls</head>
          <p>Exclusions work the same way as inclusions, except with the opposite effect - the
            indicated control(s) do not appear in the target catalog.</p>
          <p>Any control designated to be both included and excluded, MUST be excluded. This holds
            irrespective of the specificity of the selection for inclusion or exclusion. For
            example, if AC-1 is included by id <code>ac-1</code> and excluded by matching
              <code>ac.*</code>, it is excluded. Selection for exclusion prevails.</p>
          <p><src>exclude-controls</src> will also have at least one <src>with-ids</src> and
              <src>matching</src> directive, the processor MUST follow the same rules as defined in
            the above sections for these directives, but exclude instead of include any
            controls.</p>
          <tagging whose="target_catalog"> </tagging>
          <!-- TODO: Example -->
        </section>
        <section id="redundant-calls">
          <head>Redundant Inclusions</head>
          <p><src>with-id</src> and <src>matching</src> may be combined in a single import. Their
            effect is cumulative; any control that is selected by both <src>with-id</src> and
              <src>matching</src> from a given <src>include-controls</src> directive, or by matching
            more than one pattern, is included once (unless it is also marked for exclusion, see
              <xref rid="exclude-directive"/>).</p>
          <tagging whose="target_catalog"> </tagging>
          <!-- TODO: Example -->
        </section>
        <section id="controls-order">
          <head>Order of Controls</head>
          <p>Because controls may be organized in the subsequence merge phase, order of controls
            returned in a given import is unimportant. If no merge directive
            is applied, however, or the <q>no merge</q> combination rule is used <xref
              rid="no-merge-combination-rule"/>, controls MUST be returned in the order of
            their appearance in their catalog of origin (NOT the order they appear within the import statement).</p>
          <tagging whose="target_catalog"> </tagging>
          <!-- TODO: Example -->
        </section>

        <section id="import-groups">
          <!-- TODO: behavior change, unspecified grouping behavior -->
          <head>Handling Groups</head>
          <p>Catalogs are sometimes organized using the <src>groups</src> structure, which brings
            controls and other data into one logical grouping. </p>
          <p>In the Import Phase, the Processor MUST search all <src>groups</src> for controls when
            executing inclusion and exclusion directives. This includes nested groups.</p>
          <p>If a control inside a <src>group</src> is selected, the parent <src>group</src> and all
            of it's non-control, non-group children MUST also be selected. This applies recursively
            if the parent group has a parent group, until the top level group has been selected in
            this way as well.</p>
          <p>If a parent group is to be imported by the above requirement, but already exists in the
            intermediate, the control MUST be placed into that group instead. </p>
        </section>
        <section id="import-nested">
          <head>Handling Nested Controls</head>
          <p>Controls are sometimes nested under other controls, with varying levels of dependencies
            between them. </p>
          <p>If a control inside a <src>control</src> is selected, the parent <src>control</src> and
            all of it's non-control children MUST also be selected. This applies recursively if the
            parent control has a parent control, until the top level control has been selected in
            this way as well.</p>
        </section>
        <section id="import-param">
          <head>Handling Params</head>
          <p>Any <src>param</src> that is not directly under a control is referred to as a
              <q>loose</q> param. </p>
          <p>All loose params from both imported documents and the profile source should be
            propagated forward for consideration during the next two phases. Enterprising
            implementaions may consider pruning unused params at this point <xref rid="cleanup"/>,
            but care should be taken to not prune future needed params.</p>
        </section>
      </section>
      <section id="import-wrap-up">
        <head>Wrapping up the Import Phase</head>
        <p>At this point the processor should have stored a set of selected controls, along with all
          of their included information. Parents of the controls, where applicable (see above), are
          also included in the intermediate catalog; that is, any controls that were grouped (under
          a group or under another control) together in the source remain grouped together. Because
          handling of the rest of the information in the source documents will take place in the
          next phase, the rest of the data inside the sources will need to be copied and carried
          forward (including metadata and backmatter).</p>

      </section>
    </section>
    <section id="merge-phase">
      <head>Merge phase</head>
      <p>Profiles may contain a <src>merge</src> section, where directives are given to instruct the
        processor how to combine the set of selections collected during the Import Phase. Merge
        directives also inform the processor as to which extra data can be discarded, or
        alternatively, needs to be kept.</p>
      <section id="merge-combine">
        <head><src>merge/combine</src> - handling control collisions</head>
        <p><term>Colliding controls</term> (or <term>clashing</term>) describes the condition that
          occurs when multiple invocations of controls with the same ID are given, and so a profile
          resolution will result in duplicative and/or contradictory information. Generally such a
          collision is readily detectable as long as IDs have not been modified; in other words,
          constraints over uniqueness (within document scope) of IDs will make it clear when two
          (perhaps different) representations of the same control appear.</p>
        <p>There are three valid combination methods provided by OSCAL, provided by the
            <src>method</src> element under <src>combine</src>: </p>

        <ul>
          <li>
            <p>use-first: Use the first definition - the first control with a given ID is used;
              subsequent ones are discarded</p>
          </li>
          <li>
            <p>merge: Merge - controls with the same ID are combined</p>
          </li>
          <li>
            <p>keep: Keep - controls with the same ID are kept, retaining the clash</p>
          </li>
        </ul>


        <p>Processing requirements for each are described below.</p>

        <section id="no-merge-explicit">
          <head>No <src>merge/combine</src> given</head>
          <p>If no <src>merge</src> directive is given in the profile, or if a <src>merge</src> is
            given without a <src>combine</src>, merge conflicts MUST be treated as if <src>method:
              keep</src> aws given. A profile with no <src>merge</src> directive:</p>
          <tagging whose="source_profile"><![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-all: ~ ]]></tagging>
          <p>is the same as</p>
          <tagging whose="source_profile"><![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-all: ~
  merge:
    combine:
      method: keep ]]></tagging>
          <mapping unit-test="profile-resolution-examples/merge-implicit-keep_profile.xml"/>
        </section>
        <section id="no-merge-combination-rule">
          <head><q>method:keep</q></head>
          <p>When a merge is indicated by <src>method:keep</src>, or not given, the <q>keep</q>
            combination rule is used. Clashing controls or parameters MUST NOT not merged. (They are
            kept.) If they are grouped (in a group or inside another control), they MUST NOT be
            merged, unless another <src>merge</src> directive such as <src>as-is</src> is given.
            (The combination rules affect only the handling of colliding controls, not their
            grouping in the target.)</p>
          <tagging whose="source_profile"><![CDATA[
  merge:
    combine:
      method: keep ]]></tagging>
          <p>Under this directive, colliding controls will result in invalid results, as they will
            both appear in the results with the same ID. Accordingly, this setting may be useful in
            ensuring integrity of references to controls as given in the profile: if any included
            control is called only once, clashing controls will not be produced and validation will
            succeed.</p>
          <mapping unit-test="profile-resolution-examples/merge-keep_profile.xml">
            <tagging whose="source_profile"><![CDATA[
profile:
  imports:
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2 
  merge:
    combine:
      method: keep]]></tagging>
            <p>In the intermediate (showing control selections):</p>
            <tagging whose="inter_catalog"><![CDATA[
intermediate:
  selections:
    - id: ${{uuid of #catalog1}}
      included-controls:
          - ac-1
          - ac-2
    - id: ${{uuid of #catalog1}}
      included-controls:
          - ac-1
          - ac-2 ]]></tagging>
          </mapping>
          <p>In this case, downstream errors should be expected: the two <code>ac-1</code> controls
            clash with each other, as do the two <code>ac-2</code> controls.</p>
          <p>Processors SHOULD provide a warning under this directive when duplicate controls are
            detected. If no other merge directives exist (as-is or custom), the processor MAY throw an error and cease
            processing (short-circuiting a certain future error). </p>
        </section>
        <section id="use-first-combination-rule">
          <head><q>method:use-first</q></head>
          <tagging whose="source_profile"><![CDATA[
  merge:
    combine:
      method: use-first ]]></tagging>
          <p>When the <q>use-first</q> combination rule is applied, the first reference to a given
            control, with respect to the document order of the source data, MUST be included over
            later references. <q>First</q> MUST be determined by a top-down, depth-first traversal
            of the profile import hierarchy. </p>
          <mapping unit-test="profile-resolution-examples/merge-keep_profile.xml">
            <tagging whose="source_profile"><![CDATA[
profile:
  imports:
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-3
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2 
  merge:
    combine:
      method: use-first]]></tagging>
            <p>In the intermediate(showing control selections):</p>
            <tagging whose="inter_catalog"><![CDATA[
intermediate:
  selections:
    - id: ${{uuid of #catalog1}}
      included-controls:
          - ac-1
          - ac-3
    - id: ${{uuid of #catalog1}}
      included-controls:
          - ac-2 ]]></tagging>
          </mapping>
        </section>
        <section id="merge-combination-rule">
          <head><q>method:merge</q></head>
          <tagging whose="source_profile"><![CDATA[
  merge:
    combine:
      method: merge ]]></tagging>
          <p>When the <term>merge</term> combination rule is applied, the processor will merge all
            representations of a given control, as distinguished by ID, into a single unified
            representation.</p>
          <p>Processors MUST adhere to the following requirements for the <src>method:merge</src>
            directive for any given control:</p>
          <ul>
            <li>
              <p>The first time a given control is encountered, the control and all elements inside
                it are kept.</p>
            </li>
            <li>
              <p>For all subsequent encounters with the same control, any duplicate of a distinctive
                element <xref rid="id"/> is discarded, regardless of any difference in content.</p>
            </li>
            <li>
              <p>"First" is determined in the same way as in <xref rid="use-first-combination-rule"
                />, by order of the source document.</p>
            </li>
            <li>
              <p>At the conclusion of merging the control, it's contents are reordered according to
                  <term>canonical order</term>.</p>
            </li>
          </ul>
          <p>Example:</p>
          <tagging whose="source_catalog"><![CDATA[
  control:
    id: ac-1
    title: Control ac-1
    props:
      - name: label
        value: ac-1
      - name: status
        value: ready ]]></tagging>
          <p>merging with</p>
          <tagging whose="source_catalog"><![CDATA[
  control:
    id: ac-1
    title: Control ac-1
    props:
      - name: marking
        value: unclassed
      - name: label
        value: ac-1
      - name: status
        value: pending ]]></tagging>
          <p>produces</p>
          <tagging whose="target_catalog"><![CDATA[
  control:
    id: ac-1
    title: Control ac-1
    props:
      - name: marking
        value: unclassed
      - name: label
        value: ac-1
      - name: status
        value: ready ]]></tagging>
          <p>Note that groups are not merged by this rule; for that purpose, <src>as-is</src> or
              <src>custom</src> should be used (in addition to the combine directive) <xref
              rid="structuring-result"/>.</p>
          <p>Since the effect of this merge rule is to drop data silently (when it is considered to
            be redundant or duplicative), it should only be used on well-understood, well-controlled
            catalog and profile inputs, whose potential clashes or collisions are known in
            advance.</p>
        </section>
        <section id="combining-other">
          <head>Combination Rules with Other Data</head>
          <p>When profiles import from more than one resource (catalog or profile), not only is
            there a potential for clashing controls, but also groups, params, and backmatter.</p>
          <p>If no structuring directives are given, the processor MUST merge all other data using
            the given merge directive, following the rules given for controls, but applied to each
            element.</p>
          <p>With many imports or large catalogs, errors or data loss is likely. This is
            particularly likely in backmatter resources that are grouped under single distinctive
            keys, such as citations. The processor SHOULD provide warnings when non-control data is
            lost as part of a merging process.</p>
          <tagging whose="target_catalog"> </tagging>
          <!-- TODO: Example -->
        </section>
      </section>
      <section id="structuring-result">
        <head>Structuring Directives</head>
        <p>This section describes how a profile may dictate the body of the target
            <tgt>catalog</tgt>, apart from its <tgt>metadata</tgt> or <tgt>back-matter</tgt>.</p>
        <p>The <src>merge</src> element, in addition to proposing a strategy by which to
          disambiguate clashing controls, also includes directives that can be used to organize the
          target catalog into a structure or hierarchy of groups. Two <src>merge</src> directives
          are used to introduce structure into the target catalog, <src>as-is</src> and
            <src>custom</src>. If neither is given, no structure is provided: parameters and
          controls in the target appear in sequence, with no structure or grouping apart from what
          is internal to the controls</p>
        <section id="merge-flat">
          <head>No Structuring Directive</head>
          <p>Profiles that have neither of these directives are resolved as unstructured catalogs,
            with no groupings of controls.</p>
          <p>Unstructured catalog output MUST be produced by adhering to the following requirements: </p>

          <ul>
            <li>
              <p>All selected controls are output to the target as a flat list. Nested controls MUST
                be flattened (parents and children will be on the same level under catalog). </p>
            </li>
            <li>
              <p>All loose <src>params</src> (params not directly under a control) are output to the
                targer.</p>
            </li>
            <li>
              <p>Any groups automatically selected in the Import Phase MUST be flattened, and group
                metadata discarded. Any control contents MUST be merged according to the merge
                method. The processor SHOULD provide a warning if groups are being flattened under
                this directive.</p>
            </li>
            <li>
              <p>Backmatter of source documents are included and merged according to <xref
                  rid="target-back-matter"/> and the merge combination rule.</p>
            </li>
            <li>
              <p>Metadata of source documents are included and merged according to <xref
                  rid="target-metadata"/> and the merge combination rule.</p>
            </li>
            <li>
              <p>At the conclusion of the previous steps, the target catalog's contents are
                reordered according to <term>canonical order</term>.</p>
            </li>

          </ul>

          <tagging whose="target_catalog"> </tagging>
          <!-- TODO: Example -->
        </section>
        <section id="merge-as-is">
          <!--TODO Behavior change? content inclusion during as-is merge: nested controls, groups -->
          <head><q>as-is</q></head>
          <p>An <src>as-is</src>directive is used to reproduce the structure of the source documents
            in the target catalog. </p>
          <p>Processors MUST handle the <src>as-is</src>directive by adhering to the following
            requirements: </p>

          <ul>
            <li>
              <p>All selected controls are output to the target, keeping the groups and nested
                controls that were auto-included during the Import Phase. Controls keep their
                location and structure from the source documents (collected as part of import).</p>
            </li>
            <li>
              <p>All loose <src>params</src> (params not directly under a control) are output to the
                target.</p>
            </li>
            <li>
              <p>Backmatter of source documents are included and merged according to <xref
                  rid="target-back-matter"/> and the merge combination rule.</p>
            </li>
            <li>
              <p>Metadata of source documents are included and merged according to <xref
                  rid="target-metadata"/> and the merge combination rule.</p>
            </li>
            <li>
              <p>At the conclusion of the previous steps, the target catalog's contents are
                reordered according to <term>canonical order</term>.</p>
            </li>
          </ul>

          <p>Example:</p>
          <!--TODO: Example. Also this section is easy because of import rework -->
          <tagging whose="source_catalog"/>
          <p>In this case the profile does not designate either control <code>xyz-1</code> or
            control <code>xyz-1.2</code> for inclusion</p>
          <tagging whose="source_profile"/>
          <p>The unmentioned elements are included, however, with their titles, because controls
            that they contain are included. But control <code>xyz-1.3</code> does not appear in the
            target.</p>
          <tagging whose="target_catalog"/>
          <p>Note that this means there may be controls that are selected implicitly by
              <src>as-is</src> merging, over and above controls actually designated in import
            statements. Thus the control set, considered strictly, of the target of an
              <src>as-is</src> process, will be different from the control set delivered by a <q>no
              merge</q> process.</p>
          <p>Processors may optionally provide services for detection of nesting and structural
            issues related to the importing and merging of controls, including but not limited to
            validation / detection utilities (for imports regarded as incorrect, incomplete or
            otherwise subject to improvement); runtime warnings; or user interfaces.</p>
        </section>
        <section id="merge-custom">
          <head><q>custom</q></head>
          <p>The <src>merge/custom</src> directive provides a way to provide a target catalog with a
            custom structure. It combines <src>include-controls</src> directives, which indicate
            only the controls to be included, into groups, which provide the target with its
            structure.</p>
          <p>The controls to be organized are already selected in the Import Phase. A with-id or
            matching appearing inside <src>custom</src>, if it refers to controls not selected, MUST
            be ignored by the processor.</p>
          <p>The structures given inside <src>custom</src> provide a one-to-one mapping of the
            structure of the target catalog. Unlike <q>as-is</q> merging, there is no implicit
            inclusion of controls by virtue of including descendant controls. Instead, all controls
            are included in the target in the locations indicated by the custom structure.</p>
          <section id="custom-groups">
            <head>Grouping controls inside a custom structure</head>
            <p>A <src>group</src> element given in a custom structure results in a <tgt>group</tgt>
              with the same title and ID in the target. </p>

            <p>If the ID of the group matches the ID of a group that exists in a source document,
              all element contents inside the group, including <src>title</src>, <src>param</src>,
                <src>prop</src> and <src>part</src> elements MUST be copied into the target,
              appearing in the same order as in the source.</p>
            <p>Within <src>custom</src>, <src>include-controls</src> reference controls in much the
              same way as they do when given in <src>import</src> - a control is identified by
                <src>id</src> using <src>with-id</src> or by a pattern match using
                <src>matching</src>).</p>
            <p>A <src>with-id</src> results in including, at that point inside the new grouping,
                <em>all</em> controls with the <src>id</src> given by the <src>with-id</src>. They
              should be given in the same order as they appear in the control selection(s). Note
              that <term>merge combination rules</term> apply, so depending on settings, conflicts
              between controls with the same <src>@id</src> may be resolved. <xref
                rid="merge-combine"/></p>
            <p>A <src>matching</src> directive results in including, at that point inside the new
              grouping, all controls whose <src>id</src> matching, as an XPath regular expression,
              the pattern given in the <src>pattern</src>. They are given in the same order as they
              appear in the input control selection(s). Again, among clashing controls (that have
              the same ID), merge combination rules apply. <xref rid="merge-combine"/></p>
            <p><src>Custom</src> can also indicate the order that the selected controls are to be
              emitted in the result catalog using an <src>order</src> child. Three values MUST be
              supported:</p>
            <ul>
              <li>
                <p><code>ascending</code> will sort all included controls, whether selected by
                    <src>with-id</src> (literal ID) or <src>matching</src> (matching ID to glob
                  expression), into ascending alphanumeric order. <revisit>collation
                    guidance?</revisit></p>
              </li>
              <li>
                <p><code>descending</code> will sort all included controls, whether selected by
                    <src>with-id</src> (literal ID) or <src>matching</src> (matching ID to glob
                  expression), into descending alphanumeric order.</p>
              </li>
              <li>
                <p><code>keep</code> indicates that controls should be inserted in the order of
                  their appearance, first among import selections, then in the order they appear in
                  their (imported) catalog source.</p>
              </li>
            </ul>
            <mapping>
              <tagging whose="source_profile">example here</tagging>
              <tagging whose="target_catalog">example here</tagging>
              <p>In this example, control <code>a2</code> does <em>not</em> appear in the target
                catalog, as a custom structure was indicated (by the presence of the source profile
                  <src>merge/custom</src>), but the control never referenced from inside an
                  <src>insert-controls</src> directive in the custom structure.</p>
              <p>When a custom structure references a control that is not included in any control
                selection (in the import phase), the reference is inoperative. A processor may
                signal a warning in this case.</p>
              <p>Similarly, no error occurs if a control is selected (appears in a control selection
                or even more than one), but it is never referenced from the <src>custom</src>
                structure given. The control does not appear in the target catalog. Again, a
                processor may optionally signal a warning if this occurs.</p>
            </mapping>
            <mapping>
              <tagging whose="source_profile">example here</tagging>
              <tagging whose="target_catalog">example here</tagging>
              <p>In this case, no <tgt>group</tgt> container appears in the target for the controls
                  <code>b2</code> and <code>c2</code>; because they appear unwrapped before the
                  <src>group</src> in the profile source, they appear the same way in the target
                catalog. Control <code>c2</code>, however, appears in a subgroup <code>group2</code>
                inside the group with ID <code>group1</code> , again reflecting the source
                organization. Note also that <src>@id</src> flags are copied.</p>
              <p>Again, no provision is made to prevent duplicate or colliding controls from
                appearing. Optionally, a processor may signal warnings when it determines that
                controls from selections are designated to appear in the results more than once, due
                to multiple colliding occurrences of <src>include-controls/with-id</src> and
                  <src>include-controls/matching</src> inside <src>custom</src>.</p>
            </mapping>
          </section>
          <section id="custom-with-child-controls">
            <head><src>with-child-controls</src> inside a custom catalog structure</head>
            <!--TODO-->
          </section>
        </section>
      </section>
    </section>
    <section id="modify-phase">
      <head>Modify Phase</head>
      <p>There are two ways a control may need to be modified. Commonly, controls might be amended –
        new material might be added. Less commonly, materials might be removed or edited.</p>
      <p>In addition to any modification or adjustment to controls, this section of a profile is
        used to set parameter values or other properties of parameters declared in catalogs and
        referenced from their text. Parameters are propagated from the Import Phase.</p>
      <section id="param-setting">
        <head>Setting Parameters</head>
        <p>Modification of parameter settings is indicated using <src>set-parameter</src>.</p>
        <p>Parameters are not always given within controls. A profile resolution target must include
          copies (with or without modifications or settings) of all parameters defined within the
          source catalog, which are referenced from <src>insert</src> directives anywhere inside
          included controls.</p>
        <p>Accordingly, any parameter referenced by an <src>insert</src> in any source catalog is
          copied from catalog source to target <revisit>parameter propagation rules for merge/as-is,
            merge/custom</revisit> without any configuration required in the profile.</p>
        <p>However, a profile should not reproduce parameters from source catalogs, which are not
          referenced from <src>insert</src> directives.</p>
        <p>When parameters are propagated, they may be modified by <src>set-parameter</src>
          directives given in the profile.</p>
        <p>If more than one <src>set-parameter</src> directive is given for the same parameter, all
          are applied, in the sequence given in the profile.</p>
        <ul>
          <li>
            <p>A <src>set-parameter:label</src> replaces the <src>param:label</src> on the affected
              parameter</p>
          </li>
          <li>
            <p>A <src>set-parameter:value</src>
              <em>or</em> a <src>set-parameter:select</src> replaces <em>any</em>
              <src>param:value</src> or <src>param:select</src> on the affected parameter</p>
          </li>
          <li>
            <p>Other elements given in a <src>set-parameter</src> are added to the affected
              parameter, after elements of the same name</p>
          </li>
          <li>
            <p>The prescribed order of elements in the affected parameter is retained:
                <tgt>label</tgt>; <tgt>usage</tgt>; <tgt>constraint</tgt>; <tgt>guideline</tgt>;
                <tgt>value</tgt> or <tgt>select</tgt> (a choice); and <tgt>link</tgt>.</p>
          </li>
        </ul>

        <p>Note that <tgt>select</tgt> replaces <src>value</src>:</p>
        <tagging whose="target_catalog">example here </tagging>
        <section>
          <head>Setting a missing parameter</head>
          <p>A <src>set-parameter</src> directive whose <src>param-id</src> does not correspond to
            any parameter in the resolved catalog, is inoperative.</p>
          <p>A processor MAY issue a warning where such directives are found.</p>
        </section>
      </section>
      <section id="control-altering">
        <head>Altering controls</head>
        <p>A control can be altered by an <src>alter</src> directive on a control. The
            <src>control-id</src> flag on the <src>alter</src> indicates the control to which the
          alteration is applied.</p>
        <section id="add-directive">
          <head>Adding contents to controls</head>
          <p>Contents may be added to controls using an add directive inside an alter directive.
            There are two forms of alteration: with implicit and explicit bindings.</p>
          <section id="add-to-control">
            <head>Implicit binding</head>
            <p>An <src>add</src> directive with no <src>id-ref</src> flag is taken to apply to the
              control as a whole. Its <src>position</src> flag may be either of two values:
                <code>starting</code> and <code>ending</code>.</p>
            <p>The contents of the add directive are then added to the control contents in the
              target, either after its <tgt>title</tgt> when <src>position</src> is
                <code>starting</code>, or at the end if its position is <code>ending</code>, or not
              given.</p>
            <p>However, control contents in catalogs must appear in the order <code>title, param,
                prop, link, part, control</code>. Subsequent to adding new elements, the control
              contents are sorted to appear in the required order. As a consequence, a new
                <tgt>prop</tgt> appears after any <src>prop</src> already in the control, when
                <src>position</src> is <code>ending</code>, or not given,, or before any
                <src>prop</src> in the control when <src>position</src> is
              <code>starting</code>.</p>
            <p>When add has no <src>@ref-id</src> (has an implicit binding), the <src>position</src>
              values <code>before</code> and <code>after</code> are treated like
                <code>starting</code> and <code>ending</code>, respectively. <revisit>The schema
                permits these values.</revisit></p>
            <mapping>
              <p>An addition operating on a control with implicit binding and position
                  <code>starting</code></p>
              <tagging whose="source_catalog">&lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="status" value="ready"/>
                &lt;/control></tagging>
              <tagging whose="source_profile">&lt;alter control-id="a1"> &lt;add
                position="starting"> &lt;prop name="basis" value="enumerated"/> &lt;part
                name="caution">&lt;p>Pending scheduled testing.&lt;/p>&lt;/part> &lt;/add>
                &lt;/alter></tagging>
              <tagging whose="target_catalog">&lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="basis" value="enumerated"/> &lt;prop
                name="status" value="ready"/> &lt;part name="caution">&lt;p>Pending scheduled
                testing.&lt;/p>&lt;/part> &lt;/control></tagging>
              <p>Position is <code>starting</code> but the new <tgt>part</tgt> is added after the
                existing <tgt>prop</tgt>, because <tgt>prop</tgt> elements must always occur
                first.</p>
            </mapping>
            <mapping>
              <p>An addition operating on a control with implicit binding and position
                  <code>ending</code></p>
              <tagging whose="source_catalog">&lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="status" value="ready"/>
                &lt;/control></tagging>
              <tagging whose="source_profile">&lt;alter control-id="a1"> &lt;add position="ending">
                &lt;prop name="basis" value="enumerated"/> &lt;part name="caution">&lt;p>Pending
                scheduled testing.&lt;/p>&lt;/part> &lt;/add> &lt;/alter></tagging>
              <tagging whose="target_catalog">&lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="status" value="ready"/> &lt;prop name="basis"
                value="enumerated"/> &lt;part name="caution">&lt;p>Pending scheduled
                testing.&lt;/p>&lt;/part> &lt;/control></tagging>
              <p>The <src>add/@position</src> is <code>ending</code> so the new <tgt>prop</tgt>
                appears after the existing <tgt>prop</tgt>.</p>
            </mapping>
          </section>
          <section id="add-to-element">
            <head>Explicit binding</head>
            <p>An explicit binding on an addition permits inserting new contents anywhere in a
              control, not only at the top level. It is given by a <src>@ref-id</src> flag on the
                <src>add</src> directive. The value of the <src>@ref-id</src> must correspond to the
              value of an <src>@id</src> flag on an element inside the control, and not the control
              itself. If <src>ref-id</src> does not correspond to such a value, the <src>add</src>
              directive is inoperative. Optionally, a warning may be issued in such a case.</p>
            <p>The element with <src>@id</src> equal to the <src>@ref-id</src> is considered the
                <term>target</term> of the addition.</p>
            <p>Additionally, with an explicit binding given by a <src>@ref-id</src>,
                <src>@position</src> may have any of the values <code>starting</code>,
                <code>ending</code>, <code>before</code> and <code>after</code>.</p>
            <p>When <src>position</src> is <code>starting</code> or <code>ending</code>, the new
              contents are added at the beginning or ending of the target element, inside that
              element, as are additions into controls (using implicit bindings).</p>
            <p>Additionally, a <src>position</src> given as <code>before</code> indicates the
              addition should be made directly before the target element, while <code>after</code>
              indicates the addition should appear directly after the target element.</p>
            <p><revisit>Unlike additions with implicit bindings, an explicit binding does not
                provide for sorting of newly added elements to ensure correct ordering.
                Consequently, profile authors must take care that additions they make into control
                contents using explicit bindings will produce results valid to the catalog
                schema.</revisit></p>
            <mapping>
              <p>An addition operating on a control with explicit binding and position
                  <code>after</code></p>
              <tagging whose="source_catalog">&lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="status" value="ready"/> &lt;part id="a1.b"
                name="recommendations"> &lt;part id="a1.b1">&lt;p>Collect recycling for
                pickup.&lt;/p>&lt;/part> &lt;part id="a1.b2">&lt;p>Sweep surfaces free of
                dust.&lt;/p>&lt;/part> &lt;/part> &lt;/control></tagging>
              <p>Note that the <src>add</src> directive identifies the element with <src>@id</src>
                <code>a1.b1</code> as its target.</p>
              <tagging whose="source_profile">&lt;alter control-id="a1"> &lt;add position="after"
                ref-id="a1.b1"> &lt;prop name="basis" value="allocated"/> &lt;part
                name="caution">&lt;p>Unavailable on weekends.&lt;/p>&lt;/part> &lt;/add>
                &lt;/alter></tagging>
              <tagging whose="target_catalog">&lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="status" value="ready"/> &lt;part id="a1.b"
                name="recommendations"> &lt;part id="a1.b1">&lt;p>Collect recycling for
                pickup.&lt;/p>&lt;/part> &lt;prop name="basis" value="allocated"/> &lt;part
                name="caution">&lt;p>Unavailable on weekends.&lt;/p>&lt;/part> &lt;part
                id="a1.b2">&lt;p>Sweep surfaces free of dust.&lt;/p>&lt;/part> &lt;/part>
                &lt;/control></tagging>
              <p>The <src>position</src> is <code>after</code> so both elements inside
                  <src>add</src> are added after (not inside) the target element. Since the target
                element is inside another <tgt>part</tgt> in the control, the new additions appear
                there as well.</p>
              <p>Note that the result in this case will be schema-invalid since a <tgt>prop</tgt>
                may not occur directly following a <tgt>part</tgt>. A better result can be obtained
                (a better target may be defined) by using two <src>add</src> directives, to insert
                the new <tgt>prop</tgt> separately before any <tgt>part</tgt> elements in the
                target.</p>
            </mapping>
          </section>
          <section>
            <head>Usage of <src>add</src> directives modifying controls inside controls</head>
            <p>OSCAL supports control extensions inside controls in the form of <src>control</src>
              elements inside <src>control</src> elements. Because the semantics of the
                <src>add</src> directive target any (element) contents of controls, they can be used
              to target these control extensions for modification as well as other contents.</p>
            <p>Because such a control can already be modified using implicit bindings, it is
              recommended that they not be targeted with explicit bindings. Using an implicit
              binding supports more robust alteration since contents in the target can be ordered
              properly by the resolution processor. <revisit>XXX can we guarantee valid results here
                and do we have to specify a sort/order?</revisit> However, it is not an error to
              target control elements in this way, manipulating them in the same way as other
              targets may be manipulated.</p>
          </section>
        </section>
        <section id="remove-directive">
          <head>Removing contents from controls</head>
          <p>Contents inside controls can be removed from them in catalog targets. In combination
            with adding new contents, this feature can be used to edit controls as well as amend
            them.</p>
          <p>A <src>remove</src> directive inside an <src>alter</src> directive identifies an
            element or set of elements inside a control to be removed. It does this using any of
            five flags. Flag are <em>additive</em>; that is, if more than flag is given, all must
            match.:</p>
          <ul>
            <li>
              <p><src>@id-ref</src>, like <src>add/@id-ref</src>, matches an element by its
                  <src>@id</src> value.</p>
              <p>Because <src>@id</src> values are unique, the remove directive will remove only a
                single element. Ordinarily this would not combined with other identifiers for
                removal.</p>
            </li>
            <li>
              <p><src>@name-ref</src> keys to the <src>@name</src> attribute on any element inside
                the control.</p>
              <p>Any element inside the control with the assigned <src>name</src>, is removed
                (typically providing there is also a match on <src>@ns</src>).</p>
            </li>
            <li>
              <p><src>@ns-ref</src> keys to the <src>@ns</src> attribute on any element inside the
                control.</p>
              <p>Any element inside the control with the assigned <src>name</src>, is removed
                (typically providing there is also a match on <src>@name</src>).</p>
            </li>
            <li>
              <p><src>@class-ref</src> keys to the <src>@class</src> attribute on any element inside
                the control. All elements with matching <src>class</src> are removed.</p>
            </li>
            <li>
              <p><src>@item-name</src> keys to the element or property name; for example,
                  <code>&lt;remove item-name='prop'/></code> has the effect of removing all
                  <src>prop</src> elements from inside the control. <revisit>(NB: explain how this
                  maps into JSON when items are grouped)</revisit></p>
            </li>
          </ul>
          <p>Unlike an <src>add</src> directive, a <src>remove</src> may not be bound implicitly to
            the control; its binding, to contents inside the control, must be explicit.</p>
          <p>To remove an control, simply avoid selecting it into the profile, or exclude it
            specifically using <src>import/exclude-controls</src>.</p>
          <p>As with <src>add</src>, a remove that targets any element outside the control, is
            inoperative. Similarly, a remove directive that indicates that all <tgt>prop</tgt>
            elements should be removed from the target catalog, applies only to <src>prop</src></p>
        </section>
        <section>
          <head>Implicit alterations</head>
          <p>Finally some alterations are made automatically.</p>
          <p>For example, <src>link</src> elements in source data representing cross-references in a
            catalog, may no longer be effective in catalogs produced from profiles, which have not
            included the elements (controls or other) to which the links refer.</p>
          <p><revisit>Either: expand the links to refer back to the source catalogs; or remove the
              links.</revisit></p>
          <p><revisit>Note: we could also expand links to point back to the (resolved) source,
              particularly if it is described in back-matter as a resource...</revisit></p>
        </section>
      </section>
    </section>
    <section id="finalphase">
      <head>Final Operations</head>
      <section id="target-back-matter">
        <!--TODO: merge directive? -->
        <head>Backmatter Resolution</head>
        <p><tgt>back-matter</tgt> in the result is produced by combining all elements within
            <src>back-matter</src> in all source catalogs, with the <src>back-matter</src> in the
          input profile. The merge method and merge structuring directives are ignored. The
          following requirements MUST be adhered to by the processor: </p>
        <ul>
          <li>
            <p>Each import is processed in order it was provided in the source profile, then the
              source profile's metadata is processed.</p>
          </li>
          <li>
            <p>Each <src>resource</src> is added to the target in the order given inside the
              import.</p>
          </li>
          <li>
            <p>If a <src>resource</src> has the same <src>uuid</src> as a resource that has already
              been added, the previous resource is removed, and the more recent one added.</p>
          </li>
          <li>
            <p>A resource with a child prop of name:keep and value:always can only be replaced by
              the above rule by a duplicate that also has the keep always prop.</p>
          </li>
        </ul>
        <p>Placing the keep always prop on a resource in a catalog has the effect of ensuring it
          will always appear in the output produced by any profile importing that catalog, even if
          nothing links to the resource. This version of the resource will also be the one copied,
          unless a later-imported catalog or importing profile offers its own version marked to keep
          always.</p>

        <tagging whose="target_catalog"> </tagging>
        <!-- TODO: Example -->
      </section>
      <section id="target-metadata">
        <head>Metadata Resolution</head>
        <p>Metadata in the target is derived directly from the source metadata, with modifications.
          With the exceptions given, elements inside <src>metadata</src> in the source profile
          SHOULD be copied in their original order into the result catalog. Any conflicts SHOULD be
          resolved using the selected merge method. </p>
        <p>The value of metadata:last-modified in the target SHOULD be updated with a valid
          timestamp representing the time the profile resolution completed. </p>
        <p>Because of options in producing metadata and especially the requirement for a timestamp,
          developers and users should note that two different resolutions of the same profile will
          not, ordinarily, be identical inside <tgt>metadata</tgt>.</p>

        <tagging whose="target_catalog"> </tagging>
        <!-- TODO: Example -->
      </section>
      <section id="cleanup">
        <head>Pruning</head>
        <p>The processor SHOULD prune the result catalog
          to remove unused values. A given object is considered ununsed if it meets ALL of the
          following criteria:</p>
        <ul>
          <li>
            <p>The object does not have a child prop with name:keep and value:always</p>
          </li>
          <li>
            <p>The source profile has no explicit references to the object. This could appear as a
              selection in the Import Phase, selection in the Merge Phase using the custom
              structure, any reference in the Modify Phase, or originates from the source profile
              itself.</p>
          </li>
          <li>
            <p>There are no references to the object anywhere in the final result catalog, except in other obejects that also meet all other pruning criteria. A reference to
              a given object exists if "#{distinctiveID}" appears anywhere, where {distinctiveID} is
              the distinctive ID of the object <xref rid="id"/>. </p>
          </li>
        </ul>
        <p>Implementers should note that pruning need not take place after all other steps. As long as all above criteria are respected, pruning can happen at any time, and doing so is a likely performance and memory overhead improvement. </p>
      </section>
    </section>
  </section>
  <section id="target">
    <head>Target Catalog Requirements</head>

    <ul>
      <li>
        <p>The output of a profile resolution MUST be in the cannonical order of an OSCAL catalog as
          defined by the OSCAL Catalog Metaschema.</p>
      </li>
      <li>
        <p>The output of a profile resolution MUST take the form of a catalog. Catalog results (the
          output of a conformant profile resolution) MUST be valid to the OSCAL catalog schema.</p>
      </li>
      <li>
        <p>The output of a profile resolution MUST obey the ID unqiueness rules of OSCAL. Any
          violations of this rule MUST result in an error.</p>
      </li>
      <li>
        <p>The output of a profile resolution SHOULD have a uniquely generated top-level ID (the
          direct child of catalog). The ID MAY be a combination of meaningful text and a uniquely
          generated value (Ex. <code>profilename-RESOLVED-GUID</code>).</p>
      </li>


      <li>
        <p>Conforming with canonical order, the target catalog MUST have a content model as follows:
            <code>(metadata, param*, control*, back-matter?)</code></p>
      </li>
      <li>
        <p>If <src>merge/as-is</src> is used, the structure of the target MUST reflect the
          structure(s) of the source catalog(s).</p>
      </li>
      <li>
        <p>Conforming with canonical order, the target catalog has the content model
            <code>(metadata, param*, control*, group*, back-matter?)</code> where <code>group</code>
          has the model <code>(title?, prop*, part*, param*, control*, group*)</code>.</p>
      </li>
      <li>
        <p>If <src>merge/custom</src> is used, see above. The content model of the target catalog is
          the same as that for <src>merge/as-is</src>.</p>
      </li>
      <li>
        <p>Unless it be for special purposes in a debugging or tracing mode, profile results SHOULD
          not show any groups or structures in the form of elements not described here. Depending on
          the merge directive, all groups will be given either by the catalog source(s)
            (<src>merge/as-is</src>) or the profile (<src>merge/custom</src>), or there will be no
          groups at all (no merge directive).</p>
      </li>
    </ul>
  </section>
  <section id="other">
    <head>Items of Note</head>
    <section id="id">
      <head>ID uniqueness constraint</head>
      <p>In addition to those described and enforced by the respective schemas, there are additional
        constraints over the data that this process relies on. The most important of these is
        ID-distinctiveness. </p>
      <p>Whenever this specification refers to <q>distinctiveness</q>, it MUST be interperted as is
        defined in this section. Each object's distinctiveness is defined by a certain child value.
        If an object lacks it's defined value, it is assumed to be <q>null</q>.</p>
      <ul>
        <li>
          <p>control,param,part,group - distinctiveness is defined by the <q>id</q> value.</p>
        </li>
        <li>
          <p>resource,prop - distinctiveness is defined by the <q>uuid</q> value.</p>
        </li>
        <li>
          <p>link - distinctiveness is defined by the <q>uuid</q> value.</p>
        </li>
      </ul>
      <p>Because ID distinctiveness is critical, OSCAL users should take care that different
        catalogs have distinct sets of IDs. This applies to all structures within the catalogs, not
        only controls but also groups, parameters, citations and resources.</p>
    </section>
    <section id="multiformat">
      <head>Dealing with Multiple Formats (WIP)</head>
      <section id="valid-endpoints">
        <head>Formal validation of source and result</head>
        <p>In an XML context, document validation is available as a means of determining whether an
          arbitrary XML document entity conforms to structural and naming constraints such as must
          be assumed by processors respecting application semantics. These specifications assume
          that XML inputs for profile resolution will be <em>schema-valid</em> with respect to the
          OSCAL <term>profile</term> model, and hence will be tagged in the namespace
            <code>http://csrc.nist.gov/ns/oscal/1.0</code>.</p>
        <p>Similarly, the definition of the output format or results, is constrained by the OSCAL
            <term>catalog</term> model as defined by its schema.</p>
      </section>
      <section>
        <head>Order of objects in serialization</head>
        <p>As described above, <term>original order</term> refers to the order of elements and
          objects as given in the source, whereas <term>canonical order</term> refers to the
            <q>correct</q> order of elements or objects as defined by an OSCAL format such as the
          catalog or profile models. That is, the respective schemas of these models enforce order
          to the extent it is meaningful; where it is not (for example, in the ordering of
          properties on objects in JSON), a metaschema can nevertheless be referenced to restore an
          order.</p>
        <p>So for example, on a JSON object, a <src>links</src> object and a <src>parts</src> object
          may be given as properties on a <src>control</src> object. As properties, they are not
          ordered with respect to one another. However, for the sake of a complete definition in
          another of OSCAL's operational contexts (namely XML), the catalog model stipulates that
          all links come before all parts: in an XML representation, <tgt>link</tgt> elements come
          before <tgt>part</tgt> elements. This restriction ensures that the relative ordering of
          links to parts will never be significant in the data: while the order of links within
            <tgt>links</tgt> and the order of parts within <tgt>parts</tgt> may be significant and
          can hence be preserved across representations, the order <q>first links, then parts</q> is
          defined by the model, with the consequence that it can be represented as such even when an
          underlying representation (such as a compiled JSON object) does not encode that
          relationship natively.</p>
        <p>There are occasions especially when control contents are altered or amended, when a
          straightforward representation of elements in their original order, or in two sequences
          spliced together (say, the parts of a control, followed by new properties for the same
          control, added by the profile), would be invalid, which is to say not conformant with
          canonical order. In general the rule in these cases is, in resolution, to reorder the
          elements. <revisit>Example</revisit></p>
        <p>For any given element (defined as an assembly in the metaschema), the canonical order is
          given by its model. So for example the canonical order for contents of a catalog is
            <tgt>metadata</tgt>, <tgt>param</tgt>, <tgt>control</tgt>, <tgt>group</tgt>,
            <tgt>back-matter</tgt>. Within this sequence, members may be missing, as for example not
          all catalogs will have parameters or groups. Any members that are present, however, must
          be given in this order.</p>
      </section>
      <section id="comments-in-result">
        <head>Comments in result documents</head>
        <p>In an XML-based profile resolution, XML comments are one straightforward way for a
          processor to record events or conditions without affecting the output's nominal semantics.
          To support this, while two processors are obliged to return the same catalog XML for the
          same profile XML inputs, they are not required to match one another's comments, whitespace
          usage, attribute order, or processing instructions, only each other's elements, attributes
          and data content.</p>
        <p>One consequence of this is that processes intended to compare two profile resolutions may
          have to accommodate differences in comments, considering them as insignificant along with
          other differences in serialization.</p>
      </section>
    </section>
  </section>


  <!--
  <section>
    <head>Options</head>
    <p>For conformance, an OSCAL processor must deliver results of profile processing, in a basic
      configuration, exactly as described in these specifications with no elaboration.</p>
    <p>Conformance does not preclude providing additional features, however, including elaborated
      outputs, in an optional mode. Such features could include offering warning or process
      exception handling (appropriate to workflow) not described here; outputs provided with
      comments or extra structure to support tracing or analytics; or (alternative) <q>gateway</q>
      and <q>draconian</q> modes that would provide user assistance or refuse to deliver results for
      inputs considered erroneous in a workflow.</p>
  </section>
-->
</SPECIFICATION>
