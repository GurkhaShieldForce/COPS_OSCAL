<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="specml.rnc" type="application/relax-ng-compact-syntax"?>
<!--<?xml-stylesheet type="text/xsl" href="specml-html-xslt1.xsl"?>-->
<?xml-stylesheet type="text/css" href="specml.css"?>
<?xml-model href="spec-checkup.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>


<!-- 
Standing list of general TODO:

-Check for proper usage of inline tags: <src><tgt><inter><term><code>
-Spelling/Grammar
-Term usage (may need group agreement):
  -Capitilization consistency
  -Word choice consistency (object,field,element,child,parent,etc)
-->

<SPECIFICATION xmlns="http://csrc.nist.gov/ns/oscal/specml">
  <head>OSCAL Profile Resolution</head>
  <section id="abstract">
    <head>Abstract</head>
    <p>This specification provides the requirements for transforming and rendering one or more OSCAL
      Profile and Catalog Documents as a new OSCAL Catalog Document. This process of applying
      profiles to a catalog to create a new catalog is called <term>Profile Resolution</term>. This
      specification is intended for software developers who are or who intend to develop an OSCAL
      Profile Resolver, or for OSCAL Profile authors who want a more in-depth understanding of
      profile resolution.</p>
  </section>
  <section id="intro">
    <head>Introduction</head>
    <section id="purpose">
      <head>Purpose</head>
      <p>This document provides the normative requirements for an OSCAL Profile Resolver. As
          <term>profile resolution</term> is a core component to the functional use of OSCAL it is
        important for requirements to be well-defined, such that OSCAL is fully interoperable
        between parties.</p>
      <p>No requirements are placed on implementation-level details, instead, requirements are laid
        out as what the output of resolution must look like given a certain input. By adhering to
        these requirements OSCAL producers, OSCAL consumers, and any other members of the OSCAL
        ecosystem can share OSCAL Profiles with the assurance that they will be understood in the
        same way as they were written to be. </p>
    </section>
    <section id="infocontext">
      <head>Informational Context</head>
      <section id="processing-context">
        <!-- TODO: Needs more in-depth editing pass -->
        <head>Scope</head>
        <p>A <term>profile</term> in OSCAL represents a selection and configuration of a set of
            <term>controls</term>. In the normal case, the set of controls available to a profile is
          provided by a catalog. For example, the three NIST SP 800-53 profiles representing the
          impact baselines HIGH, MODERATE and LOW: each of these calls on a catalog representing the
          families, controls and control enhancements described in SP 800-53/53A. In a data
          processing system, this dependency can be modeled in the form of separate documents or
          data instances - the (nominal) <q>catalog</q> and its <q>profile</q>, the latter being a
          selection, adaptation and organization of controls, as distinct from the catalog from
          which those controls are derived.</p>
        <p>However, profiles may also select controls from profiles, thus deriving them from
          underlying catalogs as modified by those profiles. This feature enables an organization
          that wishes to promulgate guidelines or requirements to do so by publishing a set of
          customizations to an existing catalog, rather than create a catalog from scratch. Profiles
          can also arrange combinations of controls from more than one catalog or profile origin,
          making it possible to use them to support the creation of hybrid catalogs. </p>
        <p>In the general case OSCAL must support sourcing more than one catalog at once, in order
          to aggregate and organize controls from disparate sources. For example, it should be
          routine for a profile to acquire its controls from an authoritative standard catalog, plus
          a local supplement. But multiple catalog inputs, especially when they are produced and
          sourced independently of one another, may not combine without issues. In order to provide
          sensible and transparent results even for incoherent inputs, this specification defines
          these processes such that legible and testable results are produced even when they are
          formally invalid to constraints governing the outputs. Such downstream processing errors
          including validation errors are expected to be detectable and remediable. This especially
          applies to situations where multiple catalogs are sourced, or where the same catalog is
          sourced more than once, directly or indirectly.</p>
        <p>In order to support these semantics – because whatever data set is sourced by a profile,
          it must <q>look like a catalog</q> – the results of resolving a single profile must be in
          the form of a single catalog. Two different OSCAL processors that promise profile
          resolution, must deliver, for the same input, the same catalog with regard to its
          contents: which controls are included; their ordering (insofar as the target format
          represents ordering); and the structure (groups) in which they are embedded. This
          specification is designed to make this possible, by defining outputs with sufficient rigor
          that <q>the same</q> is meaningful and testable in this context.</p>
      </section>
      <section id="why-a-catalog">
        <!-- TODO: Needs more in-depth editing pass -->
        <head>Why resolve a profile as a catalog</head>
        <p>A profile is a representation of a delta, a <q>here to there</q>. As such, a profile
          might be conceived of as a recipe or instruction set – a sequence of steps or procedures –
          whereby to create an OSCAL catalog (set of controls describing security requirements) from
          an OSCAL catalog (set of controls describing security requirements). The primary use case
          for this is when we need to make a new catalog to apply to a system or set of systems,
          starting from a canonical, received, mandated or standard catalog with a more general
          scope.</p>
        <p>This is because although catalogs - for example, the controls described in NIST SP 800-53
          - are published, available for use, and even standardized, they can never be used exactly
          in the form in which they are acquired. They must be taken from the packaging and placed
          into operational context before they mean anything. This typically requires that a few
          operations over <q>raw catalogs</q> be supported by a profiling mechanism. We must be able
          to select controls; we must be able to arrange them in order (or not); and we must be able
          to qualify or condition them by setting parameters defined for them and making adjustments
          to them. </p>
        <p>By representing the steps by which a base catalog can be sliced, sifted, amended and
          edited, into a (nominally) finished or ready set of control requirements, a profile makes
          it easier to codify and preserve even very incidental or temporary local revisions of a
          control catalog. Once expressed as a profile in OSCAL format, a set of emendations to a
          catalog can be managed entirely separately and independently from the catalog. Because a
          conformant processor can always create the customized catalog by resolving the profile
          against its sources (executing the transformation described in this document), the profile
          can also be examined and used as a proxy for that catalog for other purposes. The
          customized catalog can be made available wherever and for whatever purposes it is needed,
          while its revision and maintenance can be focused on the profile.</p>
        <p>This separation of concerns - between the originating catalog authors, who describe
          policy in only general terms, and the authors of the <q>user manual</q> catalog, who must
          describe policy in very particular and local terms - is a necessary factor in supporting
          sustainable processes with the potential for automation and process improvement. An OSCAL
          profile bridges the gap between a set of general guidelines, and actionable rules. Only by
          examining the system in the context of the actual intentions appropriate to that system,
          can we properly assess its security. Profiles make this possible.</p>
        <p>In order for this to work however we need a process that can perform the necessary
          operations, to apply the delta to an unmodified catalog, to produce the local view of the
          catalog as modified. This is profile resolution.</p>
      </section>
    </section>


    <section id="readingthis">
      <head>Reading This Document</head>
      <section id="terminology">
        <!-- TODO: Parse document for additional terms to add -->
        <head>Terminology</head>
        <p>Due to the overload of technical terms used in this domain, the following terms have been
          defined to reduce ambiguity:</p>
        <ul>
          <li>
            <p><term>profile</term> - an OSCAL Profile Document. Defines a set of selections,
              modifications, and transformations against a <term>catalog</term>. See <a
                href="https://pages.nist.gov/OSCAL/concepts/layer/control/profile/">OSCAL Profile
                Model</a>.</p>
          </li>
          <li>
            <p><term>catalog</term> - an OSCAL Catalog Document. Contains a well-defined set of
                <term>controls</term>. See <a
                href="https://pages.nist.gov/OSCAL/concepts/layer/control/catalog/">OSCAL Catalog
                Model</a>.</p>
          </li>
          <li>
            <p><term>control</term> - an individual item in an OSCAL Catalog. See <a
                href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r5.pdf"
                >NIST Special Publication 800-53r5</a> for a more in-depth definition.</p>
          </li>
          <li>
            <p><term>profile resolution</term> - The process of consuming one or more OSCAL Profiles
              and the OSCAL Catalogs that they reference to produce a new tailored
                <term>catalog</term>. See <a
                href="https://pages.nist.gov/OSCAL/concepts/layer/control/catalog/">OSCAL Catalog
                Model</a>.</p>
          </li>
          <li>
            <p><term>source</term> - refers to a profile document, or in some cases, an element
              inside a profile document. The <term>source or sources</term> are the input into the
              processor. In this document, when referring to elements from a <term>source</term>
              document, the following style is used: <src>source-element</src>.</p>
          </li>
          <li>
            <p><term>target</term> - the intended output of the transformation, typically a catalog
              document. In this document, when referring to elements of a <term>target</term>
              document, the following style is used: <tgt>target-element</tgt>.</p>
          </li>
          <li>
            <p><term>directive</term> - refers to an element or combination of elements in source
              documents, which is designed to affect a particular outcome in the target catalog. For
              the most part, directives are in the source profile document – for example, a
                <src>set-parameter</src> element in a source profile is a directive to set a
              parameter value in the target catalog.</p>
          </li>
          <li>
            <p><term>original order</term> - the order of elements as presented in the
                <term>source</term> document(s). See Below.</p>
          </li>
          <li>
            <p><term>canonical order</term> - the order of elements as required in the appropriate
              OSCAL Model (Profile, Catalog, etc.). This can differ from the above order when
              converting between "ordered" formats (ex. XML), and "non-ordered" formats (ex.
              JSON).</p>
          </li>
          <li>
            <p><term>control selection</term> - Collections of controls in an intermediate state
              while going through processing steps. <term>Control selections</term> are represented
              in this document as concrete for example only, no OSCAL Profile Processor is required
              or expected to actually produce or recognize such content.</p>
          </li>
        </ul>
      </section>
      <section>
        <head>Requirement Keywords</head>
        <p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
          interpreted as described in <a href="https://tools.ietf.org/pdf/bcp14.pdf">BCP 14</a>
          <a href="https://tools.ietf.org/pdf/rfc2119">[RFC2119]</a>
          <a href="https://tools.ietf.org/pdf/rfc8174">[RFC8174]</a> when, and only when, they
          appear in all capitals, as shown here.</p>
      </section>
      <section id="use-of-yaml">
        <head>Use of YAML</head>
        <p>OSCAL supports a variety of serialization formats, each of which having it's own benefits
          and drawbacks. In this document, YAML (YAML Ain't Markup Language) is used to represent
          the various objects of the <term>source</term> and <term>target</term>. All examples and
          in-line references will be represented using <a href="https://yaml.org/spec/1.2/spec.html"
            >YAML 1.2</a>.</p>
        <p>YAML maps cleanly to JSON, thus allowing easy use of existing JSON/XML transformers where
          needed. With that in mind, the <a
            href="https://pages.nist.gov/OSCAL/reference/latest/complete/json-reference/">OSCAL
            Complete JSON Reference</a> is a valuable resource for parsing the YAML in this
          document. All JSON properties and objects defined in the reference equate to a YAML
          mapping, list, or dictionary.</p>
      </section>
      <section id="reading-examples">
        <head>Reading YAML Examples</head>
        <p>YAML is a particularly human-readable format. For those unfamiliar with the format, the
          basics: </p>
        <ul>
          <li>
            <p>Each line is a key-value pair, presented as <code>key:value</code>, or as
                <code>key:</code> with any number of list items on the following lines.</p>
          </li>
          <li>
            <p>Indentation, spacing, and white space matters. Items below a key and indented one
              level in are members (or children) of that key.</p>
          </li>
          <li>
            <p>List items are represented with a preceding dash <code>-
              listitemkey:value</code>.</p>
          </li>
        </ul>
        <p>The YAML specification is freely available here: <a
            href="https://yaml.org/spec/1.2/spec.html">YAML 1.2</a>.</p>
        <p>Additionally, in order to unambiguously express information, this specification uses
          additional conventions, as described below.</p>

        <p> There are some objects whose values must be determined dynamically at processing time.
          The most common example of this is timestamping output as it is processed. In this case,
          and any other dynamic value cases, the expression <code>${{ }}</code> is used.</p>
        <p>For example: </p>
        <tagging whose="target_catalog">last-modified: ${{ timestamp }}</tagging>
        <p>Indicates the <tgt>last-modified</tgt> element should be produced with contents generated
          appropriately, in this case, the timestamp at the time of processing.</p>
        <p>Some examples may elide content to enhance readability or save space. This these cases
          the characters <code>~~~</code> will appear on their own line. This is not valid YAML, and
          is only a convention in this document.</p>
        <p>Finally, although examples are syntactically faithful to OSCAL, they are not necessarily
          always formally valid in every respect. For example, OSCAL defines allowed property names
            (<src>props</src>) and values, and those rules may not be observed here. Examples are
          given for purposes of illustrating profile resolution semantics only, and should not be
          taken as normative for any actual use.</p>
      </section>
      <section id="document-layout">
        <head>Document Layout</head>
        <p>The specification is broken into two major sections:</p>
        <ul>
          <li>
            <p><term>Phases of Profile Processing</term> - Lays out the necessary steps and phases
              of profile resolution. As each phase executes, the processor is understood to be
              creating and editing an intermediate representation of the output.</p>
          </li>
          <li>
            <p><term>Target Catalog Structure</term> - Provides the requirements for structuring the
              final output from the intermediate representation generated throughout the previous
              section.</p>
          </li>
        </ul>
        <p><term>Please note</term>: As referenced in the Purpose section <xref rid="purpose"/>,
          this specification makes no hard requirements on the specifics of implementation. It is
          feasible for an implementation to use no intermediate representation, and to directly and
          iteratively build the output. As long as all output requirements are satisfied, any
          approach is allowed. With that said, the specification has been laid out to aid in
          implementation by providing a firm organization structure.</p>
      </section>
      <section id="intermediate">
        <head>The Intermediate and Implementation Guidance</head>
        <p>The overall intent of this document, in addition to defining strict requirements, is to
          provide rough guidelines on implementing an OSCAL Profile Resolution Tool. To this end,
          each phase of resolution will be framed as a series of transformations applied to an
          internal data structure that is persistent throughout the process. We call this "the
          intermediate".</p>

        <p>Any examples that are labelled as "Intermediate" are psuedo-code, designed to represent
          how this data structure may look as we apply different operations to it. The example
          intermediates are often not valid OSCAL, and are not to be taken as guidance, but rather a
          useful visualization tool for implementers.</p>

        <p>The authors believe that applying the steps of resolution in order against this
          persistent representation is the simplest way to achieve full compliance with the
          specification. HOWEVER, there is no requirement to implement Profile Resolution in this
          way. Requirements are given as restrictions on the output of resolution, and as such,
          tools can operate any way they would like internally.</p>
      </section>

    </section>

  </section>
  <section id="phases">
    <head>Phases of Profile Processing</head>
    <p>An OSCAL Profile has three major sections, each which correspond to a phase of profile
      resolution. In order to complete the profile resolution process, each section must be fully
      parsed and a Catalog output created.</p>
    <p>It is STRONGLY RECOMMENDED that implementations execute the following steps in the order that
      they are provided here. While it is possible to achieve compliance with a non-standard
      approach, the iterative nature of profile resolution lends itself to linear processing.</p>
    <p>The three steps are <term>import</term>; <term>merge</term>; and <term>modify</term>. In
      brief:</p>
    <ul>
      <li>
        <p><term>import</term> - identifies one or more control sources (catalogs or profiles) and
          defines the controls within them to be included in the result catalog. If nothing is
          imported, no resulting catalog is produced. Invoked by <src>import</src> directives in
          source profiles;</p>
      </li>
      <li>
        <p><term>merge</term> - designates the rules for how controls will be organized (ordered
          and/or grouped) and merged (fixing conflicts or ambiguities) in the result catalog.
          Optionally controlled by the <src>merge</src> directive in source profiles; if none are
          included, default merge rules are used;</p>
      </li>
      <li>
        <p><term>modify</term> - indicates how controls and their parameters in the underlying
          catalog are to be altered, edited, amended or added in the final result catalog. Logical
          evaluation and parameter constraints provide advanced processing. Optionally controlled by
          the <src>modify</src> directive in source profiles. If a <src>modify</src> directive is
          not provided, no changes will be made to the controls that have been imported/merged. </p>
      </li>
    </ul>
    <p>As described in the previous section, when resolved, an OSCAL profile takes the form of an
      OSCAL catalog. The phases described below will produce outputs conforming to this model.</p>
    <section id="import">
      <head>Import Phase</head>
      <p>A profile begins by listing a set of Catalogs and/or Profiles to be imported. Each is
        represented by a resolvable resource URI and a directive specifying which controls to import
        from that resource. These resources may be available as static resources, or they may be
        produced dynamically on request; such as is the case when a profile is imported. Imports are
        given in sequence after the metadata:</p>
      <tagging whose="source_profile"><![CDATA[
profile:
  uuid: ~~~
  metadata: ~~~
  imports:
    - href: ${{ catalog URI }}
      include-controls: ${{ list of selected controls }}
    - href: ${{ profile URI }}
      include-controls: ${{ list of selected controls }} ]]>
      </tagging>

      <p>In an import directive, the reference to the resource to be imported appears on an
          <src>href</src> flag. It takes either of two forms, external or internal:</p>

      <p>An external reference appears as an absolute or relative URL:</p>
      <tagging whose="source_profile"><![CDATA[
profile:
  uuid: ~~~
  metadata: ~~~
  imports:
    - href: >-
        https://github.com/usnistgov/oscal-content/tree
        /master/nist.gov/SP800-53/rev4/xml/NIST_SP-800-53_rev4_catalog.xml
      include-controls: ${{ list of selected controls }}
    - href: "../../NIST_SP-800-53_rev5_catalog.xml"
      include-controls: ${{ list of selected controls }} ]]>
      </tagging>
      <p>All import directives will contain either <src>include-all: ~</src> or
          <src>include-controls</src>. These directives indicate which controls from the imported
        document are explicitly selected <xref rid="select-phase"/>.</p>

      <section id="importhrefs">
        <head>Import href Requirements</head>

        <section id="resolving-uris">
          <head>Import URI Resolution</head>
          <p>Tools MUST resolve URIs by following <a
              href="https://datatracker.ietf.org/doc/html/rfc3986#section-5">Section 5 of
              RFC3986</a>, with the exception of URI Fragments (URIs that start with "#"). URI
            Fragments MUST instead be resolved as defined in <xref rid="internalref"/>.</p>
        </section>

        <section id="aquiring-resource">
          <head>Import Resource Acquisition</head>
          <p>Tools MUST acquire resources at the resolved URI by following <a
              href="https://datatracker.ietf.org/doc/html/rfc3986#section-5">Section 5 of
              RFC3986</a>, with the exception of URI Fragments (URIs that start with "#"). URI
            Fragments MUST instead be acquired as defined in <xref rid="internalref"/>.</p>
          <p>In the case that acquiring a resource fails, the tool MUST cease processing and provide
            an error. In order to ensure profile resolution results in the same Catalog regardless
            of which tool resolves it, all imports must successfully resolve. While this may cause
            inconvenience if resources are frequently not available, it ensures
            interoperability.</p>
        </section>
        <section id="internalref">
          <head>Internal References</head>
          <p>URI Fragments in OSCAL represent internal references to other OSCAL objects in the same
            document. These references follow the pattern of "#{{objectID}}". For example, the URI
            Fragment "#param1" is referencing the Parameter with unique ID "param1".</p>
          <p>Tools MUST resolve and acquire URI Fragments by fetching the OSCAL object referenced.
            The reference must only be searched for within the list of IDs of all objects in the
            document in which the reference appears.</p>
          <p>If the object fetched cannot be found or is not a valid OSCAL object, the tool MUST
            cease processing and provide an error.</p>
          <tagging whose="source_profile"><![CDATA[
profile:
  metadata: ~~~
  imports:
    - href: "#nist-sp800-53_catalog"
      include-controls: ${{ list of selected controls }}
    
    ~~~
    
  backmatter:
    resources:
      - uuid: "nist-sp800-53_catalog"
        description: "NIST SP 800-53 rev5 OSCAL format, on Github."
        rlinks:
          - rlink:
              href: >-
                https://github.com/usnistgov/oscal-content/tree
                /master/nist.gov/SP800-53/rev4/xml/NIST_SP-800-53_rev5_catalog.xml   ]]>
          </tagging>
        </section>
        <section id="URI-circular">
          <head>Resolving Imports of Profiles</head>
          <p>If the resource acquired is an OSCAL Profile, the tool MUST apply this specification to
            resolve it, then continue processing having imported the resulting catalog.</p>
          <p>When a profile imports a profile, the subordinate profile is resolved into a catalog
            using this specification. This presents a possibility of circular imports, when a
            profile is directed to import itself either directly or indirectly.</p>
          <p>A <term>circular import</term> is defined as a directive to import a profile, which has
            already been called higher in the import hierarchy. For example, if Profile A imports
            Profile B, and Profile B imports Profile A, the second import is circular. (An import at
            the top can only be circular if a profile tries to import itself.) If A imports B, B
            imports C and C imports A, C’s import is circular.</p>
          <p>Note that an import can only be circular within the context of processing a particular
            profile. In the last example, C’s import would not be circular if invoked in the context
            of resolving B by itself.</p>
          <p>If a processor encounters a <term>circular import</term> as described above
            (self-imports are inherently circular), the processor MUST cease processing and generate
            an error. </p>


          <mapping unit-test="profile-resolution-examples/home_profile.xml">
            <p>A profile identified as <code>home_profile.yaml</code> imports another one identified
              as <code>circular_profile.yaml</code>:</p>
            <tagging whose="source_profile"><![CDATA[
profile:
  id: "home_profile.yaml"
  metadata: ~~~
  imports:
    - href: "circular_profile.yaml"
      include-controls: ${{ list of selected controls }} ]]></tagging>
            <p>In turn this file invokes <code>home_profile.xml</code>:</p>


            <tagging whose="source_profile"><![CDATA[
profile:
  id: "circular_profile.yaml"
  metadata: ~~~
  imports:
    - href: "home_profile.yaml"
      include-controls: ${{ list of selected controls }} ]]></tagging>
            <p>Once detected, this circular import will result in an error and no further processing
              will take place.</p>
            <tagging whose="target_catalog"><![CDATA[
  # Import at href: "circular_profile.yaml" failed.
  # Reason: Error during profile import:
  # Import at href: "home_profile.yaml" failed.
  # Reason: Circular import ]]></tagging>
          </mapping>
        </section>

        <section id="URI-multiple">
          <head>Multiple imports</head>
          <p>Each import directive is processed to produce a set of controls. Note that this occurs
            even if the same catalog is imported multiple times: each distinct import collects
            controls into a separate <int>selection</int>:</p>

          <tagging whose="source_profile"><![CDATA[
profile:
  uuid: ~~~
  metadata: ~~~
  imports:
    - href: "#catalog"
      include-controls:
       - with-ids:
          - ac-1
          - ac-2
    - href: "#catalog"
      include-controls:
       - with-ids:
          - ac-3
          - ac-4 ]]>
          </tagging>

          <tagging whose="inter_catalog"><![CDATA[
intermediate:
  metadata: ~~~
  selections:
    - id: ${{uuid of #catalog}}
      included-controls:
          - ac-1
          - ac-2
    - id: ${{uuid of #catalog}}
      included-controls:
          - ac-3
          - ac-4 ]]>
          </tagging>

          <p>The control selections are combined and collapsed in the next phase of processing,
              <term>merge</term> (see below) .</p>
          <p>Multiple imports may result in outputs with clashing controls (see below). Typically
            this will be because a control has been selected twice (in selection or in the
            selections of underlying profiles), and no merge behavior has been indicated to resolve
            the clash.</p>
          <p>Typical cases of multiple imports of the same (underlying) resource will be when a
            profile A imports another profile B, which calls catalog Z, and then profile A calls
            catalog Z again to acquire other controls not included in profile B, or in an original
            form unmodified by profile B.</p>
        </section>
      </section>

      <section id="select-phase">
        <head>Including Controls</head>
        <p>Each import contains directives on which parts of the imported Catalog are to be
          included. Throughout the rest of this document, we will refer to "explicit" vs "implicit"
          inclusion. Explicit Inclusion refers to anything that has been referenced directly by any
          of the below directives. Implicit Inclusion refers to objects that have been included due
          to other circumstances, but that have not been referenced by the inclusion directives. </p>

        <p>It is RECOMMENDED that implementations track which objects are explicitly included vs
          implicitly included as the intermediate is built out. This information is required to be
          used during the pruning process <xref rid="cleanup"/>. </p>
        <section id="include-all">
          <head>include-all</head>
          <p>When an import provides the <src>include-all</src> directive, all controls in the
            referenced document (including nested controls <xref rid="import-nested"/>) MUST be
            explicitly included:</p>

          <tagging whose="source_profile">include-all: ~ </tagging>

          <p>Under the <src>include-all</src> directive, all non-control children of controls MUST
            be explicitly included.</p>
          <!-- TODO: protect otherwise unused params of explictly selected controls? What about other child objects?-->
          <p>Under the <src>include-all</src> directive, all "loose params" <xref rid="import-param"
            /> MUST be explicitly included.</p>
          <!-- TODO: loose params under include-all, carried over or not? -->
        </section>
        <section id="include-by-id">
          <head>include-controls plus with-id</head>
          <p>When an import provides the <src>include-controls</src> directive, with a
              <src>with-id</src> child, all controls in the referenced document whose
              <code>id</code> match one of the listed <code>id</code> values MUST be explicitly
            included:</p>
          <tagging whose="source_profile"><![CDATA[
include-controls:
  - with-ids:
    - id: ac-1
    - id: ac-2]]>
          </tagging>
          <p>Using "with-id", all non-control children of included controls MUST also be explicitly
            included.</p>
          <!-- TODO: protect otherwise unused params of explictly selected controls? What about other child objects?-->
        </section>
        <section id="include-by-match">
          <head>include-controls plus matching</head>
          <p>Controls may also be included using match patterns against their IDs. This is useful
            because related controls (either in a hierarchy, or together in a group) frequently have
            related IDs as well.</p>
          <p>When an import provides the <src>include-controls</src> directive, with a
              <src>matching</src> child, all controls in the referenced document whose
              <code>id</code> matches one of the listed <code>pattern</code> values (Glob matching)
            MUST be explicitly included:</p>
          <p>If a <code>matching</code> element is provided with no <code>pattern</code>, it MUST be
            treated as matching nothing.</p>

          <tagging whose="source_profile"><![CDATA[
include-controls:
  - matching:
    - pattern: "ac*" ]]></tagging>

          <p>Using "matching", all non-control children of included controls MUST also be explictly
            included.</p>
          <!-- TODO: protect otherwise unused params of explictly selected controls? What about other child objects?-->
        </section>

        <section id="include-child-controls">
          <!-- TODO: followup on param issues above. Is "include-params" needed? What about other child objects of controls?  -->
          <head>with-child-controls</head>
          <p>In OSCAL, controls may contain controls. For example, in SP 800-53 many controls are
            supplemented with control enhancements; in OSCAL these are represented as child controls
            within parent controls. So parent AC-2 (in a given catalog) has children AC-2(1) through
            AC-2(13), for example.</p>
          <p>Child controls can be included by the same mechanism as controls, i.e. by means of an
            ID call. Alternatively a match can frequently be applied (at least given most ID
            assignment schemes) to match controls and child controls together.</p>

          <p> A <src>with-child-controls: yes</src> directive on an <src>include-controls</src>
            indicates that <em>all descendant controls </em> of the explictly included control MUST
            also be explicitly included. </p>

          <p> A <src>with-child-controls: no</src> directive on an <src>include-controls</src>
            indicates that ONLY the explicitly matching control is explicitly included, any
            descendants are not included. </p>

          <p> If no <src>with-child-controls</src> is provided, the processor MUST consider the
            directive as being equivalent to one having <src>with-child-controls:yes</src>. </p>
          <!-- TODO: is this the correct default behavior? -->

        </section>

        <section id="exclude-directive">
          <head>exclude-controls</head>
          <p>Exclusions work the same way as inclusions, except with the opposite effect - the
            indicated control(s) do not appear in the target catalog.</p>
          <p>Any control designated to be both included and excluded, MUST be excluded. This holds
            irrespective of the specificity of the selection for inclusion or exclusion. For
            example, if AC-1 is included by id <code>ac-1</code> and excluded by matching
              <code>ac.*</code>, it is excluded. Selection for exclusion prevails.</p>
          <p><src>exclude-controls</src> will also have at least one <src>with-ids</src> and
              <src>matching</src> directive, the processor MUST follow the same rules as defined in
            the above sections for these directives, but exclude instead of include any
            controls.</p>
        </section>
        <section id="redundant-calls">
          <head>Redundant Inclusions</head>
          <p><src>with-id</src> and <src>matching</src> may be combined in a single import. Their
            effect is cumulative; any control that is included by both <src>with-id</src> and
              <src>matching</src> from a given <src>include-controls</src> directive, or by matching
            more than one pattern, MUST be included only once (unless it is also marked for
            exclusion, see <xref rid="exclude-directive"/>). This applies to both explicit and
            implicit inclusion.</p>
          <p>Note that this requirement only applies to controls included within the context of a
            single import. Controls with duplicate IDs included with a different "import" are not
            discarded.</p>
        </section>

        <section id="import-groups">
          <head>Handling Groups</head>
          <p>Catalogs are sometimes organized using the <src>groups</src> structure, which brings
            controls and other data into one logical grouping. </p>
          <p>In the Import Phase, the Processor MUST search all <src>groups</src> for controls when
            executing inclusion and exclusion directives. This includes nested groups.</p>
          <p>If a control inside a <src>group</src> is selected, the parent <src>group</src> and all
            of it's non-control, non-group children MUST be implicitly included. This applies
            recursively if the parent group has a parent group, until the top level group has been
            implicitly included in this way as well.</p>
          <p>If a parent group is to be implicitly included by the above requirement, but has
            already been implicitly included within the same import statement, the control MUST be
            placed into that group instead. </p>
        </section>
        <section id="import-nested">
          <head>Handling Nested Controls</head>
          <p>Controls are sometimes nested under other controls, with varying levels of dependencies
            between them. </p>
          <p>If a control inside a <src>control</src> is selected, the parent <src>control</src> and
            all of it's non-control children MUST be implicitly included. This applies recursively
            if the parent control has a parent control, until the top level control has been
            implicitly included in this way as well.</p>
        </section>
        <section id="import-param">
          <head>Handling Params</head>
          <p>Any <src>param</src> that is not directly under a control is referred to as a
              <q>loose</q> param. </p>
          <p>All loose params from both imported documents and the profile source MUST be included
            implicitly. Enterprising implementations may consider pruning unused params at this
            point <xref rid="cleanup"/>, but care should be taken to not prune future needed
            params.</p>
        </section>
      </section>
      <section id="mapping">
        <head>Mapping Controls</head>
        <p>The optional "mapping" child of a given "import" provides a simple ID remapping for
          objects included from that specific import. This provides the means for profile authors to
          proactively avoid clashing IDs of controls and other objects. </p>
        <p>The Mapping section consists of 5 optional subsections, each covering a particular type
          of object. Each subsection is a list of ID mappings to be applied for objects that are the
          parent object type.</p>
        <p>When encountering a given mapping instruction, processors:</p>
        <ul>
          <li>
            <p>MUST locate the included object in the intermediate whose distinctive ID matches the
              value of the "from" object and whose object type is the same as the name as the
              parent. If none is found, the processor SHOULD provide a warning, but MAY continue
              processing. In the case there are more than one included objects of the specified type
              with the same distinctive ID, behavior is unspecified, as this means the source
              catalog was malformed.</p>
          </li>
          <li>
            <p>MUST change the distinctive ID of that object to be equal to the value of the "to"
              object.</p>
          </li>
          <li>
            <p>SHOULD from this point forward only consider (or even be aware of) the new value of
              that object's distinctive ID.</p>
          </li>
        </ul>
        <p>Since mapping is a self contained process inside each import, the rest of this
          specification will continue to reference IDs with the assumption that mapping has already
          been applied if it was present. Since mapping is most commonly used to avoid clashing IDs,
          processors should take care to not handle duplicate IDs until after mapping is
          complete.</p>
      </section>
      <section id="import-wrap-up">
        <head>Wrapping up the Import Phase</head>
        <p>At this point the processor should have an intermediate that contains: a set of explictly
          included controls and all of their child informational (non-control, non-group) objects; a
          set of implictly included controls and groups that were parents of the previous (zero to
          many); and a set of implictly included "loose params" <xref rid="import-param"/> (zero to
          many).</p>

        <p>The general structure of explictly included controls should match that of those controls
          in the imported catalogs (i.e. Nested controls remain nested, grouped controls remain
          grouped).</p>

      </section>
    </section>
    <section id="merge-phase">
      <head>Merge Phase</head>
      <p>Profiles may contain a <src>merge</src> section, where directives are given to instruct the
        processor how to combine the set of included objects collected during the Import Phase.
          <code>merge</code> has two parts: a "combine" directive, and a "structuring"
        directive.</p>
      <p>It is RECOMMENDED that tools apply the "combine" directive to the intermediate generated by
        the Import phase first, then apply the "structuring" directive.</p>
      <section id="merge-combine">
        <head>The "combine" Directive</head>
        <!-- TODO: Suggestion: "combine->method" is pointless to have as a parent-child relationship. Meld into one object: "combine-method". -->
        <p><code>combine</code> is an optional child of <code>merge</code> that provides the rules
          for dealing with objects that have duplicate (or clashing) distinct IDs <xref rid="id"
          />.</p>
        <p>There are two valid combination methods provided by OSCAL, provided by the
            <src>method</src> child of <src>combine</src>: </p>

        <ul>
          <li>
            <p>use-first: Use the first definition - the first control with a given ID is used;
              subsequent ones are discarded</p>
          </li>
          <li>
            <p>keep: Keep - controls with the same ID are kept, retaining the clash</p>
          </li>
          <li>
            <p>merge: Deprecated.</p>
            <!-- TODO: How to handle this? Model needs updated. -->
          </li>
        </ul>

        <p>In order to apply the combination method, IDs of each control explicitly included are
          compared against one another. As IDs are unique across entire OSCAL documents, different
          imports or any groupings have no bearing on collision. Processing requirements for each
          method are described below.</p>

        <section id="no-merge-explicit">
          <head>No Combine Directive</head>
          <p>If no <src>merge</src> directive is given in the profile, or if a <src>merge</src> is
            given without a <src>combine</src>, merge conflicts MUST be treated as if <src>method:
              keep</src> was given. For example, a profile with no <src>merge</src> directive:</p>
          <tagging whose="source_profile"><![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-all: ~ ]]></tagging>
          <p>is the same as</p>
          <tagging whose="source_profile"><![CDATA[
profile:
  imports:
    - href: #catalogURI
      include-all: ~
  merge:
    combine:
      method: keep ]]></tagging>
          <mapping unit-test="profile-resolution-examples/merge-implicit-keep_profile.xml"/>
        </section>
        <section id="no-merge-combination-rule">
          <head><q>method:keep</q></head>
          <p>When a merge is indicated by <src>method:keep</src>, or not given, the <q>keep</q>
            combination rule is used. Any objects with the same distinctive ID <xref rid="id"/> MUST
            NOT not merged. (They are kept.)</p>
          <tagging whose="source_profile"><![CDATA[
  merge:
    combine:
      method: keep ]]></tagging>
          <p>Under this directive, colliding controls will result in invalid results, as they will
            both appear in the results with the same ID. Accordingly, this setting may be useful in
            ensuring integrity of references to controls as given in the profile: if any included
            control is called only once, clashing controls will not be produced and validation will
            succeed.</p>
          <mapping unit-test="profile-resolution-examples/merge-keep_profile.xml">
            <tagging whose="source_profile"><![CDATA[
profile:
  imports:
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2 
  merge:
    combine:
      method: keep]]></tagging>
            <p>In the intermediate (showing control selections):</p>
            <tagging whose="inter_catalog"><![CDATA[
intermediate:
  inclusions:
    - explicitly-included-controls:
          - ac-1
          - ac-2
          - ac-1
          - ac-2 ]]></tagging>
          </mapping>
          <p>In this case, downstream errors should be expected: the two <code>ac-1</code> controls
            clash with each other, as do the two <code>ac-2</code> controls.</p>
          <p>Processors SHOULD provide a warning under this directive when duplicate controls are
            detected. The processor MAY throw an error and cease processing (short-circuiting a
            certain future error). </p>
        </section>
        <section id="use-first-combination-rule">
          <head><q>method:use-first</q></head>
          <tagging whose="source_profile"><![CDATA[
  merge:
    combine:
      method: use-first ]]></tagging>
          <p>When the <q>use-first</q> combination rule is applied, the first reference to a given
            control, with respect to the document order of the source data, MUST be included over
            later references. <q>First</q> MUST be determined by a top-down, depth-first traversal
            of the profile import hierarchy. </p>
          <mapping unit-test="profile-resolution-examples/merge-keep_profile.xml">
            <tagging whose="source_profile"><![CDATA[
profile:
  imports:
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-3
    - href: #catalog1
      include-controls:
        - with-ids
            id: ac-1
            id: ac-2 
  merge:
    combine:
      method: use-first]]></tagging>
            <p>In the intermediate(showing control selections):</p>
            <tagging whose="inter_catalog"><![CDATA[
intermediate:
  inclusions:
    - explicitly-included-controls:
          - ac-1 (From catalog1)
          - ac-3
          - ac-2 ]]></tagging>
          </mapping>
        </section>
        <section id="merge-combination-rule">
          <head>"method:merge"</head>
          <p>Deprecated.</p>
          <!--
          <tagging whose="source_profile"><![CDATA[
  merge:
    combine:
      method: merge ]]></tagging>
          <p>When the <term>merge</term> combination rule is applied, the processor will merge all
            representations of a given control, as distinguished by ID, into a single unified
            representation.</p>
          <p>Processors MUST adhere to the following requirements for the <src>method:merge</src>
            directive for any given control:</p>
          <ul>
            <li>
              <p>The first time a given control is encountered, the control and all elements inside
                it are kept.</p>
            </li>
            <li>
              <p>For all subsequent encounters with the same control, any duplicate of a distinctive
                element <xref rid="id"/> is discarded, regardless of any difference in content.</p>
            </li>
            <li>
              <p>"First" is determined in the same way as in <xref rid="use-first-combination-rule"
                />, by order of the source document.</p>
            </li>
            <li>
              <p>At the conclusion of merging the control, it's contents are reordered according to
                  <term>canonical order</term>.</p>
            </li>
          </ul>
          <p>Example:</p>
          <tagging whose="source_catalog"><![CDATA[
  control:
    id: ac-1
    title: Control ac-1
    props:
      - name: label
        value: ac-1
      - name: status
        value: ready ]]></tagging>
          <p>merging with</p>
          <tagging whose="source_catalog"><![CDATA[
  control:
    id: ac-1
    title: Control ac-1
    props:
      - name: marking
        value: unclassed
      - name: label
        value: ac-1
      - name: status
        value: pending ]]></tagging>
          <p>produces</p>
          <tagging whose="target_catalog"><![CDATA[
  control:
    id: ac-1
    title: Control ac-1
    props:
      - name: marking
        value: unclassed
      - name: label
        value: ac-1
      - name: status
        value: ready ]]></tagging>
          <p>Note that groups are not merged by this rule; for that purpose, <src>as-is</src> or
              <src>custom</src> should be used (in addition to the combine directive) <xref
              rid="structuring-result"/>.</p>
          <p>Since the effect of this merge rule is to drop data silently (when it is considered to
            be redundant or duplicative), it should only be used on well-understood, well-controlled
            catalog and profile inputs, whose potential clashes or collisions are known in
            advance.</p>
        </section>
        <section id="combining-other">
          <head>Combination Rules with Other Data</head>
          <p>When profiles import from more than one resource (catalog or profile), not only is
            there a potential for clashing controls, but also groups, params, and backmatter.</p>
          <p>If no structuring directives are given, the processor MUST merge all other data using
            the given merge directive, following the rules given for controls, but applied to each
            element.</p>
          <p>With many imports or large catalogs, errors or data loss is likely. This is
            particularly likely in backmatter resources that are grouped under single distinctive
            keys, such as citations. The processor SHOULD provide warnings when non-control data is
            lost as part of a merging process.</p>

          -->
        </section>
      </section>
      <section id="structuring-result">
        <head>The "structuring" Directive</head>
        <p>This section describes how a profile may dictate the body of the target
            <tgt>catalog</tgt>, apart from its <tgt>metadata</tgt> or <tgt>back-matter</tgt>.</p>
        <p>The <src>merge</src> element, in addition to proposing a strategy by which to
          disambiguate clashing controls, also includes directives that can be used to organize the
          target catalog into a structure or hierarchy of groups. Two <src>merge</src> directives
          are used to introduce structure into the target catalog, <src>as-is</src> and
            <src>custom</src>. If neither is given, no structure is provided: parameters and
          controls in the target appear in sequence, with no structure or grouping apart from what
          is internal to the controls</p>
        <section id="merge-flat">
          <head>No Structuring Directive</head>
          <p>Profiles that have neither of these directives are resolved as unstructured catalogs,
            with no groupings of controls.</p>
          <p>Unstructured catalog output MUST be produced by adhering to the following requirements: </p>

          <ul>
            <li>
              <p>All selected controls are output to the target as a flat list. Nested controls MUST
                be flattened (parents and children will be on the same level under catalog). </p>
            </li>
            <li>
              <p>All loose <src>params</src> (params not directly under a control) are output to the
                target.</p>
            </li>
            <li>
              <p>Any groups automatically selected in the Import Phase MUST be flattened, and group
                metadata discarded. Any control contents MUST be merged according to the merge
                method. The processor SHOULD provide a warning if groups are being flattened under
                this directive.</p>
            </li>
            <li>
              <p>Backmatter of source documents are included and merged according to <xref
                  rid="target-back-matter"/> and the merge combination rule.</p>
            </li>
            <li>
              <p>Metadata of source documents are included and merged according to <xref
                  rid="target-metadata"/> and the merge combination rule.</p>
            </li>
            <li>
              <p>At the conclusion of the previous steps, the target catalog's contents are
                reordered according to <term>canonical order</term>.</p>
            </li>

          </ul>

          <tagging whose="target_catalog"> </tagging>
          <!-- TODO: Example -->
        </section>
        <section id="merge-as-is">
          <!--TODO Behavior change? content inclusion during as-is merge: nested controls, groups -->
          <head><q>as-is</q></head>
          <p>An <src>as-is</src>directive is used to reproduce the structure of the source documents
            in the target catalog. </p>
          <p>Processors MUST handle the <src>as-is</src>directive by adhering to the following
            requirements: </p>

          <ul>
            <li>
              <p>All selected controls are output to the target, keeping the groups and nested
                controls that were auto-included during the Import Phase. Controls keep their
                location and structure from the source documents (collected as part of import).</p>
            </li>
            <li>
              <p>All loose <src>params</src> (params not directly under a control) are output to the
                target.</p>
            </li>
            <li>
              <p>Backmatter of source documents are included and merged according to <xref
                  rid="target-back-matter"/> and the merge combination rule.</p>
            </li>
            <li>
              <p>Metadata of source documents are included and merged according to <xref
                  rid="target-metadata"/> and the merge combination rule.</p>
            </li>
            <li>
              <p>At the conclusion of the previous steps, the target catalog's contents are
                reordered according to <term>canonical order</term>.</p>
            </li>
          </ul>

          <p>Example:</p>
          <!--TODO: Example. Also this section is easy because of import rework -->
          <tagging whose="source_catalog"/>
          <p>In this case the profile does not designate either control <code>xyz-1</code> or
            control <code>xyz-1.2</code> for inclusion</p>
          <tagging whose="source_profile"/>
          <p>The unmentioned elements are included, however, with their titles, because controls
            that they contain are included. But control <code>xyz-1.3</code> does not appear in the
            target.</p>
          <tagging whose="target_catalog"/>
          <p>Note that this means there may be controls that are selected implicitly by
              <src>as-is</src> merging, over and above controls actually designated in import
            statements. Thus the control set, considered strictly, of the target of an
              <src>as-is</src> process, will be different from the control set delivered by a <q>no
              merge</q> process.</p>
          <p>Processors may optionally provide services for detection of nesting and structural
            issues related to the importing and merging of controls, including but not limited to
            validation / detection utilities (for imports regarded as incorrect, incomplete or
            otherwise subject to improvement); runtime warnings; or user interfaces.</p>
        </section>
        <section id="merge-custom">
          <head><q>custom</q></head>
          <p>The <src>merge/custom</src> directive provides a way to provide a target catalog with a
            custom structure. It combines <src>include-controls</src> directives, which indicate
            only the controls to be included, into groups, which provide the target with its
            structure.</p>
          <p>The controls to be organized are already selected in the Import Phase. A with-id or
            matching appearing inside <src>custom</src>, if it refers to controls not selected, MUST
            be ignored by the processor.</p>
          <p>The structures given inside <src>custom</src> provide a one-to-one mapping of the
            structure of the target catalog. Unlike <q>as-is</q> merging, there is no implicit
            inclusion of controls by virtue of including descendant controls. Instead, all controls
            are included in the target in the locations indicated by the custom structure.</p>
          <section id="custom-groups">
            <head>Grouping controls inside a custom structure</head>
            <p>A <src>group</src> element given in a custom structure results in a <tgt>group</tgt>
              with the same title and ID in the target. </p>

            <p>If the ID of the group matches the ID of a group that exists in a source document,
              all element contents inside the group, including <src>title</src>, <src>param</src>,
                <src>prop</src> and <src>part</src> elements MUST be copied into the target,
              appearing in the same order as in the source.</p>
            <p>Within <src>custom</src>, <src>include-controls</src> reference controls in much the
              same way as they do when given in <src>import</src> - a control is identified by
                <src>id</src> using <src>with-id</src> or by a pattern match using
                <src>matching</src>).</p>
            <p>A <src>with-id</src> results in including, at that point inside the new grouping,
                <em>all</em> controls with the <src>id</src> given by the <src>with-id</src>. They
              should be given in the same order as they appear in the control selection(s). Note
              that <term>merge combination rules</term> apply, so depending on settings, conflicts
              between controls with the same <src>@id</src> may be resolved. <xref
                rid="merge-combine"/></p>
            <p>A <src>matching</src> directive results in including, at that point inside the new
              grouping, all controls whose <src>id</src> matching, as an XPath regular expression,
              the pattern given in the <src>pattern</src>. They are given in the same order as they
              appear in the input control selection(s). Again, among clashing controls (that have
              the same ID), merge combination rules apply. <xref rid="merge-combine"/></p>
            <p><src>Custom</src> can also indicate the order that the selected controls are to be
              emitted in the result catalog using an <src>order</src> child. Three values MUST be
              supported:</p>
            <ul>
              <li>
                <p><code>ascending</code> will sort all included controls, whether selected by
                    <src>with-id</src> (literal ID) or <src>matching</src> (matching ID to glob
                  expression), into ascending alphanumeric order. <revisit>collation
                    guidance?</revisit></p>
              </li>
              <li>
                <p><code>descending</code> will sort all included controls, whether selected by
                    <src>with-id</src> (literal ID) or <src>matching</src> (matching ID to glob
                  expression), into descending alphanumeric order.</p>
              </li>
              <li>
                <p><code>keep</code> indicates that controls should be inserted in the order of
                  their appearance, first among import selections, then in the order they appear in
                  their (imported) catalog source.</p>
              </li>
            </ul>
            <mapping>
              <tagging whose="source_profile">example here</tagging>
              <tagging whose="target_catalog">example here</tagging>
              <p>In this example, control <code>a2</code> does <em>not</em> appear in the target
                catalog, as a custom structure was indicated (by the presence of the source profile
                  <src>merge/custom</src>), but the control never referenced from inside an
                  <src>insert-controls</src> directive in the custom structure.</p>
              <p>When a custom structure references a control that is not included in any control
                selection (in the import phase), the reference is inoperative. A processor may
                signal a warning in this case.</p>
              <p>Similarly, no error occurs if a control is selected (appears in a control selection
                or even more than one), but it is never referenced from the <src>custom</src>
                structure given. The control does not appear in the target catalog. Again, a
                processor may optionally signal a warning if this occurs.</p>
            </mapping>
            <mapping>
              <tagging whose="source_profile">example here</tagging>
              <tagging whose="target_catalog">example here</tagging>
              <p>In this case, no <tgt>group</tgt> container appears in the target for the controls
                  <code>b2</code> and <code>c2</code>; because they appear unwrapped before the
                  <src>group</src> in the profile source, they appear the same way in the target
                catalog. Control <code>c2</code>, however, appears in a subgroup <code>group2</code>
                inside the group with ID <code>group1</code> , again reflecting the source
                organization. Note also that <src>@id</src> flags are copied.</p>
              <p>Again, no provision is made to prevent duplicate or colliding controls from
                appearing. Optionally, a processor may signal warnings when it determines that
                controls from selections are designated to appear in the results more than once, due
                to multiple colliding occurrences of <src>include-controls/with-id</src> and
                  <src>include-controls/matching</src> inside <src>custom</src>.</p>
            </mapping>
          </section>
        </section>
      </section>
    </section>
    <section id="modify-phase">
      <head>Modify Phase</head>
      <p>There are two ways a control may need to be modified. Commonly, controls might be amended –
        new material might be added. Less commonly, materials might be removed or edited.</p>
      <p>In addition to any modification or adjustment to controls, this section of a profile is
        used to set parameter values or other properties of parameters declared in catalogs and
        referenced from their text. Parameters are propagated from the Import Phase.</p>
      <section id="param-setting">
        <head>Setting Parameters</head>
        <p>Modification of parameter settings is indicated using <src>set-parameter</src>.</p>
        <p>Parameters are not always given within controls. A profile resolution target must include
          copies (with or without modifications or settings) of all parameters defined within the
          source catalog, which are referenced from <src>insert</src> directives anywhere inside
          included controls.</p>
        <p>Accordingly, any parameter referenced by an <src>insert</src> in any source catalog is
          copied from catalog source to target <revisit>parameter propagation rules for merge/as-is,
            merge/custom</revisit> without any configuration required in the profile.</p>
        <p>However, a profile should not reproduce parameters from source catalogs, which are not
          referenced from <src>insert</src> directives.</p>
        <p>When parameters are propagated, they may be modified by <src>set-parameter</src>
          directives given in the profile.</p>
        <p>If more than one <src>set-parameter</src> directive is given for the same parameter, all
          are applied, in the sequence given in the profile.</p>
        <ul>
          <li>
            <p>A <src>set-parameter:label</src> replaces the <src>param:label</src> on the affected
              parameter</p>
          </li>
          <li>
            <p>A <src>set-parameter:value</src>
              <em>or</em> a <src>set-parameter:select</src> replaces <em>any</em>
              <src>param:value</src> or <src>param:select</src> on the affected parameter</p>
          </li>
          <li>
            <p>Other elements given in a <src>set-parameter</src> are added to the affected
              parameter, after elements of the same name</p>
          </li>
          <li>
            <p>The prescribed order of elements in the affected parameter is retained:
                <tgt>label</tgt>; <tgt>usage</tgt>; <tgt>constraint</tgt>; <tgt>guideline</tgt>;
                <tgt>value</tgt> or <tgt>select</tgt> (a choice); and <tgt>link</tgt>.</p>
          </li>
        </ul>

        <p>Note that <tgt>select</tgt> replaces <src>value</src>:</p>
        <tagging whose="target_catalog">example here </tagging>
        <section>
          <head>Setting a missing parameter</head>
          <p>A <src>set-parameter</src> directive whose <src>param-id</src> does not correspond to
            any parameter in the resolved catalog, is inoperative.</p>
          <p>A processor MAY issue a warning where such directives are found.</p>
        </section>
      </section>
      <section id="control-altering">
        <head>Altering controls</head>
        <p>A control can be altered by an <src>alter</src> directive on a control. The
            <src>control-id</src> flag on the <src>alter</src> indicates the control to which the
          alteration is applied.</p>
        <section id="add-directive">
          <head>Adding contents to controls</head>
          <p>Contents may be added to controls using an add directive inside an alter directive.
            There are two forms of alteration: with implicit and explicit bindings.</p>
          <section id="add-to-control">
            <head>Implicit binding</head>
            <p>An <src>add</src> directive with no <src>id-ref</src> flag is taken to apply to the
              control as a whole. Its <src>position</src> flag may be either of two values:
                <code>starting</code> and <code>ending</code>.</p>
            <p>The contents of the add directive are then added to the control contents in the
              target, either after its <tgt>title</tgt> when <src>position</src> is
                <code>starting</code>, or at the end if its position is <code>ending</code>, or not
              given.</p>
            <p>However, control contents in catalogs must appear in the order <code>title, param,
                prop, link, part, control</code>. Subsequent to adding new elements, the control
              contents are sorted to appear in the required order. As a consequence, a new
                <tgt>prop</tgt> appears after any <src>prop</src> already in the control, when
                <src>position</src> is <code>ending</code>, or not given,, or before any
                <src>prop</src> in the control when <src>position</src> is
              <code>starting</code>.</p>
            <p>When add has no <src>@ref-id</src> (has an implicit binding), the <src>position</src>
              values <code>before</code> and <code>after</code> are treated like
                <code>starting</code> and <code>ending</code>, respectively. <revisit>The schema
                permits these values.</revisit></p>
            <mapping>
              <p>An addition operating on a control with implicit binding and position
                  <code>starting</code></p>
              <tagging whose="source_catalog">&lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="status" value="ready"/>
                &lt;/control></tagging>
              <tagging whose="source_profile">&lt;alter control-id="a1"> &lt;add
                position="starting"> &lt;prop name="basis" value="enumerated"/> &lt;part
                name="caution">&lt;p>Pending scheduled testing.&lt;/p>&lt;/part> &lt;/add>
                &lt;/alter></tagging>
              <tagging whose="target_catalog">&lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="basis" value="enumerated"/> &lt;prop
                name="status" value="ready"/> &lt;part name="caution">&lt;p>Pending scheduled
                testing.&lt;/p>&lt;/part> &lt;/control></tagging>
              <p>Position is <code>starting</code> but the new <tgt>part</tgt> is added after the
                existing <tgt>prop</tgt>, because <tgt>prop</tgt> elements must always occur
                first.</p>
            </mapping>
            <mapping>
              <p>An addition operating on a control with implicit binding and position
                  <code>ending</code></p>
              <tagging whose="source_catalog">&lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="status" value="ready"/>
                &lt;/control></tagging>
              <tagging whose="source_profile">&lt;alter control-id="a1"> &lt;add position="ending">
                &lt;prop name="basis" value="enumerated"/> &lt;part name="caution">&lt;p>Pending
                scheduled testing.&lt;/p>&lt;/part> &lt;/add> &lt;/alter></tagging>
              <tagging whose="target_catalog">&lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="status" value="ready"/> &lt;prop name="basis"
                value="enumerated"/> &lt;part name="caution">&lt;p>Pending scheduled
                testing.&lt;/p>&lt;/part> &lt;/control></tagging>
              <p>The <src>add/@position</src> is <code>ending</code> so the new <tgt>prop</tgt>
                appears after the existing <tgt>prop</tgt>.</p>
            </mapping>
          </section>
          <section id="add-to-element">
            <head>Explicit binding</head>
            <p>An explicit binding on an addition permits inserting new contents anywhere in a
              control, not only at the top level. It is given by a <src>@ref-id</src> flag on the
                <src>add</src> directive. The value of the <src>@ref-id</src> must correspond to the
              value of an <src>@id</src> flag on an element inside the control, and not the control
              itself. If <src>ref-id</src> does not correspond to such a value, the <src>add</src>
              directive is inoperative. Optionally, a warning may be issued in such a case.</p>
            <p>The element with <src>@id</src> equal to the <src>@ref-id</src> is considered the
                <term>target</term> of the addition.</p>
            <p>Additionally, with an explicit binding given by a <src>@ref-id</src>,
                <src>@position</src> may have any of the values <code>starting</code>,
                <code>ending</code>, <code>before</code> and <code>after</code>.</p>
            <p>When <src>position</src> is <code>starting</code> or <code>ending</code>, the new
              contents are added at the beginning or ending of the target element, inside that
              element, as are additions into controls (using implicit bindings).</p>
            <p>Additionally, a <src>position</src> given as <code>before</code> indicates the
              addition should be made directly before the target element, while <code>after</code>
              indicates the addition should appear directly after the target element.</p>
            <p><revisit>Unlike additions with implicit bindings, an explicit binding does not
                provide for sorting of newly added elements to ensure correct ordering.
                Consequently, profile authors must take care that additions they make into control
                contents using explicit bindings will produce results valid to the catalog
                schema.</revisit></p>
            <mapping>
              <p>An addition operating on a control with explicit binding and position
                  <code>after</code></p>
              <tagging whose="source_catalog">&lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="status" value="ready"/> &lt;part id="a1.b"
                name="recommendations"> &lt;part id="a1.b1">&lt;p>Collect recycling for
                pickup.&lt;/p>&lt;/part> &lt;part id="a1.b2">&lt;p>Sweep surfaces free of
                dust.&lt;/p>&lt;/part> &lt;/part> &lt;/control></tagging>
              <p>Note that the <src>add</src> directive identifies the element with <src>@id</src>
                <code>a1.b1</code> as its target.</p>
              <tagging whose="source_profile">&lt;alter control-id="a1"> &lt;add position="after"
                ref-id="a1.b1"> &lt;prop name="basis" value="allocated"/> &lt;part
                name="caution">&lt;p>Unavailable on weekends.&lt;/p>&lt;/part> &lt;/add>
                &lt;/alter></tagging>
              <tagging whose="target_catalog">&lt;control id="a1"> &lt;title>Basic
                precautions&lt;/title> &lt;prop name="status" value="ready"/> &lt;part id="a1.b"
                name="recommendations"> &lt;part id="a1.b1">&lt;p>Collect recycling for
                pickup.&lt;/p>&lt;/part> &lt;prop name="basis" value="allocated"/> &lt;part
                name="caution">&lt;p>Unavailable on weekends.&lt;/p>&lt;/part> &lt;part
                id="a1.b2">&lt;p>Sweep surfaces free of dust.&lt;/p>&lt;/part> &lt;/part>
                &lt;/control></tagging>
              <p>The <src>position</src> is <code>after</code> so both elements inside
                  <src>add</src> are added after (not inside) the target element. Since the target
                element is inside another <tgt>part</tgt> in the control, the new additions appear
                there as well.</p>
              <p>Note that the result in this case will be schema-invalid since a <tgt>prop</tgt>
                may not occur directly following a <tgt>part</tgt>. A better result can be obtained
                (a better target may be defined) by using two <src>add</src> directives, to insert
                the new <tgt>prop</tgt> separately before any <tgt>part</tgt> elements in the
                target.</p>
            </mapping>
          </section>
          <section>
            <head>Usage of <src>add</src> directives modifying controls inside controls</head>
            <p>OSCAL supports control extensions inside controls in the form of <src>control</src>
              elements inside <src>control</src> elements. Because the semantics of the
                <src>add</src> directive target any (element) contents of controls, they can be used
              to target these control extensions for modification as well as other contents.</p>
            <p>Because such a control can already be modified using implicit bindings, it is
              recommended that they not be targeted with explicit bindings. Using an implicit
              binding supports more robust alteration since contents in the target can be ordered
              properly by the resolution processor. <revisit>XXX can we guarantee valid results here
                and do we have to specify a sort/order?</revisit> However, it is not an error to
              target control elements in this way, manipulating them in the same way as other
              targets may be manipulated.</p>
          </section>
        </section>
        <section id="remove-directive">
          <head>Removing contents from controls</head>
          <p>Contents inside controls can be removed from them in catalog targets. In combination
            with adding new contents, this feature can be used to edit controls as well as amend
            them.</p>
          <p>A <src>remove</src> directive inside an <src>alter</src> directive identifies an
            element or set of elements inside a control to be removed. It does this using any of
            five flags. Flag are <em>additive</em>; that is, if more than flag is given, all must
            match.:</p>
          <ul>
            <li>
              <p><src>@id-ref</src>, like <src>add/@id-ref</src>, matches an element by its
                  <src>@id</src> value.</p>
              <p>Because <src>@id</src> values are unique, the remove directive will remove only a
                single element. Ordinarily this would not combined with other identifiers for
                removal.</p>
            </li>
            <li>
              <p><src>@name-ref</src> keys to the <src>@name</src> attribute on any element inside
                the control.</p>
              <p>Any element inside the control with the assigned <src>name</src>, is removed
                (typically providing there is also a match on <src>@ns</src>).</p>
            </li>
            <li>
              <p><src>@ns-ref</src> keys to the <src>@ns</src> attribute on any element inside the
                control.</p>
              <p>Any element inside the control with the assigned <src>name</src>, is removed
                (typically providing there is also a match on <src>@name</src>).</p>
            </li>
            <li>
              <p><src>@class-ref</src> keys to the <src>@class</src> attribute on any element inside
                the control. All elements with matching <src>class</src> are removed.</p>
            </li>
            <li>
              <p><src>@item-name</src> keys to the element or property name; for example,
                  <code>&lt;remove item-name='prop'/></code> has the effect of removing all
                  <src>prop</src> elements from inside the control. <revisit>(NB: explain how this
                  maps into JSON when items are grouped)</revisit></p>
            </li>
          </ul>
          <p>Unlike an <src>add</src> directive, a <src>remove</src> may not be bound implicitly to
            the control; its binding, to contents inside the control, must be explicit.</p>
          <p>To remove an control, simply avoid selecting it into the profile, or exclude it
            specifically using <src>import/exclude-controls</src>.</p>
          <p>As with <src>add</src>, a remove that targets any element outside the control, is
            inoperative. Similarly, a remove directive that indicates that all <tgt>prop</tgt>
            elements should be removed from the target catalog, applies only to <src>prop</src></p>
        </section>
        <section>
          <head>Implicit alterations</head>
          <p>Finally some alterations are made automatically.</p>
          <p>For example, <src>link</src> elements in source data representing cross-references in a
            catalog, may no longer be effective in catalogs produced from profiles, which have not
            included the elements (controls or other) to which the links refer.</p>
          <p><revisit>Either: expand the links to refer back to the source catalogs; or remove the
              links.</revisit></p>
          <p><revisit>Note: we could also expand links to point back to the (resolved) source,
              particularly if it is described in back-matter as a resource...</revisit></p>
        </section>
      </section>
    </section>
    <section id="finalphase">
      <head>Final Operations</head>
      <section id="target-back-matter">
        <head>Backmatter Resolution</head>
        <p><tgt>back-matter</tgt> in the result is produced by combining all elements within
            <src>back-matter</src> in all source catalogs, with the <src>back-matter</src> in the
          input profile. The merge method and merge structuring directives are ignored. The
          following requirements MUST be adhered to by the processor: </p>
        <ul>
          <li>
            <p>Each import's backmatter is processed in order it was provided in the source profile,
              then the source profile's backmatter is processed.</p>
          </li>
          <li>
            <p>Each <src>resource</src> is added to the target in the order given inside the
              import.</p>
          </li>
          <li>
            <p>If a <src>resource</src> has the same <src>uuid</src> as a resource that has already
              been added, the previous resource is removed, and the more recent one added.</p>
          </li>
          <li>
            <p>A resource with a child prop of name:keep and value:always can only be replaced
              following the above rule by a duplicate that also has the keep always prop.</p>
          </li>
        </ul>
        <p>Tools MAY check for pruning conditions <xref rid="cleanup"/> as resources are added as
          long as the final result is the same as if the pruning had taken place at the end of all
          resource addition.</p>
        <p>Placing the keep always prop on a resource in a catalog has the effect of ensuring it
          will always appear in the output produced by any profile importing that catalog, even if
          nothing links to the resource. This version of the resource will also be the one copied,
          unless a later-imported catalog or importing profile offers its own version marked to keep
          always.</p>
      </section>
      <section id="target-metadata">
        <head>Metadata Resolution</head>
        <p>The following requirements MUST be followed with regards to the Metadata section of the
          output Catalog:</p>
        <ul>
          <li>
            <p>The output catalog MUST have a unique top-level UUID (metadata:uuid). This UUID may
              be generated as seen fit by the tool, as long as it is reasonable to assume it is
              globally unique. It is RECOMMENDED that tools use a combination of meaningful text and
              a uniquely generated value (Ex.
              <code>{{sourceprofilename}}-RESOLVED-{{GUIDv5}}</code>).</p>
          </li>
          <li>
            <p>The value of metadata:version in the target MUST be set with a string that identifies
              the version of this document. This SHOULD differ from the version of the source
              profile, and should be used to track updates to this specific output document. </p>
          </li>
          <li>
            <!-- TODO: OSCAL Version is provided on the site as 1.0.0. This does not match the Namespace/Base URI of http://csrc.nist.gov/ns/oscal/1.0-->
            <p>The value of metadata:oscal-version in the target MUST be set with a string that
              identifies the version of OSCAL used by this tool to resolve the profile (ex. 1.0.0).
              This value MUST be determined by compiling the oscal-versions from each imported
              document and the source profile, and taking the most recent minor version. If this
              version is more recent than what the resolution tool is using, then the value of the
              output oscal-version MUST be the version that the tool used internally. If any of the
              above OSCAL versions (imported document versions, source profile version, tool
              version) are of a different major version (the first digit differs), the tool SHOULD
              provide an error and cease processing. </p>
          </li>
          <li>
            <p>The value of metadata:last-modified in the target MUST be set with a valid timestamp
              representing the time the profile resolution completed. </p>
          </li>
          <li>
            <p>The value of metadata:source-profile in the target SHOULD be set with a valid URI
              that points to the profile that resulted in this catalog. If there are privacy or
              security concerns, the value MAY be set to anything, in which case the simple
              existence of the source-profile property indicates that this is a resolved
              profile.</p>
          </li>
          <li>
            <p>The value of metadata:resolution-tool in the target SHOULD be set with a string that
              represents the tool that was used to resolve this Catalog. </p>
          </li>
        </ul>
        <p>Beyond these requirements, tools are free to use any and all of the objects inside
          metadata to provide additional information downstream.</p>
        <p>Because of options in producing metadata and especially the requirement for a timestamp,
          developers and users should note that two different resolutions of the same profile will
          not, ordinarily, be identical inside <tgt>metadata</tgt>.</p>
      </section>
      <section id="cleanup">
        <head>Pruning</head>
        <p>The processor SHOULD prune the result catalog to remove unused values. A given object is
          considered unused if it meets ALL of the following criteria:</p>
        <ul>
          <li>
            <p>The object does not have a child prop with name:keep and value:always</p>
          </li>
          <li>
            <p>The object is not explicitly included <xref rid="select-phase"/>.</p>
          </li>
          <li>
            <p>There are no references to the object anywhere in the final result catalog, except in
              other objects that also meet all other pruning criteria. A reference to a given object
              exists if "#{distinctiveID}" appears anywhere, where {distinctiveID} is the
              distinctive ID of the object <xref rid="id"/>. </p>
          </li>
        </ul>
        <p>Implementers should note that pruning need not take place after all other steps. As long
          as all above criteria are respected, pruning can happen at any time, and doing so is a
          likely performance and memory overhead improvement. </p>
      </section>
    </section>
  </section>
  <section id="target">
    <head>Target Catalog Requirements</head>
    <p>The following requirements are largely derived from requirements already present in this
      specification, but are repeated here for additional clarity.</p>
    <ul>
      <li>
        <p>The output of a profile resolution MUST take the form of a catalog. Catalog results (the
          output of a conformant profile resolution) MUST be valid to the OSCAL catalog schema.</p>
      </li>
      <li>
        <p>The output of a profile resolution MUST be in the canonical order of an OSCAL catalog as
          defined by the OSCAL Catalog Metaschema: <code>(metadata, param*, control*, group*,
            back-matter?)</code> where <code>group</code> has the model <code>(title?, prop*, part*,
            param*, control*, group*)</code>.</p>
      </li>

      <li>
        <p>The output of a profile resolution MUST obey the ID uniqueness rules of OSCAL. Any
          violations of this rule MUST result in an error.</p>
      </li>
      <li>
        <p>If <src>combine:as-is</src> is used, the structure of the target MUST reflect the
          structure(s) of the source catalog(s). </p>
      </li>
      <li>
        <p>If <src>merge:keep</src> is used (or there is no merge object), the order of the controls
          MUST be placed in import order, with controls within an import keeping the order given by
          the imported catalog. </p>
      </li>
      <li>
        <p>Unless it be for special purposes in a debugging or tracing mode, profile results SHOULD
          not create any groups or structures not described by the source profile. Depending on the
          merge directive, all groups will be given either by the catalog source(s)
            (<src>merge:as-is</src>) or the profile (<src>merge:custom</src>), or there will be no
          groups at all (no merge directive).</p>
      </li>
    </ul>
  </section>
  <section id="other">
    <head>Items of Note</head>
    <section id="id">
      <head>Distinct ID of Objects</head>
      <p>Whenever this specification refers to <q>distinctiveness</q>, it MUST be interpreted as is
        defined in this section with regards to the object in question. </p>

      <p>control,param,group - distinctiveness is defined by the value of the <q>id</q> child
        object.</p>

      <p>resource - distinctiveness is defined by the value of the <q>uuid</q>
        <xref rid="target-back-matter"/>.</p>

      <p>link - distinctiveness is defined by the union of the values of href, rel, and media-type.
        An empty value is considered to be unique. </p>
    </section>

    <section id="multiformat">
      <!-- TODO: How likely is it for new format support to be added? Does this section need to be handle entirely by reference to make the spec static even if new formats are added? -->
      <head>Dealing with Multiple Formats</head>
      <p>Profile Resolution tools MUST be able to handle source profiles, imported catalogs, and
        imported profiles that are serialized in XML, JSON, or YAML. A different serialization
        format of any given input MUST NOT result in a differing output catalog. </p>
      <p>In order to help bootstrap this format management, the following resources are provided for
        implementers:</p>
      <ul>
        <li>
          <p>.
            <!-- TODO: Add links to OSCAL conversion libraries, format guidance pages, etc. --></p>
        </li>
      </ul>
      <p>The following sections provide additional requirements and guidance for each format.</p>
      <section id="xmlrequirements">
        <head>Requirements and Guidance for XML Output</head>
        <p>See <a href="https://pages.nist.gov/OSCAL/reference/latest/complete/xml-definitions/">the
            complete XML reference</a> for model requirements.</p>
        <!-- TODO: Consult XML Wizards on namespacing and other XML requirements -->
      </section>
      <section id="jsonrequirements">
        <head>Requirements and Guidance for JSON Output</head>
        <p>See the <a href="https://pages.nist.gov/OSCAL/reference/latest/complete/json-reference/">
            complete JSON reference</a> for model requirements.</p>
        <p>The JSON format, in general use, does not require the preservation of order of fields. As
          order matters in OSCAL, care should be taken to adhere to the canonical OSCAL order <xref
            rid="order"/> when outputting a catalog in JSON.</p>
      </section>
      <section id="yamlrequirements">
        <head>Requirements and Guidance for YAML Output</head>
        <p>YAML is considered a simple variation on the JSON format. Beyond cosmetic differences
          there are no differences in the information structure between these formats. Therefore,
          the <a href="https://pages.nist.gov/OSCAL/reference/latest/complete/json-reference/">
            complete JSON reference</a> provides model requirements.</p>
        <p>The YAML format, in general use, does not require the preservation of order of fields. As
          order matters in OSCAL, care should be taken to adhere to the canonical OSCAL order <xref
            rid="order"/> when outputting a catalog in YAML.</p>
      </section>
      <section id="order">
        <head>Order of objects in serialization</head>
        <p>In OSCAL, order of objects is always considered important, regardless of the
          serialization used. To facilitate this, OSCAL provides the concept of <term>canonical
            order</term>. This order is provided by the OSCAL Metaschema files for a given document
          type (see <a
            href="https://pages.nist.gov/OSCAL/concepts/layer/overview/#modeling-approach">an
            overview of Metaschema</a>.</p>
        <p>Except where required otherwise, the output catalog MUST be reordered into canonical
          order.</p>
      </section>
      <section id="comments-in-result">
        <head>Comments in result documents</head>
        <p>In an XML-based profile resolution, XML comments are one straightforward way for a
          processor to record events or conditions without affecting the output's nominal semantics.
          To support this, while two processors are obliged to return the same catalog XML for the
          same profile XML inputs, they are not required to match one another's comments, white
          space usage, attribute order, or processing instructions, only each other's elements,
          attributes and data content.</p>
        <p>One consequence of this is that processes intended to compare two profile resolutions may
          have to accommodate differences in comments, considering them as insignificant along with
          other differences in serialization.</p>
      </section>
    </section>

    <!-- TODO: Suggest removal of this section, or move to seperate XML guidance doc
    <section id="valid-endpoints">
      <head>Formal validation of source and result</head>
      <p>In an XML context, document validation is available as a means of determining whether an
        arbitrary XML document entity conforms to structural and naming constraints such as must be
        assumed by processors respecting application semantics. These specifications assume that XML
        inputs for profile resolution will be <em>schema-valid</em> with respect to the OSCAL
          <term>profile</term> model, and hence will be tagged in the namespace
          <code>http://csrc.nist.gov/ns/oscal/1.0</code>.</p>
      <p>Similarly, the definition of the output format or results, is constrained by the OSCAL
          <term>catalog</term> model as defined by its schema.</p>
    </section>
-->


  </section>
</SPECIFICATION>
